阅读当前编译器项目。我们正在实现从llvm ir到rv32的代码生成器，并在实现基于线性扫描算法的寄存器分配时遭遇困难，当前的相关代码是未能正确分配寄存器的，需要你理解其问题并加以修复，然后与已有的代码生成器接合，具体而言我们正在处理的任务如下：

## 总体说明
目标：把 LLVM IR 映射到 RV32 物理寄存器/栈，使用线性扫描（Linear Scan）算法做分配，该算法的思路可以阅读docs\Linear_Scan_Register_Allocation.md 作为参照。
输入假设：IR 已包含基本块、控制流。

---

## 任务（按数据流顺序）
1. **构建基本块（BasicBlock）与 CFG（Control Flow Graph）**
   - 任务：按 IR 中标签与 terminator 指令切分基本块，建立 succ/pred。
   - 输出：`Function` -> `BasicBlock` 列表，且每个 block 填充 `succ` 和 `pred`。
   - 要点：处理 fall-through、switch、异常终止等；维护 label->block 映射。
2. **块线性化（Block Linearization）**
   - 任务：选择块顺序（建议：Reverse Post-Order, RPO），生成块的线性顺序用于给指令编号。
   - 输出：线性化块序列 `blocksInOrder`。
   - 作用：减小 live interval 的断裂，提升分配质量。
3. **位置编号（Position / Instr Index 分配）**
   - 任务：按线性化顺序给每条机器/IR 指令分配唯一位置 `Pos`。建议使用双位方案：`pos_def = idx*2`, `pos_use = idx*2+1`（便于区分 def/use 的相对顺序）。
   - 输出：每条指令的全局 `Pos` 映射 `inst -> pos`。
   - 注意：在插入 spill/restore 时要更新/扩展位置机制（或使用 gap/slot 机制）。
4. **逐块收集 def/use（局部）**
   - 任务：对每个 block，计算 `def[B]`（在本块定义的 vreg）和 `use[B]`（在本块中首次在 def 之前使用的 vreg）。
   - 输出：每个 block 的 `def`/`use` 集合（可用 bitset 表示）。
   - 要点：区分“在块内首次出现的 use”与块外从 liveIn 引入的变量。
5. **全局 liveness 分析（向后数据流）**
   - 任务：根据 `use`/`def` 和 CFG，迭代计算 `liveIn[B]` 与 `liveOut[B]`：
     - `liveOut[B] = ⋃_{s ∈ succ[B]} liveIn[s]`
     - `liveIn[B]  = use[B] ∪ (liveOut[B] - def[B])`
   - 输出：每个 block 的 `liveIn` / `liveOut`（bitset 或稀疏集合）。
6. **构造 LiveInterval（range 列表）**
   - 任务：按 block 内指令顺序，用 `pos` 值为每个 vreg 构造若干 `[start,end]` range：
     - 若 v ∈ liveIn[B]：添加 conservative `[blkStartPos, blkEndPos]`
     - 扫描 block 内指令：对每个 use 添加 / 扩展包含该 use 的 range；对每个 def 从 defPos 扩展到本块最后使用或 blkEnd（若 liveOut）
   - 输出：每个 vreg -> LiveInterval（含多个 LiveRange）
   - 要点：实现 `addRange` 时保持 ranges 有序并合并相邻/重叠段；最后做一次全局合并与排序。
7. **验证（不变量检测）**
   - 任务：检查每个 use 的 pos 是否落入对应 vreg 的 interval；检查 ranges 有序、无重叠、start <= end。
   - 输出：验证报告（错误即定位 bug）。
   - 建议：在这个阶段输出可视化（text/graphviz）帮助定位。
8. **准备寄存器模型与约束**
   - 任务：定义物理寄存器集合、寄存器类别（RegClass，整数/浮点/特殊），调用约定（caller/callee 保存）、保留寄存器（如 SP、zero）。
   - 输出：RegInfo 描述（物理寄存器数量、优先级、caller-saved/callee-saved 列表、参数寄存器映射）。
   - 要点：对 RV32 明确可用的寄存器集（如 x5..x7 做临时等），并考虑紧凑分配。
   - 我们暂时不会用到浮点寄存器。
9. **线性扫描分配主体（LinearScanAllocator）**
	- 任务：对合并后的 intervals （以首段 start 排序）运行线性扫描：
	  - 维护 `active` 集合（当前已分配到物理寄存器的 intervals，按 end 增序排序）
	  - 对每个 interval 执行 `expireOldIntervals`（释放已结束的物理寄存器）
	  - 若有空寄存器：分配一个物理寄存器给该 interval，插入 `active`
	  - 否则：选择一个 interval 久远（最长 live）或启发策略 spill（spill either current or active）, 执行 spill 操作（生成 spill slot/stack slot）
	  - 支持可选的 interval split（在 spill decision 后将 interval 切分，保证后段可以重新分配寄存器）
	- 输出：每个 interval 的分配结果（physical reg 或 spill slot），可能修改 IR（插入 spill/restore/move）
	- 要点：设计清晰的 spill 策略与 split 逻辑，考虑调用点与 register class。
10. **插入 spill/restore（Lowering spill）**
	- 任务：基于分配决定在 IR（或机器指令序列）中插入 load/store：
	  - 如果某 vreg 被 spill 到栈：在每次使用前插入 load 到临时寄存器／在定义后插入 store
	  - 对 split 生成的后段，在 split 点插入必要的 spill/restore/move
	- 输出：带 spill 的新指令序列（并需重新编号 pos，或采用 gap-slot 机制以保持 pos 语义）
	- 注意：插入指令会改变 liveness，需要循环或采用增量策略（常见做法：在插入后重新构造 interval 并重复分配，或在算法中用处理后的 interval 支持 spill slots）。
11. **最终映射与机器指令生成**
	- 任务：把 vreg -> physReg/stackSlot 映射写入最终机器指令（替换虚拟寄存器为物理寄存器，或为 load/store 使用固定寄存器）
	- 输出：最终机器指令流，准备汇编/发射
	- 要点：正确处理 call-conventions、保存/恢复被调用者寄存器，参数传递等。

---

## 推荐类设计（C++ 风格接口说明，参考 LLVM 风格）

### 基本 IR / CFG 类
```cpp
// 轻量化 IR 接口（只含分配器需要的部分）
class Instruction {
public:
    int idx; // 全局编号（分配 pos 前可能未设置）
    int posDef(); // 返回 pos 对应的 def position（pos = idx*2）
    int posUse(); // 返回 pos use (idx*2+1) - 可选
    std::vector<int> uses(); // 虚拟寄存器 id 列表
    int def(); // 返回定义的 vreg id，-1 表示无定义
    bool isTerminator() const;
    std::vector<std::string> branchTargets() const; // label 名称（仅对 terminator）
    // 如果需要：isCall(), calleeSavedClobbers(), isLoad(), isStore(), ...
};

class BasicBlock {
public:
    int id;
    std::string name;
    std::vector<Instruction*> insts;
    std::vector<BasicBlock*> succ;
    std::vector<BasicBlock*> pred;

    int firstPos() const; // pos of first inst
    int lastPos() const;  // pos of last inst
};

class FunctionIR {
public:
    std::string name;
    std::vector<BasicBlock*> blocks;
    // helper: findBlockByName, entryBlock(), ...
};
```

### Liveness / Interval 类

```cpp
struct LiveRange {
    int start; // inclusive
    int end;   // inclusive (或半开  [start, end) )
};

class LiveInterval {
public:
    int vreg;                      // 虚拟寄存器 id
    std::vector<LiveRange> ranges; // 保证 non-overlap, sorted by start

    void addRange(int start, int end); // 插入并合并
    bool contains(int pos) const;
    int start() const; // first range start
    int end() const;   // last range end
    // optional:
    LiveInterval* splitAt(int pos); // 在 pos 切分，返回后半段的新 interval（用于 split）
};
```

### LivenessAnalysis / IntervalBuilder

```cpp
class LivenessAnalysis {
public:
    // 输入：FunctionIR（已构建 CFG 且已线性化并有 inst pos）
    // 输出：populates liveIn/liveOut per block (bitset or vector<int>)
    void run(FunctionIR &F);

    const std::vector<std::vector<int>>& getLiveIn() const;
    const std::vector<std::vector<int>>& getLiveOut() const;
};

class LiveIntervalBuilder {
public:
    LiveIntervalBuilder(FunctionIR &F, const LivenessAnalysis &LA);

    // 构造所有 intervals 并返回映射 vreg -> LiveInterval*
    std::unordered_map<int, LiveInterval> build();
};
```

### Register Model

```cpp
enum class RegClass { GPR, FPR, /* ... */ };

struct PhysReg {
    int id;           // 物理寄存器编号（机器编号）
    RegClass cls;
    bool callerSaved;
    bool calleeSaved;
    bool reserved;    // e.g. sp, zero
};

class RegInfo {
public:
    std::vector<PhysReg> physRegs;
    std::vector<int> freeRegsForClass(RegClass cls) const;
    // utility:
    int numPhysRegs(RegClass cls) const;
    bool isReserved(int phys) const;
};
```

### LinearScanAllocator 主体接口

```cpp
struct AllocationResult {
    // vreg -> phys/reg or spillslot
    std::unordered_map<int,int> vregToPhys;   // phys reg id or -1 if spilled
    std::unordered_map<int,int> vregToStack;  // stack slot index if spilled
};

class LinearScanAllocator {
public:
    LinearScanAllocator(const RegInfo &regInfo);

    // 分配主入口；若需要可传入策略参数
    AllocationResult allocate(FunctionIR &F,
                              std::unordered_map<int, LiveInterval> &intervals);

private:
    // 内部方法（可按需要暴露或替换）
    void expireOldIntervals(int curPos);
    void allocatePhysicalReg(LiveInterval &I);
    void spillAtInterval(LiveInterval &I);
    int chooseSpillCandidate(LiveInterval &I);
    int newSpillSlot(int vreg);
    // active: vector<LiveInterval*> sorted by end
    std::vector<LiveInterval*> active;
    RegInfo regInfo;
};
```

### Spill 插入 / CodeModifier

```cpp
class SpillInserter {
public:
    // 根据 AllocationResult，把 load/store 插入到 IR（或直接在 MachineInstr 层插入）
    // 返回是否需要重新构造 interval（true 表示需要迭代）
    bool insertSpillCode(FunctionIR &F, const AllocationResult &alloc);
};
```

### 验证与调试工具

```cpp
class IntervalVerifier {
public:
    static bool verify(FunctionIR &F, const std::unordered_map<int, LiveInterval> &intervals);
    // 输出详细错误或图形化表示
};
```

------

## 接口使用顺序示例（伪主流程）

```cpp
FunctionIR F = parseIR(...);
buildCFG(F);
linearizeBlocksRPO(F);
assignInstrPositions(F);             // pos = idx*2 / idx*2+1
LivenessAnalysis LA; LA.run(F);
LiveIntervalBuilder builder(F, LA);
auto intervals = builder.build();
for (auto &kv : intervals) kv.second.mergeRanges();

RegInfo regInfo = createRegInfoForRV32();
LinearScanAllocator allocator(regInfo);
auto allocResult = allocator.allocate(F, intervals);

SpillInserter inserter;
bool changed = inserter.insertSpillCode(F, allocResult);
if (changed) {
   // simple approach: re-run whole pipeline (recompute pos, liveness, intervals, allocate)
}
emitMachineCode(F, allocResult);
```

以上伪代码建议仅供参考，用于说明思路，并不强求为规范。但是，我仍然希望你能进行良好封装，并确保语法细节上可以与已有的代码生成器逻辑共同工作，以及提供调试方式，使用调试程序测试分配过程。你的非代码部分回答以及注释部分应使用中文。