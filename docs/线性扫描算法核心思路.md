# 线性扫描寄存器分配算法实现

## 自然语言概括

线性扫描寄存器分配请求函数：
如果程序请求一个存放数据的位置，调用该函数以决定存放到何处。

```bash
LinearScanRegisterAllocation (i) -> 一个空闲寄存器地址 | 一个空闲栈空间地址
	维护一个名为 active 的活动区间集合，初始为空
	对于按起始点位置升序排列的，所有活动区间集合 AllInterval 中的每个活动区间 i 执行操作：
		调用函数 ExpireOldIntervals (i) 以释放所有不会再被使用的寄存器
		如果 (active 集合的元素数 = 寄存器总数 R)
		那么{ 
			// 我们知道所有寄存器都被未过期变量占用
			// 且由于本算法正在被调用，有一个新变量需要立即获得一个物理寄存器
			// 换而言之，发生溢出，需要将一个寄存器中的数据暂存到栈
			return SpillAtIntervals (i)
		}
		否则{
			// 我们决定从空闲寄存器池中取出一个寄存器分配给活跃区间 i 
			将 i 加入 active 集合中，按结束点位置升序排列；
			return 分配到的寄存器地址
		}
```

活动区间是一个Struct，名称为 i ，记录了三项数据：

- 一个对应的虚拟寄存器 %i ；
- 它首次被使用的位置 StartPoint；
- 它最后一次被使用的位置 EndPoint。

一个活动区间 i 在 active 集合中时，它必定满足以下性质：

- 编译器正在处理的指令位置（可以以行数表示），位于 i 的 StartPoint 和 EndPoint 之间；
- 其对应的 %i 的物理值位于物理寄存器中，而不是在栈上。

为了便于算法处理，我们要求：

- 名为 active 的活动区间集合，必须自发按结束点位置升序排列。

```bash
ExpireOldIntervals (i) -> void
	对于按结束点位置升序排列的 active 集合中的每一个活跃区间 j：
		如果 (j.EndPoint 在 i.StartPoint 的后方)
		那么{
			// 我们知道这一个 j 还没有过期，不能移除
			// 由于我们正在遍历按结束点位置升序排列的 active 集合
			// 以后遍历的所有 j 都不会是过期的，无法移除
			没有更多的寄存器可以被释放，此次函数调用结束
			return
		}
		否则{
			// 我们知道这一个 j 过期了，它占用的物理寄存器需要释放
			将 j 从 active 集合中移除
			将 j 正在占用的物理寄存器归还到空闲寄存器池中
			继续检查下一个 j 是否过期
		}
	return
```

 ```bash
 SpillAtInterval (i) -> 一个空闲寄存器地址 | 一个空闲栈空间地址
 	定义一个临时变量 spill ，它指向 active 中结束点最靠后的活跃区间
 	如果 (spill.EndPoint 在 i.EndPoint 的后方)
 	那么{
 		// 我们知道 spill 对应的数据将晚于 i 的失效
 		// 换而言之，它将晚于 i 被使用，更"不急切地"需要寄存器
 		// 所以将 spill 先放置到栈上代价较小
 		// 我们决定将 spill 的寄存器分配给 i
 		将 spill 溢出到内存，为其分配一个新的栈空间
 		从 active 中移除 spill
 		将 i 加入 active，按结束点升序排列
 		return spill 释放出的物理寄存器地址
 	}
 	否则{
 		// 我们知道 spill 对应的数据将早于 i 的失效
 		// 换而言之，它将先于 i 被使用，更"急切地"需要寄存器
 		// 所以拒绝给 i 一个物理寄存器，只给其提供一个栈空间用于 store 数据以待使用
 		return 一个空闲栈空间
 	}
 ```

以上函数的意义是实现"最小代价的溢出"。
这个算法以 **线性地遍历活跃区间** 为核心，保持 `active` 集合中为当前最活跃、最短命（即最早结束最后一次使用而可以释放空闲寄存器）的一组变量分配寄存器，从而实现高效、实时的寄存器分配。

## 任务（按数据流顺序）

1. **构建基本块（BasicBlock）与 CFG（Control Flow Graph）**
	- 任务：按 IR 中标签与 terminator 指令切分基本块，建立 succ/pred。
	- 输出：`Function` -> `BasicBlock` 列表，且每个 block 填充 `succ` 和 `pred`。
	- 要点：处理 fall-through、switch、异常终止等；维护 label->block 映射。
2. **块线性化（Block Linearization）**
	- 任务：选择块顺序（建议：Reverse Post-Order, RPO），生成块的线性顺序用于给指令编号。
	- 输出：线性化块序列 `blocksInOrder`。
	- 作用：减小 live interval 的断裂，提升分配质量。
3. **位置编号（Position / Instr Index 分配）**
	- 任务：按线性化顺序给每条机器/IR 指令分配唯一位置 `Pos`。建议使用双位方案：`pos_def = idx*2`, `pos_use = idx*2+1`（便于区分 def/use 的相对顺序）。
	- 输出：每条指令的全局 `Pos` 映射 `inst -> pos`。
	- 注意：在插入 spill/restore 时要更新/扩展位置机制（或使用 gap/slot 机制）。
4. **逐块收集 def/use（局部）**
	- 任务：对每个 block，计算 `def[B]`（在本块定义的 vreg）和 `use[B]`（在本块中首次在 def 之前使用的 vreg）。
	- 输出：每个 block 的 `def`/`use` 集合（可用 bitset 表示）。
	- 要点：区分“在块内首次出现的 use”与块外从 liveIn 引入的变量。
5. **全局 liveness 分析（向后数据流）**
	- 任务：根据 `use`/`def` 和 CFG，迭代计算 `liveIn[B]` 与 `liveOut[B]`：
		- `liveOut[B] = ⋃_{s ∈ succ[B]} liveIn[s]`
		- `liveIn[B]  = use[B] ∪ (liveOut[B] - def[B])`
	- 输出：每个 block 的 `liveIn` / `liveOut`（bitset 或稀疏集合）。
6. **构造 LiveInterval（range 列表）**
	- 任务：按 block 内指令顺序，用 `pos` 值为每个 vreg 构造若干 `[start,end]` range：
		- 若 v ∈ liveIn[B]：添加 conservative `[blkStartPos, blkEndPos]`
		- 扫描 block 内指令：对每个 use 添加 / 扩展包含该 use 的 range；对每个 def 从 defPos 扩展到本块最后使用或 blkEnd（若 liveOut）
	- 输出：每个 vreg -> LiveInterval（含多个 LiveRange）
	- 要点：实现 `addRange` 时保持 ranges 有序并合并相邻/重叠段；最后做一次全局合并与排序。
7. **验证（不变量检测）**
	- 任务：检查每个 use 的 pos 是否落入对应 vreg 的 interval；检查 ranges 有序、无重叠、start <= end。
	- 输出：验证报告（错误即定位 bug）。
	- 建议：在这个阶段输出可视化（text/graphviz）帮助定位。
8. **准备寄存器模型与约束**
	- 任务：定义物理寄存器集合、寄存器类别（RegClass，整数/浮点/特殊），调用约定（caller/callee 保存）、保留寄存器（如 SP、zero）。
	- 输出：RegInfo 描述（物理寄存器数量、优先级、caller-saved/callee-saved 列表、参数寄存器映射）。
	- 要点：对 RV32 明确可用的寄存器集（如 x5..x7 做临时等），并考虑紧凑分配。
	- 我们暂时不会用到浮点寄存器。
9. **线性扫描分配主体（LinearScanAllocator）**
	- 任务：对合并后的 intervals （以首段 start 排序）运行线性扫描：
		- 维护 `active` 集合（当前已分配到物理寄存器的 intervals，按 end 增序排序）
		- 对每个 interval 执行 `expireOldIntervals`（释放已结束的物理寄存器）
		- 若有空寄存器：分配一个物理寄存器给该 interval，插入 `active`
		- 否则：选择一个 interval 久远（最长 live）或启发策略 spill（spill either current or active）, 执行 spill 操作（生成 spill slot/stack slot）
		- 支持可选的 interval split（在 spill decision 后将 interval 切分，保证后段可以重新分配寄存器）
	- 输出：每个 interval 的分配结果（physical reg 或 spill slot），可能修改 IR（插入 spill/restore/move）
	- 要点：设计清晰的 spill 策略与 split 逻辑，考虑调用点与 register class。
10. **插入 spill/restore（Lowering spill）**
	- 任务：基于分配决定在 IR（或机器指令序列）中插入 load/store：
		- 如果某 vreg 被 spill 到栈：在每次使用前插入 load 到临时寄存器／在定义后插入 store
		- 对 split 生成的后段，在 split 点插入必要的 spill/restore/move
	- 输出：带 spill 的新指令序列（并需重新编号 pos，或采用 gap-slot 机制以保持 pos 语义）
	- 注意：插入指令会改变 liveness，需要循环或采用增量策略（常见做法：在插入后重新构造 interval 并重复分配，或在算法中用处理后的 interval 支持 spill slots）。
11. **最终映射与机器指令生成**
	- 任务：把 vreg -> physReg/stackSlot 映射写入最终机器指令（替换虚拟寄存器为物理寄存器，或为 load/store 使用固定寄存器）
	- 输出：最终机器指令流，准备汇编/发射
	- 要点：正确处理 call-conventions、保存/恢复被调用者寄存器，参数传递等。
