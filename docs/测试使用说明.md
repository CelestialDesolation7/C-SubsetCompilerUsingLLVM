# ToyC 编译器测试使用说明

## 概述

本文档介绍 ToyC 编译器的测试系统使用方法，包括不同平台的测试指令、脚本结构说明以及故障排除指南。

## 测试系统架构

### 目录结构
```
PLCproject/
├── Makefile                    # 主构建文件
├── scripts/                    # 测试脚本目录
│   ├── generate_asm.sh        # 汇编生成脚本
│   ├── generate_ir.sh         # IR生成脚本
│   ├── run_tests.ps1          # PowerShell测试脚本
│   ├── run_tests.bat          # Windows批处理脚本
│   └── test_instr.sh          # 指令测试脚本
├── examples/compiler_inputs/   # 测试用例目录
│   ├── *.c                    # C语言测试文件
│   ├── asm/                   # 生成的汇编文件
│   └── ir/                    # 生成的IR文件
└── src/                       # 编译器源码
```

## 测试指令使用方式

### 1. 使用 Make 命令（推荐）

#### Linux/macOS 环境
```bash
# 构建并运行所有测试
make test

# 仅构建编译器
make build

# 构建寄存器分配测试程序
make unified_test

# 清理构建文件
make clean

# 构建所有目标
make all
```

#### Windows 环境（通过 WSL）
```powershell
# 构建并运行所有测试
wsl make test

# 仅构建编译器
wsl make build

# 构建寄存器分配测试程序
wsl make unified_test

# 清理构建文件
wsl make clean
```

### 2. 使用 PowerShell 脚本

```powershell
# 运行所有测试
powershell -ExecutionPolicy Bypass -File scripts/run_tests.ps1

# 仅构建编译器
powershell -ExecutionPolicy Bypass -File scripts/run_tests.ps1 -BuildOnly

# 构建寄存器分配测试程序（Windows原生）
powershell -ExecutionPolicy Bypass -File scripts/run_tests.ps1 -UnifiedTest

# 启用详细输出
powershell -ExecutionPolicy Bypass -File scripts/run_tests.ps1 -Verbose
```

### 3. 使用批处理文件

```cmd
# 运行所有测试
scripts\run_tests.bat
```

### 4. 手动执行脚本

```bash
# 构建编译器
g++ -std=c++20 -O2 -Wall -o toyc.exe src/*.cpp

# 运行汇编生成测试
bash scripts/generate_asm.sh

# 运行IR生成测试
bash scripts/generate_ir.sh
```

### 5. 寄存器分配测试程序（unified_test）

unified_test 是一个专门用于测试线性扫描寄存器分配器的独立程序。

#### 构建和运行

**方法1：使用PowerShell脚本（推荐，Windows原生）**
```powershell
# 构建寄存器分配测试程序
powershell -ExecutionPolicy Bypass -File scripts/run_tests.ps1 -UnifiedTest

# 运行测试程序
./unified_test.exe
```

**方法2：使用Makefile（WSL环境）**
```bash
# 构建寄存器分配测试程序
wsl make unified_test

# 运行测试程序（需要在WSL中运行）
wsl ./unified_test.exe
```

**方法3：直接编译（Windows原生）**
```powershell
# 直接编译
g++ -std=c++20 -O2 -Wall src/unified_test.cpp src/ra_linear_scan.cpp -o unified_test.exe

# 运行测试程序
./unified_test.exe
```

#### 功能特性
- **交互式菜单**：提供友好的用户界面选择测试用例
- **预定义测试用例**：包含4个典型的测试场景
- **详细调试信息**：输出完整的寄存器分配过程
- **自定义测试**：支持用户输入自定义LLVM IR进行测试

#### 测试用例说明
1. **简单算术测试**：基本的算术运算，测试基本寄存器分配
2. **内存操作测试**：包含内存分配、存储和加载操作
3. **控制流测试**：包含分支控制流的复杂测试用例
4. **寄存器压力测试**：大量虚拟寄存器，可能触发溢出处理

#### 输出信息
- 基本块信息和控制流图
- 寄存器分配详细过程
- 分配结果统计（物理寄存器分配数量、溢出数量等）
- 详细的虚拟寄存器到物理寄存器/栈槽的映射

## 脚本结构详解

### 1. Makefile 结构

```makefile
# 主要目标
all: build                    # 默认目标，构建编译器
build: $(TARGET)             # 构建编译器目标
unified_test: $(UNIFIED_TEST_TARGET)  # 构建寄存器分配测试程序
test: build                  # 测试目标，依赖构建
clean:                       # 清理目标

# 构建规则
$(TARGET): $(MAIN_OBJS)     # 链接主编译器目标文件
$(UNIFIED_TEST_TARGET): $(UNIFIED_TEST_OBJS)  # 链接测试程序目标文件
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp  # 编译源文件
```

**关键特性：**
- 自动依赖管理
- 增量编译
- 跨平台兼容
- 错误检查
- 支持多个独立目标（主编译器和测试程序）

### 2. generate_asm.sh 脚本结构

```bash
#!/usr/bin/env bash

# 1. 环境设置
set -eu                      # 错误时退出，未定义变量报错
if [[ -n "${BASH_VERSION:-}" ]]; then
    set -o pipefail          # 管道失败时退出
fi

# 2. 变量定义
SRC_DIR="examples/compiler_inputs"
OUT_DIR="$SRC_DIR/asm"

# 3. 目录创建
mkdir -p "$OUT_DIR"

# 4. 文件处理循环
for c in "$SRC_DIR"/*.c; do
    # 文件存在性检查
    # ToyC 汇编生成
    # Clang 汇编生成
    # RISC-V GCC 汇编生成
done
```

**功能说明：**
- 为每个 `.c` 文件生成三种汇编输出
- 自动检查工具可用性
- 友好的错误提示
- 跨平台兼容性

### 3. generate_ir.sh 脚本结构

```bash
#!/usr/bin/env bash

# 1. 环境设置（同 generate_asm.sh）
# 2. 变量定义
SRC_DIR="examples/compiler_inputs"
OUT_DIR="$SRC_DIR/ir"

# 3. 目录创建
mkdir -p "$OUT_DIR"

# 4. IR生成循环
for c in "$SRC_DIR"/*.c; do
    # ToyC IR 生成
    # Clang IR 生成
done
```

**功能说明：**
- 生成 LLVM IR 格式文件
- 支持对比分析
- 错误处理机制

### 4. run_tests.ps1 PowerShell 脚本结构

```powershell
# 1. 参数定义
param(
    [switch]$BuildOnly,      # 仅构建标志
    [switch]$Verbose         # 详细输出标志
)

# 2. 错误处理设置
$ErrorActionPreference = "Stop"

# 3. 辅助函数
function Write-Info { ... }   # 信息输出
function Write-Error { ... }  # 错误输出
function Write-Warning { ... } # 警告输出

# 4. 平台检测
$isWindows = $IsWindows -or ($PSVersionTable.Platform -eq "Win32NT")

# 5. 构建和测试逻辑
# 编译器构建
# 脚本存在性检查
# WSL 调用测试
```

**功能说明：**
- 原生 Windows 支持
- 参数化执行
- 彩色输出
- 完善的错误处理

### 5. run_tests.bat 批处理脚本结构

```batch
@echo off
setlocal enabledelayedexpansion

# 1. 编译器构建
g++ -std=c++20 -O2 -Wall -o toyc.exe src\*.cpp

# 2. 脚本存在性检查
if not exist "scripts\generate_asm.sh" (
    echo Error: scripts\generate_asm.sh not found
    exit /b 1
)

# 3. WSL 调用测试
wsl bash scripts/generate_asm.sh
wsl bash scripts/generate_ir.sh
```

**功能说明：**
- 简单的批处理实现
- 基本的错误检查
- WSL 集成

## 测试输出说明

### 生成的文件类型

1. **汇编文件** (`examples/compiler_inputs/asm/`)
   - `*_toyc.s` - ToyC 编译器生成的汇编
   - `*_clang.s` - Clang 生成的汇编（对比用）
   - `*_riscv.s` - RISC-V GCC 生成的汇编（对比用）

2. **IR 文件** (`examples/compiler_inputs/ir/`)
   - `*_toyc.ll` - ToyC 编译器生成的 LLVM IR
   - `*_clang.ll` - Clang 生成的 LLVM IR（对比用）

### 测试用例覆盖

当前包含 15 个测试用例：
- `01_minimal.c` - 最小程序
- `02_assignment.c` - 赋值操作
- `03_if_else.c` - 条件语句
- `04_while_break.c` - 循环和跳转
- `05_function_call.c` - 函数调用
- `06_continue.c` - continue 语句
- `07_scope_shadow.c` - 作用域和变量遮蔽
- `08_short_circuit.c` - 短路求值
- `09_recursion.c` - 递归函数
- `10_void_fn.c` - void 函数
- `11_precedence.c` - 运算符优先级
- `12_division_check.c` - 除法检查
- `13_scope_block.c` - 块作用域
- `14_nested_if_while.c` - 嵌套控制结构
- `15_multiple_return_paths.c` - 多返回路径

## 故障排除

### 常见问题及解决方案

1. **"set: pipefail: invalid option" 错误**
   - **原因**：shell 不支持 pipefail 选项
   - **解决**：已修复，脚本现在会检查 bash 版本

2. **"$'\r': command not found" 错误**
   - **原因**：Windows 行结束符问题
   - **解决**：脚本已使用 Unix 行结束符

3. **"toyc.exe not found" 错误**
   - **原因**：编译器未构建
   - **解决**：先运行 `make build` 或 `g++ -std=c++20 -O2 -Wall -o toyc.exe src/*.cpp`

4. **WSL 代理配置警告**
   - **原因**：WSL 网络配置
   - **解决**：这是信息性警告，不影响功能

5. **缺少工具（clang, riscv32-unknown-elf-gcc）**
   - **原因**：未安装相关工具
   - **解决**：脚本会自动跳过，或安装相应工具

### 环境要求

- **编译器**：支持 C++20 的 g++
- **WSL**：Windows 用户需要安装 WSL
- **可选工具**：clang, riscv32-unknown-elf-gcc（用于对比测试）

### 性能优化建议

1. **增量编译**：使用 `make` 命令利用增量编译
2. **并行测试**：可考虑并行化测试脚本
3. **缓存机制**：避免重复生成相同文件

## 扩展和定制

### 添加新的测试用例

1. 在 `examples/compiler_inputs/` 目录添加 `.c` 文件
2. 脚本会自动发现并处理新文件

### 修改测试脚本

1. **添加新的编译器**：在脚本中添加新的工具调用
2. **修改输出格式**：调整文件命名和目录结构
3. **增加验证逻辑**：添加结果验证和比较

### 集成到 CI/CD

脚本设计支持自动化集成：
- 返回码正确设置
- 错误信息标准化
- 支持静默模式

## 总结

ToyC 编译器的测试系统提供了完整的跨平台测试解决方案，支持多种执行方式和详细的错误处理。通过合理使用不同的测试方法，可以高效地验证编译器的正确性和性能。
