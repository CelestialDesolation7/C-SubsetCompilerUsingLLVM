# 寄存器分配与代码生成详解

## 概述

本文档从整体架构视角解释 ToyC 编译器后端的两大核心模块——寄存器分配器（Register Allocator）和目标代码生成器（Code Generator）——如何协作完成从结构化 IR 到 RISC-V 汇编的翻译。

> 如需逐函数调用链跟踪，请参阅：
> - [从调用链理解的寄存器分配流程](./从调用链理解的寄存器分配流程.md)
> - [从调用链理解的目标代码生成](./从调用链理解的目标代码生成.md)

---

## 一、两遍扫描架构

### 问题：为什么需要两遍扫描？

整个后端采用**先分配、后生成**的两遍架构：

```
                 遍 1: 寄存器分配                 遍 2: 代码生成
IR Module ──→ [LinearScanAllocator] ──→ AllocationResult ──→ [RISCVCodeGen] ──→ .s
```

**遍 1（预计算）**：对每个函数执行活跃性分析和线性扫描分配，确定每个虚拟寄存器的物理寄存器映射或溢出栈偏移。

**遍 2（生成）**：遍历函数中的每条指令，查询遍 1 的分配结果，翻译为 RISC-V 汇编。

这种分离的好处：
1. 代码生成时只需查表，无需处理分配逻辑
2. 栈帧大小（依赖 alloca、溢出数量）在遍 1 结束后就已确定
3. 两个模块可独立测试和修改

### 代码体现

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

std::string RISCVCodeGen::generate(const ir::Module &module) {
    // 遍 1: 为每个函数分配寄存器
    precomputeAllocations(module);

    // 遍 2: 为每个函数生成汇编
    for (auto &func : module.functions)
        generateFunction(*func);

    return getOutput();
}
```

```cpp
void RISCVCodeGen::precomputeAllocations(const ir::Module &module) {
    for (auto &func : module.functions) {
        auto allocator = std::make_unique<LinearScanAllocator>();
        allocator->allocate(*func);                    // 完整的分配流程
        funcAllocators_[func->name] = std::move(allocator);
    }
}
```

---

## 二、结构化 IR 模型

### 旧版 vs 新版 — 根本性变化

旧版编译器使用**字符串 IR**：所有 IR 都是 `std::string`，寄存器分配器和代码生成器通过正则表达式逐行解析。

新版使用**结构化 IR**：IR 由类型安全的 C++ 对象组成，通过枚举和查询方法访问。

| 方面 | 旧版（字符串） | 新版（结构化） |
|------|--------------|---------------|
| IR 表示 | `std::string` | `ir::Module` → `Function` → `BasicBlock` → `Instruction` |
| 操作码 | 正则匹配 `"add"` | `ir::Opcode::Add` 枚举 |
| 操作数 | 正则捕获 `"%5"`, `"42"` | `ir::Operand` (VReg/Imm/Label 等) |
| 定义查询 | 正则 `def()` 函数 | `inst.defReg()` 方法 |
| 使用查询 | 正则 `uses()` 函数 | `inst.useRegs()` 方法 |
| 终结判断 | 字符串匹配 `"br"` | `inst.isTerminator()` |
| 分支目标 | 正则提取标签 | `inst.branchTargets()` |

### 核心类型定义

#### Opcode 枚举

```cpp
// [ir.h](../src/include/ir.h)

enum class Opcode {
    Alloca, Store, Load,           // 内存操作
    Add, Sub, Mul, SDiv, SRem,     // 算术运算
    ICmp,                          // 整数比较
    Br, CondBr,                    // 分支
    Call,                          // 函数调用
    Ret, RetVoid,                  // 返回
    Phi                            // SSA φ 函数（预留）
};
```

#### Operand — 操作数的类型安全封装

```cpp
class Operand {
public:
    enum class Kind { VReg, Imm, Label, Type, None };

    // 工厂方法
    static Operand vreg(int id);           // 虚拟寄存器 %id
    static Operand imm(int val);           // 立即数
    static Operand label(std::string name); // 标签

    // 访问器
    Kind kind() const;
    int regId() const;         // VReg → 寄存器 ID
    int immVal() const;        // Imm → 立即数值
    std::string labelName() const; // Label → 标签名
};
```

#### Instruction — 指令的统一表示

```cpp
class Instruction {
public:
    Opcode op;                     // 操作码
    int result = -1;               // 定义的虚拟寄存器 ID（-1 = 无定义）
    std::vector<Operand> ops;      // 操作数列表
    ir::CmpPred pred = CmpPred::EQ; // 比较谓词（仅 ICmp）
    std::string storeType, loadType; // 存/取类型标注（"i32"/"i1"）

    // 查询方法（寄存器分配器依赖这些）
    int defReg() const;                  // 返回定义的 vreg ID
    std::vector<int> useRegs() const;    // 返回使用的 vreg ID 列表
    bool isTerminator() const;           // 是否为终结指令
    std::vector<std::string> branchTargets() const; // 分支目标标签

    // 位置信息（线性扫描用）
    int index = 0;                       // 指令编号
    int blockId = 0;                     // 所在基本块 ID
    int posDef() const { return index * 2; }
    int posUse() const { return index * 2 + 1; }

    // 工厂方法
    static std::shared_ptr<Instruction> makeAlloca(int result, const std::string &type);
    static std::shared_ptr<Instruction> makeStore(Operand val, Operand ptr, const std::string &type);
    static std::shared_ptr<Instruction> makeLoad(int result, Operand ptr, const std::string &type);
    static std::shared_ptr<Instruction> makeBinOp(Opcode op, int result, Operand lhs, Operand rhs);
    static std::shared_ptr<Instruction> makeICmp(int result, CmpPred pred, Operand lhs, Operand rhs);
    static std::shared_ptr<Instruction> makeBr(Operand target);
    static std::shared_ptr<Instruction> makeCondBr(Operand cond, Operand trueL, Operand falseL);
    static std::shared_ptr<Instruction> makeCall(int result, const std::string &func, std::vector<Operand> args);
    static std::shared_ptr<Instruction> makeRet(Operand val);
    static std::shared_ptr<Instruction> makeRetVoid();
};
```

### defReg() 和 useRegs() 示例

```cpp
// 示例指令: %6 = add i32 %4, %5
// op = Add, result = 6, ops = [VReg(4), VReg(5)]

inst.defReg()    → 6         // 定义 %6
inst.useRegs()   → [4, 5]    // 使用 %4, %5

// 示例指令: store i32 %0, ptr %2
// op = Store, result = -1, ops = [VReg(0), VReg(2)]

inst.defReg()    → -1        // store 不定义寄存器
inst.useRegs()   → [0, 2]    // 使用 %0, %2
```

---

## 三、寄存器分配核心原理

### 3.1 线性扫描算法简述

线性扫描寄存器分配（Linear Scan Register Allocation）比图着色（Graph Coloring）更快，适合在一遍扫描中完成分配：

1. **计算活跃区间**：每个虚拟寄存器的活跃范围 `[start, end]`
2. **按 start 排序**：所有区间按起始位置排序
3. **顺序扫描**：维护一个 `active` 列表（当前占用物理寄存器的区间），对每个新区间：
   - 释放已过期的旧区间
   - 如有空闲寄存器 → 分配
   - 否则 → 溢出（选择 active 中结束最晚的，或当前区间本身）

### 3.2 AllocationResult — 分配与生成的桥梁

```cpp
// [reg_alloc.h](../src/include/reg_alloc.h)

struct AllocationResult {
    std::unordered_map<int, int> vregToPhys;          // vreg → 物理寄存器
    std::unordered_map<int, int> vregToStack;          // vreg → 栈偏移（溢出）
    std::unordered_map<int, int> paramVregToLocation;  // 参数 → a0-a7 或栈偏移
    std::set<int> usedPhysRegs;                        // 使用过的物理寄存器
    std::set<int> calleeSavedRegs;                     // 需要保存的 callee-saved 寄存器
};
```

这个结构是遍 1 和遍 2 之间的唯一接口。代码生成器不需要了解活跃区间、liveIn/liveOut 等分配细节，只需查询：

- **vreg → 物理寄存器**：`vregToPhys[vreg]` → 直接使用物理寄存器名
- **vreg → 溢出栈偏移**：`vregToStack[vreg]` → 需要 `lw`/`sw` 到临时寄存器
- **callee-saved 集合** → 决定 prologue/epilogue 需要保存哪些寄存器

### 3.3 溢出处理策略

当物理寄存器耗尽时，采用**贪心策略**：

```
if active 中有结束更晚的区间:
    溢出那个区间（将其物理寄存器让给当前区间）
else:
    溢出当前区间
```

**直觉**：短区间优先使用物理寄存器，因为占用时间短，能更快释放给后续区间。

溢出的 vreg 存入栈（偏移 -4、-8、-12……递减），使用时通过 `t0`/`t1` 临时寄存器加载：
- `t0` (x5) 和 `t1` (x6) 是保留的溢出临时寄存器，不参与分配
- 两个交替使用，保证同一条指令的两个操作数不冲突

---

## 四、代码生成核心原理

### 4.1 Opcode 分派

代码生成器对每条指令按 `Opcode` 枚举分派到对应的 gen* 方法：

```cpp
switch (inst.op) {
    case Opcode::Alloca:  genAlloca(inst, alloc);  break;
    case Opcode::Store:   genStore(inst, alloc);   break;
    case Opcode::Load:    genLoad(inst, alloc);    break;
    case Opcode::Add: case Opcode::Sub: ...
                          genBinOp(inst, alloc);   break;
    case Opcode::ICmp:    genICmp(inst, alloc);    break;
    case Opcode::CondBr:  genCondBr(inst, alloc);  break;
    case Opcode::Call:    genCall(inst, alloc);     break;
    case Opcode::Ret:     genRet(inst, alloc);     break;
    ...
}
```

### 4.2 resolveUse / resolveDef — 操作数解析

每个 gen* 方法都需要将 IR 操作数（`Operand`）映射为 RISC-V 汇编中的寄存器或立即数。这由两个辅助函数完成：

```
resolveUse(op, alloc, hint):
  Imm     → "li hint, value"  返回 hint
  VReg    → vregToPhys 有映射 → 返回物理寄存器名
          → vregToStack 有映射 → "lw hint, offset(sp)" 返回 hint

resolveDef(vreg, alloc):
  vregToPhys 有映射 → 返回物理寄存器名
  vregToStack 有映射 → 返回 "t0"（之后 spillDefIfNeeded 会 sw 回栈）
```

### 4.3 占位符机制

函数序言（prologue）需要知道栈帧大小，但栈帧大小取决于 alloca 和溢出数量，这些直到遍历完所有指令才能确定。

解决方案——**延迟回填**：

```
第一步：生成代码时先输出占位符
  PROLOGUE_PLACEHOLDER_funcName
  ...（函数体）...
  EPILOGUE_PLACEHOLDER_funcName
  ret

第二步：遍历完成后计算栈帧大小
  frameSize = alloca + ra/s0(8B) + callee-saved + spills → 对齐到16

第三步：字符串替换
  PROLOGUE → addi sp, sp, -frameSize + sw ra + sw s0 + addi s0 + sw callee-saved
  EPILOGUE → lw callee-saved + lw ra + lw s0 + addi sp, sp, frameSize
```

### 4.4 关键优化

#### addi 优化

```
IR: add %x, 5    →  addi rd, rs, 5    （而非 li t0, 5 + add rd, rs, t0）
IR: add 3, %x    →  addi rd, rs, 3    （利用交换律）
IR: sub %x, 2    →  addi rd, rs, -2   （减法转加负数）
```

消除了不必要的 `li` 指令和临时寄存器使用。

#### 分支融合

```
IR:  %c = icmp eq %a, %b     →  asm: sub rd, rs1, rs2 / seqz rd, rd
     br i1 %c, true, false   →  asm: beq rs1, rs2, .true / j .false
```

`genICmp` 将比较操作数缓存到 `cmpMap_`，`genCondBr` 直接使用原始操作数生成条件分支指令（`beq`/`bne`/`blt`/`bgt`/`ble`/`bge`），跳过对比较结果寄存器的 `bnez` 测试。

#### alloca 偏移优化

```
IR:  %2 = alloca i32           →  编译时记录偏移 -4
     store i32 %0, ptr %2      →  sw a0, -4(s0)    （直接用帧指针偏移）
     %4 = load i32, ptr %2     →  lw a0, -4(s0)    （无需先加载指针到寄存器）
```

`allocaOffsets_` 映射表让 `genStore`/`genLoad` 可以直接使用已知的帧偏移，避免额外的指针寄存器操作。

---

## 五、RISC-V 调用约定

### 5.1 寄存器角色

| 寄存器 | ABI名 | 用途 | 保存责任 | 分配器处理 |
|--------|-------|------|---------|-----------|
| x0 | zero | 硬连线 0 | — | reserved |
| x1 | ra | 返回地址 | caller | reserved，prologue 保存 |
| x2 | sp | 栈指针 | callee | reserved |
| x3 | gp | 全局指针 | — | reserved |
| x4 | tp | 线程指针 | — | reserved |
| x5 | t0 | 溢出临时 1 | caller | reserved |
| x6 | t1 | 溢出临时 2 | caller | reserved |
| x7 | t2 | 临时 | caller | 可分配，优先级 20 |
| x8 | s0/fp | 帧指针 | callee | reserved |
| x9 | s1 | 保存 | callee | 可分配，优先级 50 |
| x10-x17 | a0-a7 | 参数/返回值 | caller | 可分配，优先级 0-7 |
| x18-x27 | s2-s11 | 保存 | callee | 可分配，优先级 40-49 |
| x28-x31 | t3-t6 | 临时 | caller | 可分配，优先级 21-24 |

### 5.2 分配优先级策略

```
a0-a7 (0-7)   → 最先使用：参数寄存器，caller-saved，代价最低
t2-t6 (20-24) → 其次：临时寄存器，caller-saved
s2-s11 (40-49) → 最后：callee-saved，需要额外保存/恢复开销
s1 (50)        → 最后的最后
```

**为什么把 a0-a7 排优先**：在没有函数调用的简单函数中，a0-a7 无需额外保存；即使有函数调用，`genCall` 也会自动保存/恢复所有活跃的 caller-saved 寄存器。

### 5.3 函数调用序列

```
调用方 (caller)                      被调用方 (callee)
──────────────────────               ──────────────────────
1. sw: 保存活跃的                     1. addi sp, sp, -frame
   caller-saved 寄存器                2. sw ra, s0 + callee-saved
2. mv args → a0-a7                   3. addi s0, sp, frame
3. call funcName ─────────→           4. ... 函数体 ...
4. lw: 恢复 caller-saved  ←──────── 5. mv result → a0
5. mv a0 → 目标寄存器                 6. lw callee-saved, ra, s0
                                      7. addi sp, sp, frame
                                      8. ret
```

---

## 六、完整数据流追踪

以 `int max(int a, int b) { if (a > b) return a; return b; }` 为例：

### IR 生成（IRBuilder）

```llvm
define i32 @max(i32 %0, i32 %1) {
entry:
  %2 = alloca i32
  store i32 %0, ptr %2
  %3 = alloca i32
  store i32 %1, ptr %3
  %4 = load i32, ptr %2
  %5 = load i32, ptr %3
  %6 = icmp sgt i32 %4, %5
  br i1 %6, label %if_then, label %if_else

if_then:
  %7 = load i32, ptr %2
  ret i32 %7

if_else:
  %8 = load i32, ptr %3
  ret i32 %8
}
```

### 寄存器分配（LinearScanAllocator）

**活跃性分析**：
```
entry:    useSet={%0,%1}  defSet={%2,%3,%4,%5,%6}  liveIn={%0,%1}  liveOut={}
if_then:  useSet={%2}     defSet={%7}               liveIn={%2}     liveOut={}
if_else:  useSet={%3}     defSet={%8}               liveIn={%3}     liveOut={}
```

**注意**：%2 和 %3 在 if_then/if_else 的 liveIn 中出现，因为它们是 alloca 地址，需要跨块访问。

**活跃区间**（假设 RPO: entry, if_then, if_else）：
```
%0: [0, 3]     %1: [0, 7]     %2: [0, 19]    %3: [4, 23]
%4: [8, 13]    %5: [10, 13]   %6: [12, 15]
%7: [18, 19]   %8: [22, 23]
```

**线性扫描**：
```
%0 → a0 (预分配)    %1 → a1 (预分配)
%2 → a2             %3 → a3
%4 → a0 (回收自%0)  %5 → a1 (回收自%1)  %6 → a4
%7 → a0             %8 → a0
```

### 代码生成（RISCVCodeGen）

```asm
    .globl max
    .type max, @function
max:
    addi sp, sp, -16         # prologue
    sw ra, 12(sp)
    sw s0, 8(sp)
    addi s0, sp, 16
    addi a2, s0, -4          # %2 = alloca i32
    sw a0, -4(s0)            # store %0 → %2
    addi a3, s0, -8          # %3 = alloca i32
    sw a1, -8(s0)            # store %1 → %3
    lw a0, -4(s0)            # %4 = load %2
    lw a1, -8(s0)            # %5 = load %3
    slt a4, a1, a0           # %6 = icmp sgt (反转: b < a)
    bgt a0, a1, .max_if_then # 分支融合: a0 > a1 → if_then
    j .max_if_else
.max_if_then:
    lw a0, -4(s0)            # %7 = load %2
    lw ra, 12(sp)            # epilogue
    lw s0, 8(sp)
    addi sp, sp, 16
    ret
.max_if_else:
    lw a0, -8(s0)            # %8 = load %3
    lw ra, 12(sp)            # epilogue
    lw s0, 8(sp)
    addi sp, sp, 16
    ret
```

---

## 七、线性扫描算法对比

### 与标准教科书算法的差异

| 特性 | 教科书 (Poletto & Sarkar) | ToyC 实现 |
|------|--------------------------|-----------|
| 活跃区间 | 单段 [start, end] | 多段 LiveRange 列表，自动合并 |
| 活跃信息 | 仅检查 def-use 链 | 完整的迭代数据流分析（liveIn/liveOut） |
| 溢出决策 | 溢出当前或最久结束 | 同上（贪心：溢出结束最晚的） |
| 分裂 | 不支持 | 预留接口（splitting_ flag） |
| 位置精度 | 按指令编号 | 双精度（posDef=2i, posUse=2i+1） |
| 参数处理 | 不特殊处理 | processParameters 预分配到 a0-a7 |

### 双精度位置的意义

每条指令占两个位置：`posDef = index*2`（偶数）和 `posUse = index*2+1`（奇数）。

```
指令: %6 = add %4, %5
  pos 12 (posDef): %6 在此位置被定义
  pos 13 (posUse): %4, %5 在此位置被使用

→ %4 的区间结束于 13（使用点），%6 的区间起始于 12（定义点）
→ %4 和 %6 的区间可能不重叠（13 > 12 但 %4 在 13 后死亡）
→ 允许它们复用同一个物理寄存器
```

如果使用单精度（一个位置 = 一条指令），def 和 use 在同一位置，无法区分先后关系，可能错误地判断两个区间重叠。
