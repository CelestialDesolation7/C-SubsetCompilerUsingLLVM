# 寄存器分配与代码生成详解

## 概述

本文档从整体架构视角解释 ToyC 编译器后端的两大核心模块——寄存器分配器（Register Allocator）和目标代码生成器（Code Generator）——如何协作完成从结构化 IR 到 RISC-V 汇编的翻译。

> 如需逐函数调用链跟踪，请参阅：
> - [从调用链理解的寄存器分配流程](./从调用链理解的寄存器分配流程.md)
> - [从调用链理解的目标代码生成](./从调用链理解的目标代码生成.md)

---

## 一、两遍扫描架构

### 问题：为什么需要两遍扫描？

整个后端采用**先分配、后生成**的两遍架构：

```
                 遍 1: 寄存器分配                 遍 2: 代码生成
IR Module ──→ [LinearScanAllocator] ──→ AllocationResult ──→ [RISCVCodeGen] ──→ .s
```

**遍 1（预计算）**：对每个函数执行活跃性分析和线性扫描分配，确定每个虚拟寄存器的物理寄存器映射或溢出栈偏移。

**遍 2（生成）**：遍历函数中的每条指令，查询遍 1 的分配结果，翻译为 RISC-V 汇编。

这种分离的好处：
1. 代码生成时只需查表，无需处理分配逻辑
2. 栈帧大小（依赖 alloca、溢出数量）在遍 1 结束后就已确定
3. 两个模块可独立测试和修改

### 代码体现

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

std::string RISCVCodeGen::generate(const ir::Module &module) {
    // 遍 1: 为每个函数分配寄存器
    precomputeAllocations(module);

    // 遍 2: 为每个函数生成汇编
    for (auto &func : module.functions)
        generateFunction(*func);

    return getOutput();
}
```

```cpp
void RISCVCodeGen::precomputeAllocations(const ir::Module &module) {
    for (auto &func : module.functions) {
        auto allocator = std::make_unique<LinearScanAllocator>();
        allocator->allocate(*func);                    // 完整的分配流程
        funcAllocators_[func->name] = std::move(allocator);
    }
}
```

---

## 二、结构化 IR 模型

### 旧版 vs 新版 — 根本性变化

旧版编译器使用**字符串 IR**：所有 IR 都是 `std::string`，寄存器分配器和代码生成器通过正则表达式逐行解析。

新版使用**结构化 IR**：IR 由类型安全的 C++ 对象组成，通过枚举和查询方法访问。

| 方面 | 旧版（字符串） | 新版（结构化） |
|------|--------------|---------------|
| IR 表示 | `std::string` | `ir::Module` → `Function` → `BasicBlock` → `Instruction` |
| 操作码 | 正则匹配 `"add"` | `ir::Opcode::Add` 枚举 |
| 操作数 | 正则捕获 `"%5"`, `"42"` | `ir::Operand` (VReg/Imm/Label 等) |
| 定义查询 | 正则 `def()` 函数 | `inst.defReg()` 方法 |
| 使用查询 | 正则 `uses()` 函数 | `inst.useRegs()` 方法 |
| 终结判断 | 字符串匹配 `"br"` | `inst.isTerminator()` |
| 分支目标 | 正则提取标签 | `inst.branchTargets()` |

### 核心类型定义

#### Opcode 枚举

```cpp
// [ir.h](../src/include/ir.h)

enum class Opcode {
    Alloca, Store, Load,           // 内存操作
    Add, Sub, Mul, SDiv, SRem,     // 算术运算
    ICmp,                          // 整数比较
    Br, CondBr,                    // 分支
    Call,                          // 函数调用
    Ret, RetVoid,                  // 返回
    Phi                            // SSA φ 函数（预留）
};
```

#### Operand — 操作数的类型安全封装

```cpp
class Operand {
public:
    enum class Kind { VReg, Imm, Label, Type, None };

    // 工厂方法
    static Operand vreg(int id);           // 虚拟寄存器 %id
    static Operand imm(int val);           // 立即数
    static Operand label(std::string name); // 标签

    // 访问器
    Kind kind() const;
    int regId() const;         // VReg → 寄存器 ID
    int immVal() const;        // Imm → 立即数值
    std::string labelName() const; // Label → 标签名
};
```

#### Instruction — 指令的统一表示

```cpp
class Instruction {
public:
    Opcode op;                     // 操作码
    int result = -1;               // 定义的虚拟寄存器 ID（-1 = 无定义）
    std::vector<Operand> ops;      // 操作数列表
    ir::CmpPred pred = CmpPred::EQ; // 比较谓词（仅 ICmp）
    std::string storeType, loadType; // 存/取类型标注（"i32"/"i1"）

    // 查询方法（寄存器分配器依赖这些）
    int defReg() const;                  // 返回定义的 vreg ID
    std::vector<int> useRegs() const;    // 返回使用的 vreg ID 列表
    bool isTerminator() const;           // 是否为终结指令
    std::vector<std::string> branchTargets() const; // 分支目标标签

    // 位置信息（线性扫描用）
    int index = 0;                       // 指令编号
    int blockId = 0;                     // 所在基本块 ID
    int posDef() const { return index * 2; }
    int posUse() const { return index * 2 + 1; }

    // 工厂方法
    static std::shared_ptr<Instruction> makeAlloca(int result, const std::string &type);
    static std::shared_ptr<Instruction> makeStore(Operand val, Operand ptr, const std::string &type);
    static std::shared_ptr<Instruction> makeLoad(int result, Operand ptr, const std::string &type);
    static std::shared_ptr<Instruction> makeBinOp(Opcode op, int result, Operand lhs, Operand rhs);
    static std::shared_ptr<Instruction> makeICmp(int result, CmpPred pred, Operand lhs, Operand rhs);
    static std::shared_ptr<Instruction> makeBr(Operand target);
    static std::shared_ptr<Instruction> makeCondBr(Operand cond, Operand trueL, Operand falseL);
    static std::shared_ptr<Instruction> makeCall(int result, const std::string &func, std::vector<Operand> args);
    static std::shared_ptr<Instruction> makeRet(Operand val);
    static std::shared_ptr<Instruction> makeRetVoid();
};
```

### defReg() 和 useRegs() 示例

```cpp
// 示例指令: %6 = add i32 %4, %5
// op = Add, result = 6, ops = [VReg(4), VReg(5)]

inst.defReg()    → 6         // 定义 %6
inst.useRegs()   → [4, 5]    // 使用 %4, %5

// 示例指令: store i32 %0, ptr %2
// op = Store, result = -1, ops = [VReg(0), VReg(2)]

inst.defReg()    → -1        // store 不定义寄存器
inst.useRegs()   → [0, 2]    // 使用 %0, %2
```

---

## 三、寄存器分配核心原理

### 3.1 线性扫描算法简述

线性扫描寄存器分配（Linear Scan Register Allocation）比图着色（Graph Coloring）更快，适合在一遍扫描中完成分配：

1. **计算活跃区间**：每个虚拟寄存器的活跃范围 `[start, end]`
2. **按 start 排序**：所有区间按起始位置排序
3. **顺序扫描**：维护一个 `active` 列表（当前占用物理寄存器的区间），对每个新区间：
   - 释放已过期的旧区间
   - 如有空闲寄存器 → 分配
   - 否则 → 溢出（选择 active 中结束最晚的，或当前区间本身）

### 3.2 AllocationResult — 分配与生成的桥梁

```cpp
// [reg_alloc.h](../src/include/reg_alloc.h)

struct AllocationResult {
    std::unordered_map<int, int> vregToPhys;          // vreg → 物理寄存器
    std::unordered_map<int, int> vregToStack;          // vreg → 栈偏移（溢出）
    std::unordered_map<int, int> paramVregToLocation;  // 参数 → a0-a7 或栈偏移
    std::set<int> usedPhysRegs;                        // 使用过的物理寄存器
    std::set<int> calleeSavedRegs;                     // 需要保存的 callee-saved 寄存器
};
```

这个结构是遍 1 和遍 2 之间的唯一接口。代码生成器不需要了解活跃区间、liveIn/liveOut 等分配细节，只需查询：

- **vreg → 物理寄存器**：`vregToPhys[vreg]` → 直接使用物理寄存器名
- **vreg → 溢出栈偏移**：`vregToStack[vreg]` → 需要 `lw`/`sw` 到临时寄存器
- **callee-saved 集合** → 决定 prologue/epilogue 需要保存哪些寄存器

### 3.3 溢出处理策略

当物理寄存器耗尽时，采用**贪心策略**：

```
if active 中有结束更晚的区间:
    溢出那个区间（将其物理寄存器让给当前区间）
else:
    溢出当前区间
```

**直觉**：短区间优先使用物理寄存器，因为占用时间短，能更快释放给后续区间。

溢出的 vreg 存入栈（偏移 -4、-8、-12……递减），使用时通过 `t0`/`t1` 临时寄存器加载：
- `t0` (x5) 和 `t1` (x6) 是保留的溢出临时寄存器，不参与分配
- 两个交替使用，保证同一条指令的两个操作数不冲突

---

## 四、代码生成核心原理

### 4.1 Opcode 分派

代码生成器对每条指令按 `Opcode` 枚举分派到对应的 gen* 方法：

```cpp
switch (inst.opcode) {
    case Opcode::Alloca:  genAlloca(inst);  break;
    case Opcode::Store:   genStore(inst);   break;
    case Opcode::Load:    genLoad(inst);    break;
    case Opcode::Add: case Opcode::Sub: case Opcode::Mul:
    case Opcode::SDiv: case Opcode::SRem:
                          genBinOp(inst);   break;
    case Opcode::ICmp:    genICmp(inst);    break;
    case Opcode::CondBr:  genCondBr(inst);  break;
    case Opcode::Br:      genBr(inst);      break;
    case Opcode::Ret:     genRet(inst);     break;
    case Opcode::RetVoid:  genRet(inst);    break;
    case Opcode::Call:    genCall(inst);    break;
}
```

每个 gen* 方法只接收 `const Instruction &inst` 单参数。分配结果通过 `funcAllocators_[currentFunction_]->getAllocationResult()` 按需查询，无需逐指令传递。

### 4.2 resolveUse / resolveDef / spillDefIfNeeded — 操作数解析

每个 gen* 方法都需要将 IR 操作数（`Operand`）映射为 RISC-V 汇编中的寄存器或立即数。这由三个辅助函数完成：

```
resolveUse(op):                                          // 无 hint 参数
  Imm/BoolLit → allocateSpillTempReg() 获取 t0 或 t1
              → "li t0/t1, value"  返回 t0/t1
  VReg → vregToPhys 有映射 → 返回物理寄存器名
       → vregToStack 有映射：
           slot > 0 (栈传入参数) → "lw tmp, (slot-4)(s0)"  返回 tmp
           slot < 0 (溢出槽)    → "lw tmp, spillSlotToSpOffset(slot)(sp)"  返回 tmp

resolveDef(op):                                          // 接收 Operand（非 int）
  vregToPhys 有映射 → lastDefRegName_ = 物理寄存器名
  vregToStack 有映射 → lastDefRegName_ = allocateSpillTempReg() 获取 t0/t1
  返回 lastDefRegName_

spillDefIfNeeded(inst):                                  // 在指令生成后调用
  if inst.defReg() 在 vregToStack 且 slot < 0 且不在 allocaOffsets_ 中：
    → "sw lastDefRegName_, spillSlotToSpOffset(slot)(sp)"
```

**关键设计**：`resolveDef` 将结果寄存器名保存到成员变量 `lastDefRegName_`，`spillDefIfNeeded` 直接使用该名称回写栈槽，避免依赖 `allocateSpillTempReg()` 的 counter 状态。`t0`/`t1` 交替分配由 `allocateSpillTempReg()` 内部计数器维护，保证同一条指令的两个 `resolveUse` 调用分别拿到不同的临时寄存器。

### 4.3 占位符机制与栈帧预计算

函数序言（prologue）需要知道栈帧大小，但栈帧大小取决于 alloca 和溢出数量，这些直到遍历完所有指令才能确定。

**预计算（`generateFunction` 入口处）**：在生成指令之前，先扫描所有指令预计算三个固定值：

```
frameOverhead_   = 8（ra + s0）+ calleeSavedCount * 4
callSaveSize_    = 函数内所有 call 指令 → 活跃 caller-saved 寄存器 × 4 的最大值
callArgAreaSize_ = 函数内所有 call 指令 → max(0, 参数数 - 8) × 4 的最大值
```

这三个值决定了栈帧底部固定区域的大小，使溢出槽偏移 `spillSlotToSpOffset()` 和 alloca 偏移 `getAllocaOffset()` 在生成指令时即可正确计算。

**延迟回填**：

```
第一步：生成代码时先输出占位符
  PROLOGUE_PLACEHOLDER_funcName
  ...（函数体，可能有多个 EPILOGUE_PLACEHOLDER_funcName）...
  ret

第二步：遍历完成后计算栈帧大小 (calculateStackFrame)
  spillSize       = max(-slot) 对所有负偏移溢出槽
  allocaSize      = stackOffset_（alloca 累计）
  totalStackSize_ = allocaSize + frameOverhead_ + spillSize + callSaveSize_ + callArgAreaSize_
                    → 对齐到 16

第三步：updateStackFramePlaceholders 字符串替换
  PROLOGUE → addi sp, sp, -totalStackSize_ + sw ra + sw s0 + addi s0 + sw callee-saved
  EPILOGUE → lw callee-saved + lw ra + lw s0 + addi sp, sp, totalStackSize_
  注：epilogue 占位符可能出现多次（多 return 路径），使用 while 循环逐个替换
```

**栈帧布局**（从低地址到高地址）：

```
sp+0                                              → 出栈参数区 (callArgAreaSize_ 字节)
sp+callArgAreaSize_                                → caller-saved 保存区 (callSaveSize_ 字节)
sp+callArgAreaSize_+callSaveSize_                  → 溢出栈槽 (spillSize 字节)
（溢出区上方）                                      → alloca 局部变量 (stackOffset_ 字节)
s0-frameOverhead_...s0-8                           → callee-saved 寄存器
s0-8                                               → old s0
s0-4                                               → ra
s0                                                 → 帧指针顶部 (= sp + totalStackSize_)
```

### 4.4 关键优化

#### addi 优化

```
IR: add %x, 5    →  addi rd, rs, 5    （而非 li t0, 5 + add rd, rs, t0）
IR: add 3, %x    →  addi rd, rs, 3    （利用交换律）
IR: sub %x, 2    →  addi rd, rs, -2   （减法转加负数）
```

消除了不必要的 `li` 指令和临时寄存器使用。优化受 `inAddiRange` 守卫保护：

```cpp
auto inAddiRange = [](int v) { return v >= -2048 && v <= 2047; };
```

只有立即数在 12 位有符号范围 $[-2048, 2047]$ 内时才能使用 `addi`/`addi`（负数形式），超出范围时回退到 `li` + 两寄存器运算。

#### 分支融合

```
IR:  %c = icmp eq %a, %b     →  asm: sub rd, rs1, rs2 / seqz rd, rd
     br i1 %c, true, false   →  asm: beq rs1, rs2, .true / j .false
```

`genICmp` 将比较操作数缓存到 `cmpMap_`，`genCondBr` 直接使用原始操作数生成条件分支指令（`beq`/`bne`/`blt`/`bgt`/`ble`/`bge`），跳过对比较结果寄存器的 `bnez` 测试。

#### alloca 偏移优化

```
IR:  %2 = alloca i32           →  编译时记录偏移 allocaOffsets_[2] = 4
     store i32 %0, ptr %2      →  sw a0, -offset(s0)    （直接用帧指针偏移）
     %4 = load i32, ptr %2     →  lw a0, -offset(s0)    （无需先加载指针到寄存器）
```

其中 `offset = getAllocaOffset(vreg) = allocaOffsets_[vreg] + frameOverhead_`。加上 `frameOverhead_`（= 8 + callee-saved × 4）是为了跳过 ra/s0/callee-saved 保存区，定位到 alloca 变量在帧中的实际位置。

`genAlloca` 本身**不生成任何汇编指令**，仅在 `allocaOffsets_` 映射表中记录偏移，让后续的 `genStore`/`genLoad` 通过 `getAllocaOffset()` 直接使用帧偏移。

---

## 五、RISC-V 调用约定

### 5.1 寄存器角色

| 寄存器 | ABI名 | 用途 | 保存责任 | 分配器处理 |
|--------|-------|------|---------|-----------|
| x0 | zero | 硬连线 0 | — | reserved |
| x1 | ra | 返回地址 | caller | reserved，prologue 保存 |
| x2 | sp | 栈指针 | callee | reserved |
| x3 | gp | 全局指针 | — | reserved |
| x4 | tp | 线程指针 | — | reserved |
| x5 | t0 | 溢出临时 1 | caller | reserved |
| x6 | t1 | 溢出临时 2 | caller | reserved |
| x7 | t2 | 临时 | caller | 可分配，优先级 20 |
| x8 | s0/fp | 帧指针 | callee | reserved |
| x9 | s1 | 保存 | callee | 可分配，优先级 50 |
| x10-x17 | a0-a7 | 参数/返回值 | caller | 可分配，优先级 0-7 |
| x18-x27 | s2-s11 | 保存 | callee | 可分配，优先级 40-49 |
| x28-x31 | t3-t6 | 临时 | caller | 可分配，优先级 21-24 |

### 5.2 分配优先级策略

```
a0-a7 (0-7)   → 最先使用：参数寄存器，caller-saved，代价最低
t2-t6 (20-24) → 其次：临时寄存器，caller-saved
s2-s11 (40-49) → 最后：callee-saved，需要额外保存/恢复开销
s1 (50)        → 最后的最后
```

**为什么把 a0-a7 排优先**：在没有函数调用的简单函数中，a0-a7 无需额外保存；即使有函数调用，`genCall` 也会在调用前将活跃的 caller-saved 寄存器保存到栈（位于 `sp + callArgAreaSize_` 开始的区域）。

### 5.3 函数调用序列（genCall 并行移动修复）

`genCall` 的核心挑战是**并行移动问题**：参数 vreg 可能恰好被分配到某个 a 寄存器上，而 call 约定要求它出现在另一个 a 寄存器中。如果简单地 `mv a0, a1; mv a1, a0`，第二条会读到已被覆盖的值。

**解决方案**：先保存 caller-saved 到栈，再从栈位置加载到目标 a 寄存器。

```
调用方 (caller)                                被调用方 (callee)
──────────────────────────                     ──────────────────────
1. sw: 保存活跃 caller-saved                    1. addi sp, sp, -frame
   → sp + callArgAreaSize_ + 0, +4, ...        2. sw ra, s0 + callee-saved
                                                3. addi s0, sp, frame
2. sw: 超过 8 个参数存到出栈参数区               4. ... 函数体 ...
   → sp + 0, sp + 4, ...                       5. mv result → a0
                                                6. lw callee-saved, ra, s0
3. 前 8 个参数 → a0-a7:                         7. addi sp, sp, frame
   · caller-saved vreg                          8. ret
     → lw ai, saved_offset(sp)  ← 从栈读！
   · callee-saved vreg
     → mv ai, sN               ← 直接移动
   · 溢出 vreg
     → lw ai, spill_offset(sp)
   · 立即数 → li ai, value

4. call funcName ──────────────────→

5. mv defReg, a0                ← 在恢复前取返回值！
6. lw: 恢复 caller-saved 寄存器  ←────────────────────
```

**关键时序**：
- 步骤 5 在步骤 6 **之前**：如果 `defReg` 恰好是某个 caller-saved 寄存器（如 a2），恢复操作会覆盖 a0 之前，先把 a0 移走
- 步骤 3 的 caller-saved 参数从**已保存的栈位置**加载，而非从寄存器移动，彻底消除并行移动冲突

---

## 六、完整数据流追踪

以 `int max(int a, int b) { if (a > b) return a; return b; }` 为例：

### IR 生成（IRBuilder）

```llvm
define i32 @max(i32 %0, i32 %1) {
entry:
  %2 = alloca i32
  store i32 %0, ptr %2
  %3 = alloca i32
  store i32 %1, ptr %3
  %4 = load i32, ptr %2
  %5 = load i32, ptr %3
  %6 = icmp sgt i32 %4, %5
  br i1 %6, label %if_then, label %if_else

if_then:
  %7 = load i32, ptr %2
  ret i32 %7

if_else:
  %8 = load i32, ptr %3
  ret i32 %8
}
```

### 寄存器分配（LinearScanAllocator）

**活跃性分析**：
```
entry:    useSet={%0,%1}  defSet={%2,%3,%4,%5,%6}  liveIn={%0,%1}  liveOut={}
if_then:  useSet={%2}     defSet={%7}               liveIn={%2}     liveOut={}
if_else:  useSet={%3}     defSet={%8}               liveIn={%3}     liveOut={}
```

**注意**：%2 和 %3 在 if_then/if_else 的 liveIn 中出现，因为它们是 alloca 地址，需要跨块访问。

**活跃区间**（假设 RPO: entry, if_then, if_else）：
```
%0: [0, 3]     %1: [0, 7]     %2: [0, 19]    %3: [4, 23]
%4: [8, 13]    %5: [10, 13]   %6: [12, 15]
%7: [18, 19]   %8: [22, 23]
```

**线性扫描**：
```
%0 → a0 (预分配)    %1 → a1 (预分配)
%2 → a2             %3 → a3
%4 → a0 (回收自%0)  %5 → a1 (回收自%1)  %6 → a4
%7 → a0             %8 → a0
```

### 代码生成（RISCVCodeGen）

```asm
    .globl max
    .type max, @function
max:
    addi sp, sp, -16         # prologue
    sw ra, 12(sp)
    sw s0, 8(sp)
    addi s0, sp, 16
                             # %2 = alloca i32（不生成汇编，记录偏移）
    sw a0, -12(s0)           # store %0 → %2（-12 = -(4 + frameOverhead_)）
                             # %3 = alloca i32（不生成汇编，记录偏移）
    sw a1, -16(s0)           # store %1 → %3（-16 = -(8 + frameOverhead_)）
    lw a0, -12(s0)           # %4 = load %2
    lw a1, -16(s0)           # %5 = load %3
                             # %6 = icmp sgt（缓存到 cmpMap_）
    bgt a0, a1, .max_if_then # 分支融合: 直接用 a0 > a1 条件
    j .max_if_else
.max_if_then:
    lw a0, -12(s0)           # %7 = load %2
    lw ra, 12(sp)            # epilogue
    lw s0, 8(sp)
    addi sp, sp, 16
    ret
.max_if_else:
    lw a0, -16(s0)           # %8 = load %3
    lw ra, 12(sp)            # epilogue
    lw s0, 8(sp)
    addi sp, sp, 16
    ret
```

**注意**：与旧版不同，`genAlloca` 不再生成 `addi` 指令计算地址，仅在映射表中记录偏移。`store`/`load` 直接通过 `getAllocaOffset()` 算出 `s0` 相对偏移。此处 `frameOverhead_ = 8`（ra + s0，无 callee-saved），所以 alloca 偏移 4 → 实际 `-(4+8) = -12(s0)`，偏移 8 → 实际 `-(8+8) = -16(s0)`。

---

## 七、线性扫描算法对比

### 与标准教科书算法的差异

| 特性 | 教科书 (Poletto & Sarkar) | ToyC 实现 |
|------|--------------------------|-----------|
| 活跃区间 | 单段 [start, end] | 多段 LiveRange 列表，自动合并 |
| 活跃信息 | 仅检查 def-use 链 | 完整的迭代数据流分析（liveIn/liveOut） |
| 溢出决策 | 溢出当前或最久结束 | 同上（贪心：溢出结束最晚的） |
| 分裂 | 不支持 | 预留接口（splitting_ flag） |
| 位置精度 | 按指令编号 | 双精度（posDef=2i, posUse=2i+1） |
| 参数处理 | 不特殊处理 | processParameters 预分配到 a0-a7 |

### 双精度位置的意义

每条指令占两个位置：`posDef = index*2`（偶数）和 `posUse = index*2+1`（奇数）。

```
指令: %6 = add %4, %5
  pos 12 (posDef): %6 在此位置被定义
  pos 13 (posUse): %4, %5 在此位置被使用

→ %4 的区间结束于 13（使用点），%6 的区间起始于 12（定义点）
→ %4 和 %6 的区间可能不重叠（13 > 12 但 %4 在 13 后死亡）
→ 允许它们复用同一个物理寄存器
```

如果使用单精度（一个位置 = 一条指令），def 和 use 在同一位置，无法区分先后关系，可能错误地判断两个区间重叠。
