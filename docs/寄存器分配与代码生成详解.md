# 寄存器分配与代码生成详解

## 概述

本文档详细解释了C语言子集编译器中的寄存器分配器（Register Allocator）和目标代码生成器（Code Generator）的实现原理和工作流程。

## 一、整体流程回答

### 问题1：是否进行了两次扫描？

**答案：是的！** 整个代码生成过程确实分为两个主要阶段：

1. **第一次扫描（预计算阶段）**：对所有函数的LLVM IR进行扫描，完成虚拟寄存器到物理寄存器的分配
2. **第二次扫描（代码生成阶段）**：再次遍历LLVM IR，根据第一次分配的结果生成最终的RISC-V汇编代码

这两个阶段在 `RISCVGenerator::generateModule()` 函数中体现：

```cpp
std::string RISCVGenerator::generateModule(const std::string &llvmIR)
{
    // 第一次扫描：提前计算所有函数的寄存器分配结果
    precomputeAllFunctionAllocations(llvmIR);
    
    // 第二次扫描：生成汇编代码
    while (std::getline(iss, line)) {
        // 解析函数定义、标签、指令...
        parseLLVMInstruction(line);
    }
}
```

## 二、寄存器分配的完整流程

### 2.1 预处理：从字符串到结构化数据

#### 步骤1：解析函数（parseFunctionFromLLVMIR）

位置：`ra_linear_scan.cpp:1170`

这是整个寄存器分配的第一步，将LLVM IR字符串解析为结构化的 `FunctionIR` 对象。

**输入**：完整的LLVM IR字符串 + 目标函数名

**输出**：`FunctionIR` 对象，包含：
- 函数名
- 基本块列表（`blocks`）
- 基本块名称到指针的映射（`nameToBlock`）
- 参数列表（`parameters`）
- 最大虚拟寄存器编号（`maxVregId`）

**解析过程**：

```cpp
std::unique_ptr<FunctionIR> parseFunctionFromLLVMIR(const std::string &llvmIR, const std::string &funcName)
{
    auto functionIR = std::unique_ptr<FunctionIR>(new FunctionIR());
    BasicBlock *currentBlock = nullptr;
    bool inTargetFunction = false;
    
    // 逐行读取LLVM IR
    while (std::getline(iss, line)) {
        // 1. 识别函数定义行
        if (regex_search(line, funcDefRegex)) {
            // 解析函数参数列表
            parseFunctionParameters(line, *functionIR);
        }
        
        // 2. 识别标签（新基本块的开始）
        if (regex_match(line, labelRegex)) {
            // 创建新的基本块
            auto newBlock = new BasicBlock();
            newBlock->name = labelName;
            functionIR->blocks.push_back(newBlock);
        }
        
        // 3. 识别普通指令
        if (regex_match(line, instRegex)) {
            // 创建指令对象，添加到当前基本块
            auto instruction = new Instruction(instText);
            currentBlock->insts.push_back(instruction);
        }
    }
    
    // 4. 构建控制流图
    functionIR->buildControlFlowGraph();
    
    return functionIR;
}
```

#### 步骤2：构建基本块结构

**基本块（BasicBlock）的组成**：

```cpp
class BasicBlock {
    int id;                                    // 基本块ID（按创建顺序从0开始）
    std::string name;                          // 基本块名称（标签名）
    std::vector<Instruction*> insts;           // 指令列表
    std::vector<BasicBlock*> succ;             // 后继基本块列表
    std::vector<BasicBlock*> pred;             // 前驱基本块列表
    
    // 数据流分析结果
    std::set<int> defSet;   // 本块定义的虚拟寄存器集合
    std::set<int> useSet;   // 本块使用但未定义的虚拟寄存器集合
    std::set<int> liveIn;   // 块入口处活跃的虚拟寄存器集合
    std::set<int> liveOut;  // 块出口处活跃的虚拟寄存器集合
};
```

**指令（Instruction）的组成**：

```cpp
class Instruction {
    std::string text;   // 指令原文（例如："%3 = add nsw i32 %1, %2"）
    int idx;            // 全局顺序编号（线性化后设置）
    int blockId;        // 所属基本块ID
    
    // 位置编号：使用双位方案
    int posDef() const { return idx * 2; }      // 定义位置
    int posUse() const { return idx * 2 + 1; }  // 使用位置
    
    // 解析方法
    std::vector<int> uses() const;  // 返回使用的虚拟寄存器列表
    int def() const;                // 返回定义的虚拟寄存器ID（-1表示无定义）
};
```

**示例：LLVM IR到基本块的转换**

```llvm
define i32 @main() {
entry:
  %1 = alloca i32
  store i32 10, ptr %1
  br label %loop

loop:
  %2 = load i32, ptr %1
  %3 = icmp sgt i32 %2, 0
  br i1 %3, label %body, label %exit

body:
  %4 = sub nsw i32 %2, 1
  store i32 %4, ptr %1
  br label %loop

exit:
  ret i32 0
}
```

转换后的基本块结构：

```
BasicBlock 0 (entry):
  - Instruction 0: "%1 = alloca i32"
  - Instruction 1: "store i32 10, ptr %1"
  - Instruction 2: "br label %loop"
  - succ: [BasicBlock 1]

BasicBlock 1 (loop):
  - Instruction 3: "%2 = load i32, ptr %1"
  - Instruction 4: "%3 = icmp sgt i32 %2, 0"
  - Instruction 5: "br i1 %3, label %body, label %exit"
  - pred: [BasicBlock 0, BasicBlock 2]
  - succ: [BasicBlock 2, BasicBlock 3]

BasicBlock 2 (body):
  - Instruction 6: "%4 = sub nsw i32 %2, 1"
  - Instruction 7: "store i32 %4, ptr %1"
  - Instruction 8: "br label %loop"
  - pred: [BasicBlock 1]
  - succ: [BasicBlock 1]

BasicBlock 3 (exit):
  - Instruction 9: "ret i32 0"
  - pred: [BasicBlock 1]
  - succ: []
```

#### 步骤3：构建控制流图（CFG）

位置：`ra_linear_scan.cpp:164` `FunctionIR::buildControlFlowGraph()`

**目的**：建立基本块之间的前驱（pred）和后继（succ）关系

**方法**：
1. 检查每个基本块的最后一条指令（终止指令）
2. 如果是分支指令，提取分支目标标签
3. 根据标签名在 `nameToBlock` 映射中找到目标基本块
4. 建立当前块和目标块的后继/前驱关系

```cpp
void FunctionIR::buildControlFlowGraph() {
    for (auto &block : blocks) {
        auto &lastInst = block->insts.back();
        if (lastInst->isTerminator()) {
            // 获取分支目标
            std::vector<std::string> targets = lastInst->branchTargets();
            
            for (const std::string &target : targets) {
                BasicBlock *succBlock = nameToBlock[target];
                block->succ.push_back(succBlock);
                succBlock->pred.push_back(block);
            }
        }
        // 如果不是终止指令，存在fall-through关系
    }
}
```

### 2.2 指令编号机制

#### 双位编号方案

位置：`ra_linear_scan.h:67` `Instruction::posDef()` 和 `posUse()`

每条指令在线性化后会被赋予一个 `idx`（从0开始），并使用双位方案计算位置：

- **定义位置（def）**：`idx * 2`
- **使用位置（use）**：`idx * 2 + 1`

**原因**：保证定义总是在使用之前发生，即使在同一条指令中（如 `%3 = add i32 %1, %2`）

**示例**：

```
Instruction 0: "%1 = alloca i32"
  - idx = 0
  - posDef = 0 (定义 %1)
  - posUse = 1

Instruction 1: "store i32 10, ptr %1"
  - idx = 1
  - posDef = 2
  - posUse = 3 (使用 %1)

Instruction 2: "%2 = load i32, ptr %1"
  - idx = 2
  - posDef = 4 (定义 %2)
  - posUse = 5 (使用 %1)
```

### 2.3 数据流分析

#### 阶段1：计算USE和DEF集合

位置：`ra_linear_scan.cpp:417` `LivenessAnalysis::computeUseDefSets()`

**目的**：为每个基本块计算：
- `defSet`：在本块中定义的虚拟寄存器
- `useSet`：在本块中使用但在使用前未定义的虚拟寄存器

**算法**：按基本块内的指令顺序正向扫描

```cpp
void LivenessAnalysis::computeUseDefSets(FunctionIR &F) {
    for (BasicBlock *block : F.blocksInOrder) {
        std::set<int> localDef;  // 块内已定义的寄存器
        
        for (auto &inst : block->insts) {
            // 1. 处理使用：如果使用的寄存器还未在本块定义，加入useSet
            for (int vreg : inst->uses()) {
                if (localDef.find(vreg) == localDef.end()) {
                    block->useSet.insert(vreg);
                }
            }
            
            // 2. 处理定义：将定义的寄存器加入defSet和localDef
            int defVreg = inst->def();
            if (defVreg != -1) {
                block->defSet.insert(defVreg);
                localDef.insert(defVreg);
            }
        }
    }
}
```

**示例**：

```llvm
loop:                        ; BasicBlock 1
  %2 = load i32, ptr %1      ; 使用 %1（未在本块定义）-> useSet
  %3 = icmp sgt i32 %2, 0    ; 定义 %3, 使用 %2（已在本块定义）
  br i1 %3, label %body, label %exit
```

结果：
- `defSet = {2, 3}`
- `useSet = {1}`

#### 阶段2：活跃性分析（Liveness Analysis）

位置：`ra_linear_scan.cpp:459` `LivenessAnalysis::computeLivenessIteratively()`

**目的**：计算每个基本块的 `liveIn` 和 `liveOut` 集合

**算法**：基于数据流方程的迭代算法（逆后序遍历 + 不动点迭代）

**数据流方程**：

```
liveOut[B] = ∪ liveIn[S]  (S ∈ succ(B))
liveIn[B] = use[B] ∪ (liveOut[B] - def[B])
```

**代码实现**：

```cpp
void LivenessAnalysis::computeLivenessIteratively(FunctionIR &F) {
    // 构建逆后序遍历（RPO）
    F.blocksInOrder = buildRPO(F.entryBlock());
    
    bool changed = true;
    while (changed) {
        changed = false;
        
        // 逆序遍历基本块（从出口到入口）
        for (int i = F.blocksInOrder.size() - 1; i >= 0; --i) {
            BasicBlock *block = F.blocksInOrder[i];
            
            // 1. 计算 liveOut = ∪ succ.liveIn
            std::set<int> newLiveOut;
            for (BasicBlock *succ : block->succ) {
                newLiveOut.insert(succ->liveIn.begin(), succ->liveIn.end());
            }
            
            // 2. 计算 liveIn = use ∪ (liveOut - def)
            std::set<int> newLiveIn = block->useSet;
            for (int vreg : newLiveOut) {
                if (!block->defSet.count(vreg)) {
                    newLiveIn.insert(vreg);
                }
            }
            
            // 3. 检查是否变化
            if (newLiveIn != block->liveIn || newLiveOut != block->liveOut) {
                changed = true;
                block->liveIn = newLiveIn;
                block->liveOut = newLiveOut;
            }
        }
    }
}
```

**示例**（继续上面的循环例子）：

```
BasicBlock 1 (loop):
  - defSet = {2, 3}
  - useSet = {1}
  - succ = [body, exit]
  
第一次迭代：
  - liveOut = body.liveIn ∪ exit.liveIn = {2} ∪ {} = {2}
  - liveIn = {1} ∪ ({2} - {2, 3}) = {1}

第二次迭代：
  - liveOut = {1, 2}  (因为body块会跳回loop，%1和%2在body中活跃)
  - liveIn = {1} ∪ ({1, 2} - {2, 3}) = {1}

不动点达到，迭代结束
```

### 2.4 构建活跃区间（Live Intervals）

位置：`ra_linear_scan.cpp:577` `LiveIntervalBuilder::build()`

**目的**：为每个虚拟寄存器构建其活跃区间，即该寄存器从定义到最后使用的位置范围

**活跃区间（LiveInterval）的结构**：

```cpp
class LiveInterval {
    int vreg;                         // 虚拟寄存器ID
    std::vector<LiveRange> ranges;    // 活跃范围列表（可能有多个不连续的范围）
    int physReg;                      // 分配的物理寄存器ID
    int spillSlot;                    // 溢出槽索引
};

struct LiveRange {
    int start;  // 起始位置（包含）
    int end;    // 结束位置（包含）
};
```

**构建算法**：

```cpp
std::unordered_map<int, LiveInterval*> LiveIntervalBuilder::build() {
    // 为每个虚拟寄存器创建活跃区间
    for (int vreg = 0; vreg <= F.maxVregId; ++vreg) {
        auto interval = new LiveInterval(vreg);
        buildIntervalForVreg(vreg, interval);
        intervals[vreg] = interval;
    }
    return intervals;
}

void LiveIntervalBuilder::buildIntervalForVreg(int vreg, LiveInterval *interval) {
    // 遍历所有基本块
    for (BasicBlock *block : F.blocksInOrder) {
        bool liveAtStart = block->liveIn.count(vreg);
        bool liveAtEnd = block->liveOut.count(vreg);
        
        int rangeStart = liveAtStart ? block->firstPos() : -1;
        int rangeEnd = liveAtEnd ? block->lastPos() : -1;
        
        // 扫描块内指令，精确计算活跃范围
        for (auto &inst : block->insts) {
            // 定义点
            if (inst->def() == vreg) {
                rangeStart = inst->posDef();
                rangeEnd = liveAtEnd ? block->lastPos() : inst->posDef();
            }
            
            // 使用点
            for (int use : inst->uses()) {
                if (use == vreg) {
                    if (rangeStart == -1) {
                        rangeStart = liveAtStart ? block->firstPos() : inst->posUse();
                    }
                    rangeEnd = max(rangeEnd, inst->posUse());
                }
            }
        }
        
        // 添加活跃范围
        if (rangeStart != -1 && rangeEnd != -1) {
            interval->addRange(rangeStart, rangeEnd);
        }
    }
}
```

**示例**：

对于虚拟寄存器 `%2`：

```
Instruction 3: "%2 = load i32, ptr %1"   (idx=3, def=6, use=7)
Instruction 4: "%3 = icmp sgt i32 %2, 0" (idx=4, def=8, use=9, uses %2)
Instruction 6: "%4 = sub nsw i32 %2, 1"  (idx=6, def=12, use=13, uses %2)

活跃区间：
%2: [6, 13]  (从定义位置6到最后使用位置13)
```

### 2.5 线性扫描寄存器分配

位置：`ra_linear_scan.cpp:869` `LinearScanAllocator::runLinearScan()`

**算法流程**：

1. **排序**：将所有活跃区间按起始位置排序
2. **扫描**：按顺序处理每个区间
3. **过期处理**：释放已结束的区间占用的物理寄存器
4. **分配或溢出**：
   - 如果有空闲寄存器：分配物理寄存器
   - 如果没有空闲寄存器：溢出到栈

**数据结构**：

```cpp
class LinearScanAllocator {
    std::set<int> freePhysRegs;              // 空闲物理寄存器集合（按优先级排序）
    std::list<LiveInterval*> active;         // 当前活跃的区间列表（按结束位置排序）
    std::vector<bool> isPhysRegUsed;         // 物理寄存器使用状态
    AllocationResult result;                 // 分配结果
};
```

**核心代码**：

```cpp
AllocationResult LinearScanAllocator::runLinearScan(intervals) {
    // 1. 按起始位置排序
    std::vector<LiveInterval*> sortedIntervals = sortByStart(intervals);
    
    // 2. 线性扫描
    for (LiveInterval *interval : sortedIntervals) {
        // 2.1 释放已过期的区间
        expireOldIntervals(interval->start());
        
        // 2.2 分配或溢出
        if (freePhysRegs.empty()) {
            spillAtInterval(*interval);  // 溢出到栈
        } else {
            allocatePhysicalReg(*interval);  // 分配物理寄存器
        }
    }
    
    return result;
}

void LinearScanAllocator::expireOldIntervals(int curStart) {
    // 遍历active列表（按结束位置排序）
    auto it = active.begin();
    while (it != active.end()) {
        LiveInterval *interval = *it;
        
        if (interval->end() < curStart) {
            // 区间已过期，释放其物理寄存器
            freePhysReg(interval->physReg);
            it = active.erase(it);
        } else {
            break;  // 后续区间都未过期
        }
    }
}

void LinearScanAllocator::allocatePhysicalReg(LiveInterval &interval) {
    // 分配优先级最高的空闲寄存器
    int physReg = *freePhysRegs.begin();
    freePhysRegs.erase(physReg);
    
    interval.physReg = physReg;
    result.vregToPhys[interval.vreg] = physReg;
    
    // 插入active列表（保持按结束位置排序）
    insertActiveInterval(&interval);
}

void LinearScanAllocator::spillAtInterval(LiveInterval &interval) {
    // 分配栈槽
    int spillSlot = allocateSpillSlot();
    interval.spillSlot = spillSlot;
    result.vregToStack[interval.vreg] = spillSlot * 4;  // 字节偏移
}
```

**分配结果（AllocationResult）**：

```cpp
struct AllocationResult {
    std::unordered_map<int, int> vregToPhys;   // vreg -> 物理寄存器ID
    std::unordered_map<int, int> vregToStack;  // vreg -> 栈字节偏移
    std::set<int> usedPhysRegs;                // 使用的物理寄存器集合
    std::set<int> calleeSavedRegs;             // 需要保存的被调用者保存寄存器
};
```

### 2.6 物理寄存器优先级

位置：`ra_linear_scan.cpp:314` `RegInfo::RegInfo()`

**RISC-V寄存器分类**：

```cpp
RegInfo::RegInfo() {
    // 临时寄存器（caller-saved，优先级高）
    physRegs.push_back({5,  "t0", true,  false, false, 0});  // 最高优先级
    physRegs.push_back({6,  "t1", true,  false, false, 1});
    physRegs.push_back({7,  "t2", true,  false, false, 2});
    physRegs.push_back({28, "t3", true,  false, false, 3});
    physRegs.push_back({29, "t4", true,  false, false, 4});
    physRegs.push_back({30, "t5", true,  false, false, 5});
    physRegs.push_back({31, "t6", true,  false, false, 6});
    
    // 保存寄存器（callee-saved，优先级低）
    physRegs.push_back({9,  "s1", false, true,  false, 7});
    physRegs.push_back({18, "s2", false, true,  false, 8});
    physRegs.push_back({19, "s3", false, true,  false, 9});
    
    // 参数/返回值寄存器（caller-saved）
    physRegs.push_back({10, "a0", true,  false, false, 10});
    physRegs.push_back({11, "a1", true,  false, false, 11});
    // ...
    
    // 保留寄存器（不参与分配）
    physRegs.push_back({0,  "zero", false, false, true, 999});  // 硬件零寄存器
    physRegs.push_back({2,  "sp",   false, false, true, 999});  // 栈指针
    physRegs.push_back({8,  "s0",   false, false, true, 999});  // 帧指针
}
```

**优先级策略**：
1. 临时寄存器（t0-t6）：最高优先级，不需要保存/恢复
2. 参数寄存器（a0-a7）：中等优先级
3. 保存寄存器（s1-s11）：最低优先级，需要在函数入口保存、出口恢复

## 三、代码生成阶段

### 3.1 查询分配结果

在第二次扫描中，代码生成器需要查询虚拟寄存器对应的物理寄存器或栈位置。

**主要接口**：

```cpp
// riscv_gen.cpp:950
std::string RISCVGenerator::parseRegUse(const std::string &vreg) {
    int vregId = stoi(vreg.substr(1));  // "%3" -> 3
    
    // 从分配结果中查询
    auto &result = functionAllocators[currentFunction]->getAllocationResult();
    
    // 1. 检查是否分配到物理寄存器
    if (result.vregToPhys.count(vregId)) {
        int physReg = result.vregToPhys[vregId];
        return regInfo.getReg(physReg).name;  // 返回 "t0", "a1" 等
    }
    
    // 2. 检查是否溢出到栈
    if (result.vregToStack.count(vregId)) {
        int stackOffset = result.vregToStack[vregId];
        // 生成加载指令，使用临时寄存器
        int tempReg = allocator->allocateSpillTempReg();
        addInstruction("lw " + regInfo.getReg(tempReg).name + 
                      ", " + to_string(stackOffset) + "(sp)");
        return regInfo.getReg(tempReg).name;
    }
}
```

### 3.2 代码生成示例

**LLVM IR**：

```llvm
%3 = add nsw i32 %1, %2
```

**查询分配结果**：
- `%1` -> `t0` (物理寄存器)
- `%2` -> `t1` (物理寄存器)
- `%3` -> `t2` (物理寄存器)

**生成的RISC-V汇编**：

```asm
add t2, t0, t1
```

**如果 `%2` 被溢出到栈（偏移-16）**：

```asm
lw  t3, -16(sp)    # 加载 %2 到临时寄存器
add t2, t0, t3     # 执行加法
```

## 四、总结

### 编号和划分机制总结

1. **基本块划分**：按照标签（label）划分，每个标签代表一个新的基本块开始
2. **指令编号**：
   - 全局顺序编号 `idx`（0, 1, 2, ...）
   - 双位编号方案：`def = idx * 2`, `use = idx * 2 + 1`
3. **虚拟寄存器标识**：使用 `%数字` 格式，例如 `%1`, `%2`, `%42`
4. **物理寄存器编号**：从0开始的整数ID，映射到RISC-V寄存器名称

### 两次扫描的优点

1. **第一次扫描**：
   - 全局视角分析所有函数
   - 完整的数据流分析
   - 最优的寄存器分配决策

2. **第二次扫描**：
   - 直接查询分配结果
   - 无需重新计算
   - 代码生成高效

### 关键数据结构流转

```
LLVM IR 字符串
    ↓ [parseFunctionFromLLVMIR]
FunctionIR (基本块 + 指令)
    ↓ [buildControlFlowGraph]
控制流图 (CFG)
    ↓ [LivenessAnalysis]
活跃性分析结果 (liveIn/liveOut)
    ↓ [LiveIntervalBuilder]
活跃区间 (LiveIntervals)
    ↓ [LinearScanAllocator]
分配结果 (vregToPhys, vregToStack)
    ↓ [generateModule]
RISC-V 汇编代码
```

这个设计清晰地分离了分析阶段和代码生成阶段，使得代码易于理解和维护。
