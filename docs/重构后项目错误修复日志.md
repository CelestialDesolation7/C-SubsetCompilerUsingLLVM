# 重构后项目错误修复日志

## 概述

ToyC 编译器经历了从单体文件到模块化架构的完整重构（9 个头文件 + 10 个实现文件，CMake 构建系统）。重构完成后，在端到端验证（`make verify`）过程中暴露了 11 个代码生成与 IR 构建 Bug。本文档逐一记录每个 Bug 的**现象、根因分析、数据流追踪**和**修复方案**。

> 所有修复完成后：36/36 单元测试 + 36/36 QEMU 端到端验证全部通过。

---

## Bug #1：alloca 偏移未计入帧开销 → SIGSEGV

### 现象

所有包含局部变量的测试在 QEMU 执行时触发 **SIGSEGV**（段错误）。

### 根因分析

[riscv_codegen.cpp](../src/riscv_codegen.cpp) 中 `genAlloca` 计算栈地址时直接使用 `stackOffset_`：

```cpp
// BUG: alloca 偏移 = -stackOffset_，未考虑 ra/s0/callee-saved 区域
allocaOffsets_[vreg] = -stackOffset_;
emit("addi " + rd + ", s0, " + std::to_string(-stackOffset_));
```

**问题**：`s0` 指向帧顶，`s0-4` 是 ra、`s0-8` 是旧 s0，再往下是 callee-saved 寄存器。如果 alloca 偏移从 `-4` 开始，就会**覆盖 ra 和 s0 的保存区域**，导致函数返回时跳转到非法地址。

```
s0 → ┌──────────┐
     │    ra     │ -4(s0)  ← 被 alloca 覆盖！
     │   old s0  │ -8(s0)  ← 被 alloca 覆盖！
     │ callee-sv │ -12(s0)
     │   alloca  │ -16(s0) ← 实际应从这里开始
     └──────────┘
```

### 修复

引入 `frameOverhead_` 成员变量，在 `generateFunction` 入口处预计算 `ra + s0 + callee-saved` 的总大小，`getAllocaOffset` 自动加上该偏移：

```cpp
// [riscv_codegen.cpp] generateFunction 入口
frameOverhead_ = 8 + calleeSavedCount * 4;

// [riscv_codegen.cpp] getAllocaOffset
int RISCVCodeGen::getAllocaOffset(int vreg) {
    return allocaOffsets_[vreg] + frameOverhead_;  // 越过 ra/s0/callee-saved
}
```

**修复后布局**：

```
s0 → ┌──────────┐
     │    ra     │ -4(s0)
     │   old s0  │ -8(s0)
     │ callee-sv │ -12(s0) ... -(8+N)(s0)
     │  alloca 1 │ -(frameOverhead_+4)(s0)   ← 正确起始位置
     │  alloca 2 │ -(frameOverhead_+8)(s0)
     └──────────┘
```

---

## Bug #2：IRBuilder 未设置 maxVregId → 活跃区间构建遗漏

### 现象

部分函数的寄存器分配结果不完整，后续虚拟寄存器未被分配到物理寄存器或栈槽。

### 根因分析

[ir_builder.cpp](../src/ir_builder.cpp) 中 `buildFunction` 构建完成函数后，未将 `vregCounter_` 写入 `Function::maxVregId`。`LiveIntervalBuilder::build()` 依赖 `maxVregId` 来遍历所有虚拟寄存器：

```cpp
// LiveIntervalBuilder::build()
for (int vreg = 0; vreg <= F_.maxVregId; ++vreg) { ... }
```

如果 `maxVregId` 为 0（默认值），循环只处理 `%0`，其余所有虚拟寄存器的活跃区间不会被构建。

### 修复

在 `buildFunction` 末尾、函数加入模块之前，设置 `maxVregId`：

```cpp
// [ir_builder.cpp] buildFunction 末尾
func->maxVregId = vregCounter_;
module_->functions.push_back(std::move(func));
```

---

## Bug #3：genCall 中返回值被恢复操作覆盖

### 现象

函数调用返回值（a0）被后续的 caller-saved 寄存器恢复操作覆盖，导致返回值丢失。

### 根因分析

旧版 `genCall` 的执行顺序：

```
1. 保存 caller-saved 寄存器（sw a0-a7 → sp）
2. 设置参数到 a0-a7
3. call funcName
4. 恢复 caller-saved 寄存器（lw sp → a0-a7）  ← a0 的返回值被覆盖！
5. mv a0 → 目标寄存器                          ← 此时 a0 已经是恢复后的旧值
```

### 修复

将返回值的 `mv` 移到恢复操作**之前**：

```cpp
// [riscv_codegen.cpp] genCall
emit("call " + inst.callee);

// 先取出返回值（在 a0 被恢复覆盖之前）
std::string defReg = resolveDef(inst.def);
if (defReg != "a0")
    emit("mv " + defReg + ", a0");

// 然后恢复 caller-saved 寄存器
for (int reg : savedRegs) {
    emit("lw " + regInfo_.getRegName(reg) + ", " + ...);
}
```

---

## Bug #4：callSaveSize 未纳入栈帧计算

### 现象

当函数内有函数调用时，caller-saved 寄存器的保存区域与其他栈区域重叠，导致数据损坏。

### 根因分析

`genCall` 在 `sp+0` 处保存 caller-saved 寄存器，但 `calculateStackFrame` 并未为这些保存区域预留空间。溢出栈槽也从 `sp` 底部开始计算，两者发生地址冲突。

### 修复

引入 `callSaveSize_` 成员变量，在 `generateFunction` 入口预计算所有 caller-saved 寄存器的保存区大小，并将其纳入栈帧总大小：

```cpp
// [riscv_codegen.cpp] generateFunction
{
    std::set<int> csRegs;
    for (auto &[vreg, physReg] : alloc.vregToPhys) {
        if (regInfo_.isCallerSaved(physReg) &&
            !funcAllocators_[currentFunction_]->isSpillTempReg(physReg))
            csRegs.insert(physReg);
    }
    callSaveSize_ = static_cast<int>(csRegs.size()) * 4;
}

// [riscv_codegen.cpp] calculateStackFrame
totalStackSize_ = allocaSize + frameOverhead + spillSize + callSaveSize_ + callArgAreaSize_;
```

---

## Bug #5：addi 立即数超出 12 位范围

### 现象

当 alloca 偏移或溢出偏移超过 ±2047 时，生成的 `addi` 指令包含非法立即数，汇编器报错。

### 根因分析

RISC-V `addi` 指令的立即数字段为 12 位有符号（-2048 到 +2047）。当函数有大量局部变量时，帧偏移超出此范围。

### 修复

在 `genAlloca` 和其他需要帧偏移的地方添加范围检查，超出时使用 `li` + `add` 替代 `addi`：

```cpp
// 辅助函数
static bool inAddiRange(int imm) { return imm >= -2048 && imm <= 2047; }

// genAlloca 中
int off = getAllocaOffset(vreg);
if (inAddiRange(-off)) {
    emit("addi " + rd + ", s0, " + std::to_string(-off));
} else {
    emit("li " + rd + ", " + std::to_string(-off));
    emit("add " + rd + ", s0, " + rd);
}
```

---

## Bug #6：buildLogicalOp 产生重复基本块标签

### 现象

包含多个短路逻辑运算（`&&`、`||`）的函数生成 IR 时出现重复的基本块标签名（如两个 `land_rhs_0`），导致 CFG 构建和跳转目标错误。

### 根因分析

[ir_builder.cpp](../src/ir_builder.cpp) 中 `buildLogicalOp` 使用 `newLabel()` 生成基本块标签时，仅在函数末尾递增 `labelCounter_`，但 `&&` 分支和 `||` 分支各自生成多个标签，导致不同逻辑运算共享同一个计数器值。

### 修复

在 `buildLogicalOp` 的 `&&` 和 `||` 两个分支中，标签生成后都立即递增 `labelCounter_`：

```cpp
// [ir_builder.cpp] buildLogicalOp
if (op == "&&") {
    std::string rhsBB  = newLabel("land_rhs");
    std::string falseBB = newLabel("land_false");
    std::string endBB  = newLabel("land_end");
    labelCounter_++;   // ← 递增，防止后续逻辑运算标签冲突
    // ...
}
if (op == "||") {
    std::string trueBB = newLabel("lor_true");
    std::string rhsBB  = newLabel("lor_rhs");
    std::string endBB  = newLabel("lor_end");
    labelCounter_++;   // ← 同理
    // ...
}
```

---

## Bug #7：溢出栈槽寻址使用负 sp 偏移

### 现象

溢出到栈的虚拟寄存器读写时使用负的 `sp` 偏移（如 `lw t0, -4(sp)`），访问了栈帧之外的内存，导致数据损坏或 SIGSEGV。

### 根因分析

寄存器分配器 `allocateSpillSlot()` 返回负偏移（-4, -8, -12, ...），代码生成器直接将这些负值作为 `sp` 的偏移使用。但 `sp` 指向栈帧底部，合法的溢出区域在 `sp` 之上（正偏移方向）。

### 修复

引入 `spillSlotToSpOffset()` 转换函数，将分配器返回的负槽值映射为帧底部的正偏移：

```cpp
// [riscv_codegen.cpp]
int RISCVCodeGen::spillSlotToSpOffset(int slot) {
    // slot 为负值（如 -4, -8, ...）
    // 布局: [0, argArea) | [argArea, argArea+callSave) | [argArea+callSave, ...)
    return callArgAreaSize_ + callSaveSize_ + ((-slot) - 4);
}
```

**栈帧底部布局**：
```
sp+0                → 出栈参数区（callArgAreaSize_ 字节）
sp+callArgAreaSize_ → caller-saved 保存区（callSaveSize_ 字节）
sp+callArgAreaSize_+callSaveSize_ → 溢出槽（slot -4 → 偏移 0，slot -8 → 偏移 4，...）
```

---

## Bug #8：if-else 合并块缺少 loadedValues\_ 缓存清除

### 现象

测试 17（complex_expressions）在 QEMU 执行时陷入**无限循环**，程序挂起。

### 根因分析

[ir_builder.cpp](../src/ir_builder.cpp) 的 `buildIf` 在 `then` 和 `else` 分支内可能修改了变量值并 `store` 到栈，但 `loadedValues_` 缓存仍然保留着分支前的旧值。当控制流合并到 `endif` 块后，后续的 `buildExpr` 读取变量时命中缓存，返回过期的虚拟寄存器，导致使用了错误的条件值，循环条件永远为真。

**数据流追踪**：
```
entry:
  %5 = load i32, ptr %x_slot       ← loadedValues_["x"] = %5
  br cond, then, else

then:
  store i32 newVal, ptr %x_slot     ← x 的值改变了
  br endif

else:
  store i32 otherVal, ptr %x_slot
  br endif

endif:
  // loadedValues_["x"] 仍然 = %5（过期！）
  %10 = buildExpr(x)               ← 返回 %5 而不是重新 load → 循环条件永远不变
```

### 修复

在 `buildIf` 的合并基本块（`endBB`）入口处清除 `loadedValues_` 缓存：

```cpp
// [ir_builder.cpp] buildIf 末尾
auto *endBB = createBlock(endName);
setInsertBlock(endBB);
loadedValues_.clear();  // ← 修复：强制后续重新 load
```

---

## Bug #9：genCall 参数移动的并行移动冲突

### 现象

测试 18（many_variables）：期望返回值 78，实际返回 222。多个函数的独立调用结果正确，但在同一个 `main` 函数中组合调用时结果异常。

### 根因分析

旧版 `genCall` 将参数按顺序 `mv` 到 a0-a7：

```asm
mv a0, a2    # 将 vreg(→a2) 移到 a0
mv a1, a3    # 将 vreg(→a3) 移到 a1
call func
```

**冲突场景**：如果参数的源寄存器恰好是另一个参数的目标寄存器，就会发生覆盖：

```
mv a0, a1    # a1 的值移到 a0 ← OK
mv a1, a0    # 但此时 a0 已经被上一步覆盖！
```

这是经典的**并行移动问题**（parallel move problem）。

### 修复

完全重写参数加载逻辑。`genCall` 在保存 caller-saved 寄存器到栈后，**直接从已保存的栈位置**加载参数到目标寄存器，彻底避免寄存器间的交叉依赖：

```cpp
// genCall 参数加载（修复后）
for (size_t i = 0; i < inst.ops.size() && i < 8; ++i) {
    std::string target = "a" + std::to_string(i);
    const auto &op = inst.ops[i];

    if (op.isVReg()) {
        int vreg = op.regId();
        auto physIt = alloc.vregToPhys.find(vreg);
        if (physIt != alloc.vregToPhys.end()) {
            auto saveIt = regToSaveOffset.find(physIt->second);
            if (saveIt != regToSaveOffset.end()) {
                // caller-saved: 从已保存位置加载（不依赖其他参数寄存器）
                emit("lw " + target + ", " + std::to_string(saveIt->second) + "(sp)");
            } else {
                // callee-saved: 不会被 caller-save 操作影响
                emit("mv " + target + ", " + regInfo_.getRegName(physIt->second));
            }
        } else {
            // 溢出到栈的 vreg: 从溢出槽加载
            emit("lw " + target + ", " + std::to_string(spillOffset) + "(sp)");
        }
    }
}
```

---

## Bug #10：spillDefIfNeeded 使用了错误的临时寄存器

### 现象

测试 18 在 Bug #9 修复后仍差 2（返回 76 而非 78），具体差异来自某个子函数的溢出路径。

### 根因分析

`resolveDef` 和 `spillDefIfNeeded` 分别调用 `allocateSpillTempReg()` 获取临时寄存器，但中间插入的 `resolveUse` 调用会推进 t0/t1 交替计数器，导致两者获取到**不同的**临时寄存器：

```
resolveDef(vreg)   → allocateSpillTempReg() → t1  ← 定义值写入 t1
resolveUse(op1)    → allocateSpillTempReg() → t0  ← 中间 use 推进了计数器
resolveUse(op2)    → allocateSpillTempReg() → t1
spillDefIfNeeded() → allocateSpillTempReg() → t0  ← BUG: 应该用 t1 但拿到 t0
```

**汇编证据**：
```asm
lw t1, -60(s0)    # resolveDef → t1（定义在 t1）
...
sw t0, 84(sp)     # spillDefIfNeeded → t0（写回时用了错误的 t0！）
```

### 修复

在 `resolveDef` 中保存分配到的寄存器名到 `lastDefRegName_` 成员变量，`spillDefIfNeeded` 直接使用该变量，不再独立调用 `allocateSpillTempReg()`：

```cpp
// [riscv_codegen.cpp] resolveDef
std::string RISCVCodeGen::resolveDef(const Operand &op) {
    // ...
    auto &allocator = funcAllocators_[currentFunction_];
    int tmpReg = allocator->allocateSpillTempReg();
    lastDefRegName_ = regInfo_.getRegName(tmpReg);
    return lastDefRegName_;
}

// [riscv_codegen.cpp] spillDefIfNeeded — 使用 lastDefRegName_
void RISCVCodeGen::spillDefIfNeeded(const Instruction &inst) {
    // ...
    emit("sw " + lastDefRegName_ + ", " + std::to_string(spOffset) + "(sp)");
}
```

---

## Bug #11：超过 8 个参数的函数调用不支持栈传参

### 现象

测试 19（many_arguments）：包含 `sum16`/`sum32`/`sum64` 等多参数函数，期望返回 165，实际返回 109-114（不稳定）。

### 根因分析

RISC-V 调用约定规定前 8 个参数通过 a0-a7 传递，第 9 个及之后的参数通过栈传递。ToyC 的 `genCall` 和 `resolveUse` 完全没有实现栈传参支持。

**缺失的功能**：
1. **调用方（caller）**：第 9+ 个参数应存放到 `sp+0, sp+4, sp+8, ...`（出栈参数区）
2. **被调用方（callee）**：第 9+ 个参数的栈偏移位于调用者帧底部，应通过 `s0` 正偏移访问
3. **栈帧**：需要为出栈参数区预留空间，且该空间在整个函数生命周期内保持有效

### 修复

分三部分实现：

#### 1. 寄存器分配器：栈传入参数正偏移

```cpp
// [reg_alloc.cpp] processParameters
void LinearScanAllocator::processParameters(const std::vector<int> &paramVregs) {
    for (size_t i = 0; i < paramVregs.size(); ++i) {
        if (i < 8) {
            // 前 8 个参数: a0-a7
            result_.vregToPhys[vreg] = 10 + static_cast<int>(i);
        } else {
            // 第 9+ 个参数: 正偏移栈位置
            int stackOffset = static_cast<int>(i - 8 + 1) * 4;  // +4, +8, +12, ...
            result_.vregToStack[vreg] = stackOffset;
        }
    }
}
```

#### 2. 代码生成器：出栈参数区 + 调用方栈传参

```cpp
// [riscv_codegen.cpp] generateFunction — 预计算出栈参数区大小
int maxStackArgs = 0;
for (auto &bb : func.blocks)
    for (auto &inst : bb->insts)
        if (inst->opcode == ir::Opcode::Call)
            maxStackArgs = std::max(maxStackArgs,
                std::max(0, static_cast<int>(inst->ops.size()) - 8));
callArgAreaSize_ = maxStackArgs * 4;

// [riscv_codegen.cpp] genCall — 第 9+ 参数存到出栈参数区
for (size_t i = 8; i < inst.ops.size(); ++i) {
    int argOffset = static_cast<int>(i - 8) * 4;  // sp+0, sp+4, ...
    emit("sw " + src + ", " + std::to_string(argOffset) + "(sp)");
}
```

#### 3. resolveUse 处理正偏移栈位置

```cpp
// [riscv_codegen.cpp] resolveUse
if (stackIt->second > 0) {
    // 正偏移 = 栈传入参数，位于调用者帧底部
    // 调用者将参数存到 caller_sp+0, +4, ... 即 callee_s0+0, +4, ...
    int s0Offset = stackIt->second - 4;
    emit("lw " + tmpName + ", " + std::to_string(s0Offset) + "(s0)");
}
```

#### 最终栈帧布局

```
高地址
┌──────────────────────────┐ ← 调用者 sp
│  调用者出栈参数区          │   arg9 在 sp+0, arg10 在 sp+4, ...
├──────────────────────────┤ ← s0（帧指针 = 调用者 sp）
│  ra                                              │ s0-4
│  old s0                                          │ s0-8
│  callee-saved regs (s1, s2, ...)                 │ s0-12, ...
│  alloca 区域（局部变量）                         │
├──────────────────────────┤
│  溢出栈槽 (spill slots)                          │ spillSlotToSpOffset()
├──────────────────────────┤
│  caller-saved 保存区 (callSaveSize_)             │ sp + callArgAreaSize_
├──────────────────────────┤
│  出栈参数区 (callArgAreaSize_)                   │ sp + 0
└──────────────────────────┘ ← sp
低地址
```

---

## 修复时间线与测试影响

| Bug # | 影响范围 | 修复文件 | 关联测试 |
|-------|---------|---------|---------|
| 1 | 全部函数（SIGSEGV） | riscv_codegen.cpp | 所有 36 个 |
| 2 | 所有函数（分配遗漏） | ir_builder.cpp | 所有 36 个 |
| 3 | 有函数调用的测试 | riscv_codegen.cpp | 05, 09, 16-20, 22, 25, 31 |
| 4 | 有函数调用的测试 | riscv_codegen.cpp | 同上 |
| 5 | 大量局部变量 | riscv_codegen.cpp | 18, 19, 20 |
| 6 | 多重 &&/\|\| | ir_builder.cpp | 08, 27, 28 |
| 7 | 有溢出的函数 | riscv_codegen.cpp | 18, 19, 20 |
| 8 | if 内修改变量 + 循环 | ir_builder.cpp | 17 |
| 9 | 函数调用参数冲突 | riscv_codegen.cpp | 18, 22 |
| 10 | 溢出 + def/use 交错 | riscv_codegen.cpp | 18 |
| 11 | ≥9 个参数的调用 | riscv_codegen.cpp, reg_alloc.cpp | 19 |

---

## 关键设计决策总结

### 1. 帧布局分层策略

将栈帧划分为多个独立区域，每个区域有明确的偏移计算规则：

| 区域 | 基准 | 偏移方向 | 管理变量 |
|------|------|---------|---------|
| 出栈参数 | sp | 正偏移 | `callArgAreaSize_` |
| caller-saved 保存 | sp + callArgAreaSize_ | 正偏移 | `callSaveSize_` |
| 溢出栈槽 | 通过 `spillSlotToSpOffset()` | 正偏移 | `nextSpillSlot_` |
| alloca 变量 | s0 | 负偏移 | `stackOffset_` + `frameOverhead_` |
| callee-saved | s0 | 负偏移 | `calleeSavedCount` |
| ra + s0 | s0 | 负偏移 | 固定 8 字节 |

### 2. 溢出临时寄存器绑定

`resolveDef` 通过 `lastDefRegName_` 将定义操作和溢出回写操作绑定到同一个临时寄存器，不受中间 `resolveUse` 调用的影响。这是一个简单但有效的解决方案，无需引入复杂的寄存器预约机制。

### 3. genCall 基于栈的参数传递

通过"先保存、后从保存位置加载到目标寄存器"的策略彻底避免了并行移动冲突。虽然可能多一次内存访问，但正确性有保证，且不需要实现完整的并行移动求解器。

### 4. 正负偏移区分策略

寄存器分配器对栈参数使用**正偏移**（+4, +8, ...），对溢出槽使用**负偏移**（-4, -8, ...），代码生成器据此区分参数访问（通过 s0 正偏移）和溢出访问（通过 sp + 转换后的正偏移）。
