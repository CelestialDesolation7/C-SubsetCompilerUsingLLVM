# ToyC 编译器完整流程详解

## 概述

本文档详细介绍 ToyC 编译器从 C 语言子集源代码到 RISC-V 汇编代码的完整编译流程。整个编译过程分为以下几个主要阶段：

```
C 源代码 → 词法分析 → 语法分析 → AST → 结构化 IR 生成 → 寄存器分配 → RISC-V 汇编生成
         (Lexer)   (Parser)       (IRBuilder)    (LinearScan)  (RISCVCodeGen)
```

与传统的字符串拼接 IR 方案不同，ToyC 使用**结构化 IR 模型**：`IRBuilder` 在内存中构建 `ir::Module` 对象树，后端直接通过 `Opcode` 枚举进行指令分派，全程无正则匹配、无字符串解析。

我们将以 `01_minimal.c` 和一个含函数调用的稍复杂示例，结合源码逐步追踪数据在各个阶段的转换过程。

---

## 阶段 0：主程序入口 (main.cpp)

### 数据流概览

编译器的主入口在 [main.cpp](../src/main.cpp) 中，负责：
- 解析命令行参数（`--ast`、`--ir`、`--asm`、`--all`、`-o`）
- 根据输入文件扩展名选择前端（`.c`/`.tc` → 完整编译，`.ll` → 跳过前端直接解析 IR）
- 协调各个编译阶段，控制输出

### 关键代码分析

```cpp
// [main.cpp](../src/main.cpp)

int main(int argc, char *argv[]) {
    // 1. 解析命令行参数
    std::string inputFile = argv[1];
    bool printAst = false, printIr = false, printAsm = false;
    std::string outputFile;
    // ... --ast / --ir / --asm / --all / -o 解析
    // 默认：仅输出汇编

    // 2. 读取输入文件
    std::string source = readFile(inputFile);
    bool isLLFile = (扩展名为 ".ll");

    if (isLLFile) {
        // .ll 输入 → IRParser 解析为 ir::Module → 代码生成
        toyc::IRParser parser;
        auto mod = parser.parseModule(source);
        std::string asmOutput = toyc::generateRISCVAssembly(*mod);
    } else {
        // .c / .tc 输入 → 完整编译流程
        Parser parser(source);                          // 词法 + 语法分析器
        auto funcs = parser.parseCompUnit();            // 解析得到 AST

        toyc::IRBuilder builder;                        // IR 生成器
        auto mod = builder.buildModule(funcs);          // AST → ir::Module

        std::string asmOutput = toyc::generateRISCVAssembly(*mod); // IR → 汇编
    }
}
```

### 示例：编译 01_minimal.c

**输入文件** [examples/compiler_inputs/01_minimal.c](../examples/compiler_inputs/01_minimal.c)：
```c
int main() {
    return 0;
}
```

主程序会依次调用：
1. `Parser parser(source)` — 创建词法/语法分析器
2. `parser.parseCompUnit()` — 解析得到 `vector<shared_ptr<FuncDef>>`
3. `builder.buildModule(funcs)` — 生成 `unique_ptr<ir::Module>`
4. `generateRISCVAssembly(*mod)` — 生成 RISC-V 汇编字符串

---

## 阶段 1：词法分析 (Lexer)

### 功能说明

词法分析器定义在 [lexer.h](../src/include/lexer.h) / [lexer.cpp](../src/lexer.cpp) 中，将源代码字符串转换为 **Token 流**。Token 是编译器识别的最小语法单元。

### 核心数据结构

Token 类型定义在 [token.h](../src/include/token.h)：

```cpp
// [token.h](../src/include/token.h)

enum class TokenType {
    ID,      // 标识符：变量名、函数名
    NUMBER,  // 数字字面量
    INT, VOID, IF, ELSE, WHILE, RETURN, BREAK, CONTINUE,  // 关键字
    PLUS, MINUS, TIMES, DIV, MOD,                         // 算术运算符
    GT, LT, GE, LE, EQ, NE,                               // 关系运算符
    OR, AND, NOT,                                          // 逻辑运算符
    ASSIGN,                                                // 赋值
    LPAREN, RPAREN, LBRACE, RBRACE, SEMI, COMMA,          // 分隔符
    END, UNKNOWN                                           // 特殊标记
};

struct Token {
    TokenType type;    // Token 类型
    std::string lexeme;// 原始文本
    int line;          // 所在行号
};
```

### 工作流程

```cpp
// [lexer.h](../src/include/lexer.h)

class Lexer {
    std::string src;     // 源代码
    size_t pos = 0;      // 当前扫描位置
    int line = 1;        // 当前行号

    Token nextToken() {
        skipWhitespace();   // 跳过空白和注释
        char c = advance(); // 读取当前字符

        if (c == '+') return makeToken(TokenType::PLUS);
        if (c == '=') {
            if (peek() == '=') { advance(); return {TokenType::EQ, "==", line}; }
            return makeToken(TokenType::ASSIGN);
        }
        if (isalpha(c)) return identifier();  // 标识符或关键字
        if (isdigit(c)) return number();      // 数字
        // ...
    }
};
```

### 关键实现细节

1. **关键字识别**：通过哈希表查找，`identifier()` 扫描完整标识符后查表判断是关键字还是普通标识符
   ```cpp
   static const unordered_map<string, TokenType> keywords = {
       {"int", TokenType::INT}, {"void", TokenType::VOID},
       {"return", TokenType::RETURN}, {"if", TokenType::IF},
       // ...
   };
   ```

2. **注释处理**：跳过 `//` 单行注释

3. **双字符运算符**：需要预读一个字符
   ```cpp
   // '=' 可能是 ASSIGN(=) 或 EQ(==)
   // '<' 可能是 LT(<) 或 LE(<=)
   // '!' 可能是 NOT(!) 或 NE(!=)
   ```

### 示例：词法分析过程

**输入**：
```c
int main() {
    return 0;
}
```

**Token 流输出**：
```
[INT,    "int",    line=1]
[ID,     "main",   line=1]
[LPAREN, "(",      line=1]
[RPAREN, ")",      line=1]
[LBRACE, "{",      line=1]
[RETURN, "return", line=2]
[NUMBER, "0",      line=2]
[SEMI,   ";",      line=2]
[RBRACE, "}",      line=3]
[END,    "",       line=3]
```

---

## 阶段 2：语法分析 (Parser)

### 功能说明

语法分析器定义在 [parser.h](../src/include/parser.h) / [parser.cpp](../src/parser.cpp) 中，将 Token 流转换为 **抽象语法树（AST）**。

### 核心数据结构

AST 节点定义在 [ast.h](../src/include/ast.h)：

```cpp
// [ast.h](../src/include/ast.h)

// 基类
struct ASTNode {
    virtual void print(int indent, std::ostream &os) const = 0;
};
using ASTPtr = std::shared_ptr<ASTNode>;

// ======== 表达式节点 ========
struct NumberExpr : Expr { int value; };               // 数字：42
struct IdentifierExpr : Expr { std::string name; };    // 标识符：x
struct BinaryExpr : Expr {                             // 二元运算：x + y
    std::string op;
    ASTPtr lhs, rhs;
};
struct UnaryExpr : Expr {                              // 一元运算：-x, !flag
    std::string op;
    ASTPtr expr;
};
struct CallExpr : Expr {                               // 函数调用：foo(a, b)
    std::string callee;
    std::vector<ASTPtr> args;
};

// ======== 语句节点 ========
struct DeclStmt : Stmt { std::string name; ASTPtr expr; };     // int x = 5;
struct AssignStmt : Stmt { std::string name; ASTPtr expr; };   // x = 10;
struct IfStmt : Stmt { ASTPtr cond, thenStmt, elseStmt; };    // if-else
struct WhileStmt : Stmt { ASTPtr cond, body; };                // while
struct ReturnStmt : Stmt { ASTPtr expr; };                     // return
struct BreakStmt : Stmt {};                                     // break
struct ContinueStmt : Stmt {};                                  // continue
struct BlockStmt : Stmt { std::vector<ASTPtr> stmts; };        // { ... }

// ======== 函数定义 ========
struct FuncDef : ASTNode {
    std::string retType;                // 返回类型：int/void
    std::string name;                   // 函数名
    std::vector<Param> params;          // 参数列表
    std::shared_ptr<BlockStmt> body;    // 函数体
};
```

### 递归下降解析

Parser 使用 **递归下降** 方法，内部保持两个 Token 的预读（`cur` 和 `nxt`），每个语法规则对应一个函数：

```cpp
// [parser.h](../src/include/parser.h)

class Parser {
    Lexer lex;
    Token cur, nxt;  // 当前和下一个 Token（双 Token 预读）

    // 核心解析函数
    std::vector<std::shared_ptr<FuncDef>> parseCompUnit();
    std::shared_ptr<FuncDef> parseFuncDef();
    std::shared_ptr<BlockStmt> parseBlock();
    ASTPtr parseStmt();
    ASTPtr parseExpr();

    // 表达式按优先级分层
    ASTPtr parseLOr();      // 逻辑或：||       优先级 1（最低）
    ASTPtr parseLAnd();     // 逻辑与：&&       优先级 2
    ASTPtr parseRel();      // 关系运算：< > == !=  优先级 3
    ASTPtr parseAdd();      // 加减：+ -        优先级 4
    ASTPtr parseMul();      // 乘除模：* / %    优先级 5
    ASTPtr parseUnary();    // 一元：+ - !      优先级 6
    ASTPtr parsePrimary();  // 基本：数字 标识符 括号  优先级 7（最高）
};
```

### 语法规则与实现

#### 1. 编译单元

```
CompUnit → FuncDef+
```

```cpp
vector<shared_ptr<FuncDef>> Parser::parseCompUnit() {
    vector<shared_ptr<FuncDef>> funcs;
    while (cur.type == TokenType::INT || cur.type == TokenType::VOID)
        funcs.push_back(parseFuncDef());
    return funcs;
}
```

#### 2. 函数定义

```
FuncDef → ("int" | "void") ID "(" Params? ")" Block
Params  → "int" ID ("," "int" ID)*
```

#### 3. 语句解析

```cpp
// [parser.cpp](../src/parser.cpp)
ASTPtr Parser::parseStmt() {
    if (cur.type == TokenType::LBRACE) return parseBlock();       // { ... }
    if (cur.type == TokenType::IF)     ...;                       // if (...)
    if (cur.type == TokenType::WHILE)  ...;                       // while (...)
    if (match(TokenType::RETURN))      ...;                       // return ...;
    if (match(TokenType::BREAK))       ...;                       // break;
    if (match(TokenType::CONTINUE))    ...;                       // continue;
    if (cur.type == TokenType::INT)    ...;                       // int x = ...;
    if (cur.type == TokenType::ID && nxt.type == TokenType::ASSIGN)
        ...;                                                       // x = ...;
    // 表达式语句（函数调用等）
}
```

#### 4. 表达式解析（运算符优先级）

表达式解析通过分层函数实现运算符优先级，每层函数先调用更高优先级的函数，再处理同级运算符：

```
parseExpr → parseLOr → parseLAnd → parseRel → parseAdd → parseMul → parseUnary → parsePrimary
```

示例：解析加法表达式
```cpp
ASTPtr Parser::parseAdd() {
    auto left = parseMul();  // 先解析更高优先级的乘法
    while (cur.type == TokenType::PLUS || cur.type == TokenType::MINUS) {
        string op = cur.lexeme;
        advance();
        auto right = parseMul();
        left = make_shared<BinaryExpr>(op, left, right);
    }
    return left;
}
```

### 示例：解析过程追踪

**输入代码**：
```c
int main() {
    int x = 1;
    x = x + 2;
    return x;
}
```

**Token 流** → **AST**：
```
Token 流:                          AST 结构:
INT ID(main) LPAREN RPAREN        FuncDef {
LBRACE                               retType: "int"
  INT ID(x) ASSIGN NUMBER(1)         name: "main"
  SEMI                                params: []
  ID(x) ASSIGN ID(x) PLUS            body: BlockStmt {
  NUMBER(2) SEMI                        stmts: [
  RETURN ID(x) SEMI                       DeclStmt { name="x", expr=NumberExpr(1) }
RBRACE                                    AssignStmt {
END                                         name="x",
                                            expr=BinaryExpr {
                                              op: "+",
                                              lhs: IdentifierExpr("x"),
                                              rhs: NumberExpr(2)
                                            }
                                          }
                                          ReturnStmt { expr=IdentifierExpr("x") }
                                        ]
                                      }
                                    }
```

---

## 阶段 3：结构化 IR 生成 (IRBuilder)

### 功能说明

IR 生成器定义在 [ir_builder.h](../src/include/ir_builder.h) / [ir_builder.cpp](../src/ir_builder.cpp) 中，将 AST 转换为**结构化 LLVM IR 对象树**。

与旧版本的字符串拼接方式不同，当前实现使用 [ir.h](../src/include/ir.h) 中定义的类型系统，在内存中构建 `ir::Module` → `ir::Function` → `ir::BasicBlock` → `ir::Instruction` 的层次结构。每条指令以 `Opcode` 枚举标识操作类型，操作数由 `Operand` 类型安全地表示。

### 核心数据结构

#### IR 类型层次（ir.h）

```cpp
// [ir.h](../src/include/ir.h)

namespace toyc::ir {

// 指令操作码
enum class Opcode {
    Alloca, Load, Store,              // 内存操作
    Add, Sub, Mul, SDiv, SRem,       // 算术运算
    ICmp,                             // 整数比较
    Br, CondBr,                       // 控制流
    Ret, RetVoid,                     // 返回
    Call                              // 函数调用
};

// 比较谓词
enum class CmpPred { EQ, NE, SLT, SGT, SLE, SGE };

// 操作数（类型安全的联合体）
class Operand {
    enum class Kind { None, VReg, Imm, Label, BoolLit };
    // 工厂方法
    static Operand vreg(int id);      // %1, %2, ...
    static Operand imm(int val);      // 42, 0, ...
    static Operand label(string name);// %entry, %then, ...
    static Operand boolLit(bool val); // true, false
};

// 指令
class Instruction {
    Opcode opcode;                    // 操作码
    std::string type;                 // "i32", "i1", "void"
    Operand def;                      // 结果寄存器
    std::vector<Operand> ops;         // 操作数列表
    CmpPred cmpPred;                  // 仅 ICmp 使用
    std::string callee;               // 仅 Call 使用

    int index;                        // 线性化位置（用于寄存器分配）
    int blockId;                      // 所属基本块 ID

    // 工厂方法
    static Instruction makeAlloca(Operand def, string type, int align = 4);
    static Instruction makeLoad(Operand def, string type, Operand ptr, int align = 4);
    static Instruction makeStore(string type, Operand val, Operand ptr, int align = 4);
    static Instruction makeBinOp(Opcode op, Operand def, string type, Operand lhs, Operand rhs);
    static Instruction makeICmp(CmpPred pred, Operand def, string type, Operand lhs, Operand rhs);
    static Instruction makeBr(Operand target);
    static Instruction makeCondBr(Operand cond, Operand trueTarget, Operand falseTarget);
    static Instruction makeRet(string type, Operand value);
    static Instruction makeRetVoid();
    static Instruction makeCall(Operand def, string retType, string callee, vector<Operand> args);

    // 查询接口（无需正则匹配）
    int defReg() const;                    // 定义的虚拟寄存器 ID（-1 表示无定义）
    std::vector<int> useRegs() const;      // 使用的所有虚拟寄存器 ID
    bool isTerminator() const;             // 是否为终结指令
    std::vector<std::string> branchTargets() const;  // 分支目标标签

    // 位置计算（线性扫描寄存器分配用）
    int posDef() const { return index * 2; }     // 偶数位：定义点
    int posUse() const { return index * 2 + 1; } // 奇数位：使用点
};

// 基本块
class BasicBlock {
    int id;
    std::string name;
    std::vector<std::unique_ptr<Instruction>> insts;
    std::vector<BasicBlock*> succs, preds;           // CFG 边
    std::set<int> defSet, useSet, liveIn, liveOut;   // 活跃性分析数据
};

// 函数
class Function {
    std::string name, returnType;
    std::vector<FuncParam> params;
    std::vector<std::unique_ptr<BasicBlock>> blocks;
    std::unordered_map<std::string, BasicBlock*> blockMap;
    std::vector<BasicBlock*> rpoOrder;     // 逆后序（数据流分析用）
    std::vector<int> paramVregs;           // 参数对应的虚拟寄存器 ID
    int maxVregId;

    void buildCFG();                       // 根据分支指令构建 succs/preds
};

// 模块
class Module {
    std::string name = "toyc";
    std::string targetTriple = "riscv32-unknown-elf";
    std::vector<std::unique_ptr<Function>> functions;
    std::string toString() const;          // 序列化为 LLVM IR 文本
};

} // namespace toyc::ir
```

#### IRBuilder 状态

```cpp
// [ir_builder.h](../src/include/ir_builder.h)

class IRBuilder {
    int vregCounter_;          // 虚拟寄存器计数器
    int labelCounter_;         // 标签计数器

    ir::Module *module_;       // 当前模块
    ir::Function *currentFunc_;// 当前函数
    ir::BasicBlock *currentBB_;// 当前指令插入块

    std::vector<std::map<std::string, ir::Operand>> scopeStack_;  // 作用域栈
    std::map<std::string, ir::Operand> loadedValues_;             // load 缓存

    std::vector<std::string> breakLabels_;      // break 目标标签栈
    std::vector<std::string> continueLabels_;   // continue 目标标签栈
};
```

### IR 生成调用链

```
buildModule(funcs)
 └─ for each FuncDef:
     buildFunction(funcDef)
      ├─ 重置 vregCounter_, labelCounter_, scopeStack_, loadedValues_
      ├─ 创建 ir::Function + 入口 BasicBlock("entry")
      ├─ main 函数: alloca + store 0 (返回值变量)
      ├─ 参数处理: alloca + store 每个参数
      ├─ buildBlock(body)
      │   └─ enterScope → for each stmt: buildStmt(stmt) → exitScope
      └─ 若无 return: 添加默认 ret i32 0 / ret void
```

### 语句生成

`buildStmt()` 通过 `dynamic_pointer_cast` 识别 AST 节点类型，分派到对应生成函数：

```cpp
// [ir_builder.cpp](../src/ir_builder.cpp)

void IRBuilder::buildStmt(const ASTPtr &stmt) {
    if (auto s = dynamic_pointer_cast<AssignStmt>(stmt))   { buildAssign(s);  return; }
    if (auto s = dynamic_pointer_cast<DeclStmt>(stmt))     { buildDecl(s);    return; }
    if (auto s = dynamic_pointer_cast<IfStmt>(stmt))       { buildIf(s);      return; }
    if (auto s = dynamic_pointer_cast<WhileStmt>(stmt))    { buildWhile(s);   return; }
    if (auto s = dynamic_pointer_cast<ReturnStmt>(stmt))   { buildReturn(s);  return; }
    if (auto s = dynamic_pointer_cast<BreakStmt>(stmt))    { buildBreak();    return; }
    if (auto s = dynamic_pointer_cast<ContinueStmt>(stmt)) { buildContinue(); return; }
    if (auto s = dynamic_pointer_cast<BlockStmt>(stmt))    { buildBlock(s);   return; }
    if (auto s = dynamic_pointer_cast<CallExpr>(stmt))     { buildCall(s);    return; }
    if (auto s = dynamic_pointer_cast<Expr>(stmt))         { buildExpr(s);    return; }
}
```

#### 声明语句（DeclStmt）

```cpp
void IRBuilder::buildDecl(const shared_ptr<DeclStmt> &decl) {
    Operand val = buildExpr(decl->expr);  // 计算初始值
    Operand slot = newVReg();             // 分配新虚拟寄存器
    emit(Instruction::makeAlloca(slot, "i32"));       // alloca
    addVariable(decl->name, slot);                     // 注册到当前作用域
    emit(Instruction::makeStore("i32", val, slot));   // store 初始值
    loadedValues_.erase(decl->name);                   // 清除缓存
}
```

#### if 语句（IfStmt）

```cpp
void IRBuilder::buildIf(const shared_ptr<IfStmt> &ifStmt) {
    loadedValues_.clear();                  // 进入分支前清除缓存
    Operand cond = buildExpr(ifStmt->cond);

    string thenName = newLabel("then");     // e.g. "then_0"
    string elseName = newLabel("else");
    string endName  = newLabel("endif");
    labelCounter_++;

    emit(Instruction::makeCondBr(cond, Operand::label(thenName), Operand::label(elseName)));

    auto *thenBB = createBlock(thenName);   // Then 块
    setInsertBlock(thenBB);
    loadedValues_.clear();                  // 清除缓存（分支后缓存无效）
    buildStmt(ifStmt->thenStmt);
    emit(Instruction::makeBr(Operand::label(endName)));

    auto *elseBB = createBlock(elseName);   // Else 块
    setInsertBlock(elseBB);
    loadedValues_.clear();                  // 同上
    buildStmt(ifStmt->elseStmt);
    emit(Instruction::makeBr(Operand::label(endName)));

    auto *endBB = createBlock(endName);     // Merge 块
    setInsertBlock(endBB);
    loadedValues_.clear();                  // 合流点：两条路径的缓存均不可信
}
```

注意 `loadedValues_.clear()` 在四个位置调用：分支前、then 块入口、else 块入口和 merge 块入口。这是因为 `loadedValues_` 缓存了变量最近一次 load 的结果，但在控制流分叉/合流点，缓存值可能来自"另一条路径"而不再有效。例如在 merge 块中，then 分支可能修改了某变量的值，但 else 分支没有，此时缓存的 load 值是不确定的。
```

**控制流图**：
```
        entry
          │
     br cond, then, else
        ↙         ↘
     then          else
       │             │
    br endif      br endif
        ↘         ↙
         endif
```

#### while 语句（WhileStmt）

```cpp
void IRBuilder::buildWhile(const shared_ptr<WhileStmt> &whileStmt) {
    string condName = newLabel("while_cond");
    string bodyName = newLabel("while_body");
    string endName  = newLabel("while_end");
    labelCounter_++;

    breakLabels_.push_back(endName);        // break → 跳到 while_end
    continueLabels_.push_back(condName);    // continue → 跳到 while_cond

    emit(Instruction::makeBr(Operand::label(condName)));

    auto *condBB = createBlock(condName);   // 条件块
    setInsertBlock(condBB);
    Operand cond = buildExpr(whileStmt->cond);
    emit(Instruction::makeCondBr(cond, Operand::label(bodyName), Operand::label(endName)));

    auto *bodyBB = createBlock(bodyName);   // 循环体
    setInsertBlock(bodyBB);
    buildStmt(whileStmt->body);
    emit(Instruction::makeBr(Operand::label(condName)));  // 回跳

    auto *endBB = createBlock(endName);     // 出口
    setInsertBlock(endBB);

    breakLabels_.pop_back();
    continueLabels_.pop_back();
}
```

**控制流图**：
```
        entry
          │
       br while_cond
          ↓
    → while_cond ←──────┐
    │     │              │
    │ br cond, body, end │
    │     ↓              │
    │ while_body         │
    │     │              │
    │  br while_cond ────┘
    │
    └→ while_end
```

### 表达式生成

`buildExpr()` 根据表达式类型分派处理，返回结果 `Operand`：

```cpp
// [ir_builder.cpp](../src/ir_builder.cpp)

Operand IRBuilder::buildExpr(const ASTPtr &expr) {
    // 数字字面量 → 直接返回立即数
    if (auto e = dynamic_pointer_cast<NumberExpr>(expr))
        return Operand::imm(e->value);

    // 标识符 → 查找变量，load 到新虚拟寄存器（带缓存避免重复 load）
    if (auto e = dynamic_pointer_cast<IdentifierExpr>(expr)) {
        Operand varOp = findVariable(e->name);
        auto it = loadedValues_.find(e->name);
        if (it != loadedValues_.end()) return it->second;  // 缓存命中
        Operand temp = newVReg();
        emit(Instruction::makeLoad(temp, "i32", varOp));
        loadedValues_[e->name] = temp;
        return temp;
    }

    // 二元运算 → 由 buildBinaryOp 分派
    if (auto e = dynamic_pointer_cast<BinaryExpr>(expr))
        return buildBinaryOp(e->op, e->lhs, e->rhs);

    // 一元运算 / 函数调用
    // ...
}
```

#### 二元运算分派

```cpp
Operand IRBuilder::buildBinaryOp(const string &op, const ASTPtr &lhs, const ASTPtr &rhs) {
    if (op == "&&" || op == "||") return buildLogicalOp(op, lhs, rhs);  // 短路
    if (op == "==" || op == "!=" || ...) return buildComparison(op, lhs, rhs);  // icmp

    // 算术运算
    Operand lhsOp = buildExpr(lhs);
    Operand rhsOp = buildExpr(rhs);
    Operand result = newVReg();
    Opcode opc;
    if (op == "+") opc = Opcode::Add;
    else if (op == "-") opc = Opcode::Sub;
    else if (op == "*") opc = Opcode::Mul;
    else if (op == "/") opc = Opcode::SDiv;
    else opc = Opcode::SRem;  // "%"
    emit(Instruction::makeBinOp(opc, result, "i32", lhsOp, rhsOp));
    return result;
}
```

#### 一元运算

```cpp
Operand IRBuilder::buildUnaryOp(const string &op, const ASTPtr &expr) {
    if (op == "-") {
        // 常量折叠：-42 → Operand::imm(-42)
        if (auto num = dynamic_pointer_cast<NumberExpr>(expr))
            return Operand::imm(-num->value);
        // 一般情况：sub 0, x
        Operand inner = buildExpr(expr);
        Operand result = newVReg();
        emit(Instruction::makeBinOp(Opcode::Sub, result, "i32", Operand::imm(0), inner));
        return result;
    }
    if (op == "!") {
        // !x → icmp eq x, 0
        Operand inner = buildExpr(expr);
        Operand result = newVReg();
        emit(Instruction::makeICmp(CmpPred::EQ, result, "i32", inner, Operand::imm(0)));
        return result;
    }
    return buildExpr(expr);  // "+" 无操作
}
```

#### 短路逻辑运算（核心难点）

短路求值通过 `alloca i1` + 条件分支实现：

```cpp
Operand IRBuilder::buildLogicalOp(const string &op, const ASTPtr &lhs, const ASTPtr &rhs) {
    Operand resultVar = newVReg();
    emit(Instruction::makeAlloca(resultVar, "i1", 1));  // 分配 i1 结果变量
    Operand lhsOp = buildExpr(lhs);

    // && 的控制流：lhs 为 false 则短路
    //   br lhsOp, land_rhs, land_false
    //   land_false: store false → br land_end
    //   land_rhs:   store rhs  → br land_end
    //   land_end:   load result

    // || 的控制流：lhs 为 true 则短路
    //   br lhsOp, lor_true, lor_rhs
    //   lor_true: store true → br lor_end
    //   lor_rhs:  store rhs  → br lor_end
    //   lor_end:  load result

    Operand result = newVReg();
    emit(Instruction::makeLoad(result, "i1", resultVar, 1));
    return result;
}
```

**`a && b` 的控制流**：
```
      entry
        │
   br lhsOp, rhs, false
      ↙          ↘
  land_rhs     land_false
  store rhs    store false
  br end       br end
      ↘        ↙
     land_end
     load result
```

### 作用域管理

`IRBuilder` 使用 `scopeStack_`（`vector<map<string, Operand>>`）管理变量可见性：

```cpp
void enterScope() { scopeStack_.emplace_back(); }
void exitScope()  { scopeStack_.pop_back(); }

// 从内层向外层查找变量（实现变量隐藏/遮蔽语义）
Operand findVariable(const string &name) {
    for (int i = scopeStack_.size() - 1; i >= 0; --i) {
        auto it = scopeStack_[i].find(name);
        if (it != scopeStack_[i].end()) return it->second;
    }
    return Operand::none();
}
```

### 示例：IR 生成数据流追踪

**输入 AST**（来自前面的示例）：
```
FuncDef {
  retType: "int", name: "main"
  body: BlockStmt {
    DeclStmt { name="x", expr=NumberExpr(1) }
    AssignStmt { name="x", expr=BinaryExpr("+", IdentifierExpr("x"), NumberExpr(2)) }
    ReturnStmt { expr=IdentifierExpr("x") }
  }
}
```

**IRBuilder 逐步生成**：

| # | 操作 | 生成的 IR 指令 | 说明 |
|---|------|--------------|------|
| 1 | buildFunction → main 返回值 | `%3 = alloca i32` | isMain → 分配返回值变量 |
| 2 | | `store i32 0, ptr %3` | 初始化为 0 |
| 3 | buildDecl("x", 1) | `%4 = alloca i32` | 为 x 分配栈空间 |
| 4 | | `store i32 1, ptr %4` | x = 1 |
| 5 | buildAssign → buildExpr(x+2) | `%5 = load i32, ptr %4` | load x（写入 loadedValues\_ 缓存） |
| 6 | | `%6 = add i32 %5, 2` | %5 + 2 |
| 7 | buildAssign 完成 | `store i32 %6, ptr %4` | 存回 x，清除 loadedValues\_ 缓存 |
| 8 | buildReturn → buildExpr(x) | `%7 = load i32, ptr %4` | 再次 load x |
| 9 | | `ret i32 %7` | 返回 |

**生成的 LLVM IR 文本**（由 `Module::toString()` 输出）：
```llvm
; ModuleID = 'toyc'
source_filename = "toyc"
target triple = "riscv32-unknown-elf"

define dso_local i32 @main() #0 {
entry:
  %3 = alloca i32, align 4
  store i32 0, ptr %3, align 4
  %4 = alloca i32, align 4
  store i32 1, ptr %4, align 4
  %5 = load i32, ptr %4, align 4
  %6 = add nsw i32 %5, 2
  store i32 %6, ptr %4, align 4
  %7 = load i32, ptr %4, align 4
  ret i32 %7
}
```

### LLVM IR 关键概念小结

| 概念 | 说明 | 示例 |
|------|------|------|
| **SSA** | 每个虚拟寄存器只赋值一次 | `%5 = load ...` 后不会再有 `%5 = ...` |
| **内存操作** | 变量通过 alloca/store/load 三件套访问 | `%4 = alloca` → `store ... %4` → `load ... %4` |
| **控制流** | 基本块 + 跳转（br/condbr） | `br i1 %cond, label %then, label %else` |
| **类型系统** | `i32`（32位整数）、`i1`（布尔）、`void` | `%5 = icmp eq i32 %3, 0` → 结果为 i1 |
| **结构化表示** | 指令为 `Instruction` 对象，非字符串 | `inst.opcode == Opcode::Add`，无需正则 |

---

## 阶段 4：寄存器分配 (LinearScanAllocator)

### 功能说明

寄存器分配器定义在 [reg_alloc.h](../src/include/reg_alloc.h) / [reg_alloc.cpp](../src/reg_alloc.cpp) 中，为 IR 中的虚拟寄存器分配 RISC-V 物理寄存器。当物理寄存器不足时，部分虚拟寄存器会被**溢出**（spill）到栈上。

### RISC-V 寄存器约定

```
保留寄存器（不参与分配）:
  x0(zero)  — 硬连线为 0        x1(ra)    — 返回地址
  x2(sp)    — 栈指针            x3(gp), x4(tp) — 全局/线程指针
  x5(t0), x6(t1) — 溢出临时      x8(s0/fp) — 帧指针

可分配寄存器（按优先级排序）:
  x10-x17(a0-a7)    — 参数/返回值，优先级 0-7（最优先分配）
  x7(t2), x28-31    — 临时寄存器，优先级 20-24
  x18-x27(s2-s11)   — 被调用者保存，优先级 40-49
  x9(s1)            — 被调用者保存，优先级 50
```

### 分配流程

```
LinearScanAllocator::allocate(Function &F)
 ├─ 1. processParameters()          绑定参数到 a0-a7
 ├─ 2. LivenessAnalysis::run(F)     活跃性分析
 │      ├─ F.buildCFG()             构建控制流图
 │      ├─ computeUseDefSets()      计算每块的 use/def 集合
 │      ├─ buildRPO()               构建逆后序遍历
 │      └─ computeLivenessIteratively() 迭代求解 liveIn/liveOut
 ├─ 3. assignInstrPositions()       为指令分配线性编号
 ├─ 4. LiveIntervalBuilder::build() 构建活跃区间
 ├─ 5. runLinearScan()              线性扫描分配
 │      ├─ sortIntervalsByStart()   按起始位置排序
 │      └─ for each interval:
 │          ├─ expireOldIntervals() 释放过期寄存器
 │          ├─ allocatePhysicalReg() 分配物理寄存器
 │          └─ spillAtInterval()    无空闲则溢出
 └─ 6. collect results              收集使用信息
```

### 活跃性分析数据流方程

```
liveOut(B) = ∪ liveIn(S),  S ∈ succ(B)
liveIn(B)  = useSet(B) ∪ (liveOut(B) - defSet(B))
```

反向遍历 RPO 序列，迭代直到所有基本块的 liveIn/liveOut 不再变化（不动点）。

### 分配结果

`AllocationResult` 包含：
- `vregToPhys` — 虚拟寄存器 → 物理寄存器映射
- `vregToStack` — 虚拟寄存器 → 溢出栈槽映射
- `usedPhysRegs` — 实际使用过的物理寄存器集合
- `calleeSavedRegs` — 需要在 prologue/epilogue 中保存/恢复的寄存器

> 更详细的寄存器分配流程参见 [从调用链理解的寄存器分配流程](从调用链理解的寄存器分配流程.md) 和 [寄存器分配与代码生成详解](寄存器分配与代码生成详解.md)。

---

## 阶段 5：RISC-V 汇编生成 (RISCVCodeGen)

### 功能说明

RISC-V 代码生成器定义在 [riscv_codegen.h](../src/include/riscv_codegen.h) / [riscv_codegen.cpp](../src/riscv_codegen.cpp) 中，从结构化 `ir::Module` 直接生成 RISC-V32 汇编代码。

核心特点：**基于 `Opcode` 枚举的 switch 分派**，全程不解析字符串。

### 生成流程

```
RISCVCodeGen::generate(Module &module)
 ├─ 输出 ".text" 头
 ├─ precomputeAllocations(module)
 │   └─ for each function: new LinearScanAllocator → allocate(func) → 缓存
 └─ for each function:
     generateFunction(func)
      ├─ 输出 .globl + 函数标签
      ├─ 输出 __PROLOGUE_PLACEHOLDER__
      ├─ for each BasicBlock:
      │   ├─ 输出基本块标签（非 entry）
      │   └─ for each Instruction:
      │       generateInst(inst) → switch (inst.opcode) →
      │         Alloca → genAlloca    Store → genStore    Load → genLoad
      │         Add/Sub/Mul/SDiv/SRem → genBinOp
      │         ICmp → genICmp        CondBr → genCondBr  Br → genBr
      │         Ret/RetVoid → genRet  Call → genCall
      ├─ calculateStackFrame()           计算栈帧大小
      └─ updateStackFramePlaceholders()  替换占位符
```

### 关键优化

#### 1. addi 优化

当 `add`/`sub` 的一个操作数为立即数**且在 12 位有符号范围 [-2048, 2047] 内**时，直接生成 `addi`：

```cpp
auto inAddiRange = [](int v) { return v >= -2048 && v <= 2047; };

// add %def, %lhs, imm → addi def, lhs, imm
if (inst.opcode == Opcode::Add && inst.ops[1].isImm()
    && inAddiRange(inst.ops[1].immValue())) {
    emit("addi " + defReg + ", " + lhsReg + ", " + to_string(inst.ops[1].immValue()));
    return;
}
// sub %def, %lhs, imm → addi def, lhs, -imm
if (inst.opcode == Opcode::Sub && inst.ops[1].isImm()
    && inAddiRange(-inst.ops[1].immValue())) {
    emit("addi " + defReg + ", " + lhsReg + ", " + to_string(-inst.ops[1].immValue()));
    return;
}
```

超出范围的立即数由 `resolveUse` 自动通过 `li` 加载到临时寄存器。

#### 2. Branch Fusion（分支合并）

`genICmp` 将比较信息缓存到 `cmpMap_`，`genCondBr` 检查缓存后直接生成融合分支指令：

```
IR:                              有 Fusion:         无 Fusion:
  %5 = icmp slt %3, %4          blt a0, a1, .then  slt t2, a0, a1
  br i1 %5, label %then, ...    j .else             bnez t2, .then
                                                     j .else
```

#### 3. 占位符替换（栈帧计算）

函数开始时输出 prologue/epilogue 占位符，函数结束后才知道实际栈帧大小，最后统一替换。

### 栈帧布局

```
高地址
┌─────────────────────────────┐ ← s0 (帧指针 = 调用者 sp)
│    ra (返回地址)              │ s0-4
├─────────────────────────────┤
│    old s0 (旧帧指针)          │ s0-8
├─────────────────────────────┤
│  callee-saved 寄存器         │ s0-12, s0-16, ... (若有)
├─────────────────────────────┤
│  局部变量 (alloca)           │ -getAllocaOffset(vreg)(s0)
├─────────────────────────────┤
│  溢出栈槽 (spill)            │ spillSlotToSpOffset(slot)(sp)
├─────────────────────────────┤
│  caller-saved 保存区          │ sp + callArgAreaSize_
├─────────────────────────────┤
│  出栈参数区                   │ sp+0, sp+4, ... (第 9+ 个参数)
└─────────────────────────────┘ ← sp
低地址
```

其中：
- **alloca 偏移** = `allocaOffsets_[vreg] + frameOverhead_`（`frameOverhead_` = ra + s0 + callee-saved 区域大小），避免 alloca 区域与保存区重叠
- **溢出槽偏移** = `callArgAreaSize_ + callSaveSize_ + (-slot) - 4`，位于 caller-saved 保存区之上
- **caller-saved 保存区**和**出栈参数区**用于 `genCall` 的保存/恢复和 >8 参数传递

### 示例：汇编生成数据流追踪

**输入 IR → 生成的 RISC-V 汇编**：

| IR 指令 | RISC-V 指令 | 说明 |
|---------|------------|------|
| `%3 = alloca i32` | — | genAlloca: %3 → -4(s0) |
| `store i32 0, ptr %3` | `sw zero, -4(s0)` | resolveUse(imm 0) → zero |
| `%4 = alloca i32` | — | genAlloca: %4 → -8(s0) |
| `store i32 1, ptr %4` | `li a0, 1` + `sw a0, -8(s0)` | resolveUse(imm 1) → li |
| `%5 = load i32, ptr %4` | `lw a0, -8(s0)` | %5 → a0 |
| `%6 = add i32 %5, 2` | `addi a0, a0, 2` | **addi 优化** |
| `store i32 %6, ptr %4` | `sw a0, -8(s0)` | %6 在 a0 中 |
| `%7 = load i32, ptr %4` | `lw a0, -8(s0)` | %7 → a0 |
| `ret i32 %7` | epilogue + `ret` | a0 即返回值 |

> 更详细的代码生成流程参见 [从调用链理解的目标代码生成](从调用链理解的目标代码生成.md)。

---

## 完整示例：含函数调用的端到端数据流

### 输入：C 源代码

```c
int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 10;
    int z = add(x, y);
    return z;
}
```

### 阶段 1-2：Token 流 → AST

```
CompUnit {
  FuncDef {
    retType: "int", name: "add"
    params: [Param("a"), Param("b")]
    body: BlockStmt {
      ReturnStmt { expr: BinaryExpr("+", IdentifierExpr("a"), IdentifierExpr("b")) }
    }
  }
  FuncDef {
    retType: "int", name: "main"
    params: []
    body: BlockStmt {
      DeclStmt { name: "x", expr: NumberExpr(5) }
      DeclStmt { name: "y", expr: NumberExpr(10) }
      DeclStmt { name: "z", expr: CallExpr("add", [IdentifierExpr("x"), IdentifierExpr("y")]) }
      ReturnStmt { expr: IdentifierExpr("z") }
    }
  }
}
```

### 阶段 3：IR 生成

```llvm
define dso_local i32 @add(i32 noundef %0, i32 noundef %1) #0 {
entry:
  %2 = alloca i32, align 4       ; 参数 a 的栈槽
  store i32 %0, ptr %2, align 4  ; a → 栈
  %3 = alloca i32, align 4       ; 参数 b 的栈槽
  store i32 %1, ptr %3, align 4  ; b → 栈
  %4 = load i32, ptr %2, align 4 ; 加载 a
  %5 = load i32, ptr %3, align 4 ; 加载 b
  %6 = add nsw i32 %4, %5        ; a + b
  ret i32 %6
}

define dso_local i32 @main() #0 {
entry:
  %2 = alloca i32, align 4       ; main 返回值
  store i32 0, ptr %2, align 4
  %3 = alloca i32, align 4       ; x
  store i32 5, ptr %3, align 4
  %4 = alloca i32, align 4       ; y
  store i32 10, ptr %4, align 4
  %5 = alloca i32, align 4       ; z
  %6 = load i32, ptr %3, align 4 ; load x
  %7 = load i32, ptr %4, align 4 ; load y
  %8 = call i32 @add(i32 %6, i32 %7)
  store i32 %8, ptr %5, align 4  ; z = result
  %9 = load i32, ptr %5, align 4 ; load z
  ret i32 %9
}
```

### 阶段 4-5：寄存器分配 + 汇编生成

```asm
    .text
    .globl add
add:
    addi sp, sp, -16
    sw ra, 12(sp)
    sw s0, 8(sp)
    addi s0, sp, 16
    sw a0, -4(s0)                 # 参数 a 入栈
    sw a1, -8(s0)                 # 参数 b 入栈
    lw a0, -4(s0)                 # 加载 a
    lw a1, -8(s0)                 # 加载 b
    add a0, a0, a1                # a + b → a0
    lw ra, 12(sp)
    lw s0, 8(sp)
    addi sp, sp, 16
    ret
    .size add, .-add

    .globl main
main:
    addi sp, sp, -32
    sw ra, 28(sp)
    sw s0, 24(sp)
    addi s0, sp, 32
    sw zero, -4(s0)               # main 返回值 = 0
    li a0, 5
    sw a0, -8(s0)                 # x = 5
    li a0, 10
    sw a0, -12(s0)                # y = 10
    lw a0, -8(s0)                 # 加载 x → a0（第一参数）
    lw a1, -12(s0)                # 加载 y → a1（第二参数）
    call add                      # 调用 add(x, y)
    sw a0, -16(s0)                # z = 返回值
    lw a0, -16(s0)                # 加载 z → a0
    lw ra, 28(sp)
    lw s0, 24(sp)
    addi sp, sp, 32
    ret
    .size main, .-main
```

---

## 关键技术点总结

### 1. 结构化 IR vs 字符串 IR

| 方面 | 旧方案（字符串 IR） | 当前方案（结构化 IR） |
|------|-------------------|-------------------|
| IR 表示 | `string` 拼接 | `ir::Module` 对象树 |
| 指令识别 | 正则匹配 `regex_match` | `Opcode` 枚举 `switch` |
| 操作数访问 | 字符串解析 | `Operand::isVReg()`/`regId()` |
| 活跃性分析 | 扫描字符串提取 def/use | `inst->defReg()`/`useRegs()` |
| CFG 构建 | 解析标签和分支字符串 | `branchTargets()` + `blockMap` |

### 2. 控制流结构

- **if-else**: 3 个基本块（then / else / endif），条件分支 + 两个无条件跳转合并
- **while**: 3 个基本块（cond / body / end），条件块循环回跳
- **break/continue**: 利用标签栈（`breakLabels_` / `continueLabels_`）跳转到对应块
- **短路求值**: `alloca i1` + 条件分支 + store true/false + merge 块

### 3. 函数调用约定（RISC-V）

| 角色 | 寄存器 | 保存责任 |
|------|--------|---------|
| 参数/返回值 | a0-a7 | Caller-saved |
| 临时寄存器 | t0-t6 | Caller-saved |
| 保存寄存器 | s0-s11 | Callee-saved |
| 返回地址 | ra | Callee-saved |
| 栈/帧指针 | sp, s0(fp) | Callee-saved |

### 4. 寄存器分配策略

- **线性扫描算法**：按活跃区间起始点排序后单遍扫描
- **优先级分配**：a0-a7 优先（调用者保存，分配代价低）
- **溢出策略**：无空闲寄存器时，优先溢出结束最晚的区间并将其物理寄存器转给当前区间
- **溢出临时寄存器**：t0/t1 保留用于溢出加载/存储，交替使用避免冲突

---

## 编译器使用示例

### 命令行用法

```bash
# 编译 C 文件到汇编（默认模式）
./build/toyc input.c

# 仅输出 AST
./build/toyc input.c --ast

# 仅输出 LLVM IR
./build/toyc input.c --ir

# 输出所有阶段（AST + IR + ASM）
./build/toyc input.c --all

# 输出汇编到文件
./build/toyc input.c -o output.s

# 从 .ll 文件直接生成汇编
./build/toyc input.ll --asm
```

### 完整验证流程（WSL 环境）

```bash
# 1. ToyC 生成汇编
./build/toyc examples/compiler_inputs/01_minimal.c -o test/asm/01_minimal_toyc.s

# 2. Clang 编译参考版本
clang --target=riscv32-unknown-elf -march=rv32im -mabi=ilp32 -S \
    examples/compiler_inputs/01_minimal.c -o test/asm/01_minimal_clang.s

# 3. 汇编 + 链接 + QEMU 运行
clang --target=riscv32-unknown-elf -march=rv32im -mabi=ilp32 \
    test/asm/01_minimal_toyc.s scripts/crt0.s -nostdlib -o test.elf
qemu-riscv32 test.elf
echo $?  # 检查退出码
```

---

## 附录：数据结构速查

### Token 类型
```
ID, NUMBER                                     字面量
INT, VOID, IF, ELSE, WHILE, RETURN,           关键字
BREAK, CONTINUE
PLUS, MINUS, TIMES, DIV, MOD                  算术
GT, LT, GE, LE, EQ, NE                        比较
OR, AND, NOT                                   逻辑
ASSIGN                                         赋值
LPAREN, RPAREN, LBRACE, RBRACE, SEMI, COMMA   分隔符
```

### AST 节点类型
```
表达式: NumberExpr, IdentifierExpr, BinaryExpr, UnaryExpr, CallExpr
语句:   DeclStmt, AssignStmt, IfStmt, WhileStmt, ReturnStmt,
        BreakStmt, ContinueStmt, BlockStmt
顶层:   FuncDef
```

### IR 指令类型（Opcode 枚举）
```
内存:   Alloca, Load, Store
算术:   Add, Sub, Mul, SDiv, SRem
比较:   ICmp (EQ, NE, SLT, SGT, SLE, SGE)
控制流: Br, CondBr
返回:   Ret, RetVoid
调用:   Call
```

### RISC-V 指令
```
数据: li, mv, lw, sw, lb, sb
算术: add, sub, mul, div, rem, addi
比较: slt, seqz, snez, xori
分支: beq, bne, blt, bgt, ble, bge, bnez, j
调用: call, ret
```

---

## 总结

ToyC 编译器的完整流程可概括为：

```
C 源代码
  ↓ Lexer (lexer.cpp)
Token 流
  ↓ Parser (parser.cpp) — 递归下降
AST (ast.h)
  ↓ IRBuilder (ir_builder.cpp) — 递归遍历 AST
ir::Module (ir.h) — 结构化 LLVM IR
  ↓ LinearScanAllocator (reg_alloc.cpp) — 活跃性分析 + 线性扫描
AllocationResult — vreg→physReg / vreg→stackSlot
  ↓ RISCVCodeGen (riscv_codegen.cpp) — opcode 分派
RISC-V 汇编文本
```

每个阶段都有明确的输入输出类型，阶段间通过类型安全的结构化数据传递，而非字符串。后端直接操作 IR 对象而非解析文本，使得整个编译流程更加健壮和可维护。
