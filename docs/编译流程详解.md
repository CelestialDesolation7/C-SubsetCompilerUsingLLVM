# ToyC 编译器完整流程详解

## 概述

本文档详细介绍 ToyC 编译器从 C 语言源代码到 RISC-V 汇编代码的完整编译流程。整个编译过程分为以下几个主要阶段：

```
C 源代码 → 词法分析 → 语法分析 → AST → LLVM IR 生成 → RISC-V 汇编生成
```

我们将结合代码和示例，逐步追踪数据在各个阶段的转换过程。

---

## 阶段 0：主程序入口 (main.cpp)

### 数据流概览

编译器的主入口在 [main.cpp](../src/main.cpp) 中，负责：
- 解析命令行参数
- 协调各个编译阶段
- 控制输出模式（AST、IR、汇编）

### 关键代码分析

```cpp
int main(int argc, char **argv) {
    // 1. 解析命令行参数，确定输入文件和输出模式
    string inputFile = "";
    string outputMode = "asm";  // 默认输出汇编
    
    // 2. 读取输入源代码
    stringstream buf;
    // ... 读取文件或标准输入到 buf
    
    // 3. 根据输入类型分支处理
    if (isLLVMIR) {
        llvmIR = buf.str();  // 直接使用 IR
    } else {
        // 启动前端编译流程
        Parser parser(buf.str());           // 创建语法分析器
        funcs = parser.parseCompUnit();     // 解析得到 AST
        llvmIR = generateLLVMIR(funcs);     // 生成 LLVM IR
    }
    
    // 4. 生成目标代码
    if (outputMode == "asm") {
        string assembly = generateRISCVAssembly(llvmIR);  // IR → 汇编
        *out << assembly;
    }
}
```

### 示例：编译 01_minimal.c

**输入文件** [examples/compiler_inputs/01_minimal.c](../examples/compiler_inputs/01_minimal.c)：
```c
int main() {
    return 0;
}
```

主程序会依次调用：
1. `Parser parser(源代码)` - 创建解析器
2. `parser.parseCompUnit()` - 获得 AST
3. `generateLLVMIR(funcs)` - 生成 IR
4. `generateRISCVAssembly(llvmIR)` - 生成汇编

---

## 阶段 1：词法分析 (Lexer)

### 功能说明

词法分析器 [lexer.cpp](../src/lexer.cpp) 将源代码字符串转换为 **Token 流**。Token 是编译器识别的最小语法单元。

### 核心数据结构

```cpp
// Token 类型枚举
enum class TokenType {
    ID,      // 标识符：变量名、函数名
    NUMBER,  // 数字字面量
    INT, VOID, IF, ELSE, WHILE, RETURN, BREAK, CONTINUE,  // 关键字
    PLUS, MINUS, TIMES, DIV, MOD,                         // 算术运算符
    GT, LT, GE, LE, EQ, NE,                               // 关系运算符
    OR, AND, NOT,                                          // 逻辑运算符
    ASSIGN,                                                // 赋值
    LPAREN, RPAREN, LBRACE, RBRACE, SEMI, COMMA,          // 分隔符
    END, UNKNOWN                                           // 特殊标记
};

// Token 结构体
struct Token {
    TokenType type;  // Token 类型
    string lexeme;   // 原始文本
    int line;        // 所在行号
};
```

### 工作流程

```cpp
class Lexer {
    string src;       // 源代码
    size_t pos = 0;   // 当前扫描位置
    int line = 1;     // 当前行号
    
    Token nextToken() {
        skipWhitespace();  // 跳过空白和注释
        
        char c = advance();  // 读取当前字符
        
        // 根据字符类型返回对应 Token
        if (c == '+') return makeToken(TokenType::PLUS);
        if (c == '=') {
            if (peek() == '=') {
                advance();
                return {TokenType::EQ, "==", line};
            }
            return makeToken(TokenType::ASSIGN);
        }
        if (isalpha(c)) return identifier();  // 标识符或关键字
        if (isdigit(c)) return number();      // 数字
        // ...
    }
};
```

### 示例：词法分析过程

**输入**：
```c
int main() {
    return 0;
}
```

**Token 流输出**：
```
[INT, "int", line=1]
[ID, "main", line=1]
[LPAREN, "(", line=1]
[RPAREN, ")", line=1]
[LBRACE, "{", line=1]
[RETURN, "return", line=2]
[NUMBER, "0", line=2]
[SEMI, ";", line=2]
[RBRACE, "}", line=3]
[END, "", line=3]
```

### 关键实现细节

1. **关键字识别**：通过哈希表查找
   ```cpp
   static const unordered_map<string, TokenType> keywords = {
       {"int", TokenType::INT},
       {"return", TokenType::RETURN},
       // ...
   };
   ```

2. **注释处理**：跳过 `//` 单行注释
   ```cpp
   if (peek() == '/' && src[pos+1] == '/') {
       while (peek() != '\n' && peek() != '\0')
           advance();
   }
   ```

3. **双字符运算符**：需要预读一个字符
   ```cpp
   if (c == '=') {
       if (peek() == '=') {  // ==
           advance();
           return {TokenType::EQ, "==", line};
       }
       return makeToken(TokenType::ASSIGN);  // =
   }
   ```

---

## 阶段 2：语法分析 (Parser)

### 功能说明

语法分析器 [parser.cpp](../src/parser.cpp) 将 Token 流转换为 **抽象语法树（AST）**。

### 核心数据结构

AST 定义在 [ast.h](../src/include/ast.h) 中，主要节点类型：

```cpp
// 基类
struct ASTNode {
    virtual void print(int indent) const = 0;
};
using ASTPtr = shared_ptr<ASTNode>;

// 表达式节点
struct NumberExpr : Expr { int value; };              // 数字：42
struct IdentifierExpr : Expr { string name; };        // 标识符：x
struct BinaryExpr : Expr {                            // 二元运算：x + y
    string op;
    ASTPtr lhs, rhs;
};
struct UnaryExpr : Expr {                             // 一元运算：-x, !flag
    string op;
    ASTPtr expr;
};
struct CallExpr : Expr {                              // 函数调用：foo(a, b)
    string callee;
    vector<ASTPtr> args;
};

// 语句节点
struct DeclStmt : Stmt {                              // 声明：int x = 5;
    string name;
    ASTPtr expr;
};
struct AssignStmt : Stmt {                            // 赋值：x = 10;
    string name;
    ASTPtr expr;
};
struct IfStmt : Stmt {                                // if 语句
    ASTPtr cond, thenStmt, elseStmt;
};
struct WhileStmt : Stmt {                             // while 循环
    ASTPtr cond, body;
};
struct ReturnStmt : Stmt { ASTPtr expr; };            // return 语句
struct BreakStmt : Stmt {};                           // break
struct ContinueStmt : Stmt {};                        // continue
struct BlockStmt : Stmt { vector<ASTPtr> stmts; };    // 语句块：{ ... }

// 函数定义
struct FuncDef : ASTNode {
    string retType;              // 返回类型：int/void
    string name;                 // 函数名
    vector<Param> params;        // 参数列表
    shared_ptr<BlockStmt> body;  // 函数体
};
```

### 递归下降解析

Parser 使用 **递归下降** 方法，每个语法规则对应一个函数：

```cpp
class Parser {
    Lexer lex;
    Token cur, nxt;  // 当前和下一个 Token（预读）
    
    // 核心解析函数
    vector<shared_ptr<FuncDef>> parseCompUnit();  // 编译单元
    shared_ptr<FuncDef> parseFuncDef();           // 函数定义
    shared_ptr<BlockStmt> parseBlock();           // 语句块
    ASTPtr parseStmt();                           // 语句
    ASTPtr parseExpr();                           // 表达式
    
    // 表达式按优先级分层解析
    ASTPtr parseLOr();      // 逻辑或：||
    ASTPtr parseLAnd();     // 逻辑与：&&
    ASTPtr parseRel();      // 关系运算：<, >, ==, !=
    ASTPtr parseAdd();      // 加减：+, -
    ASTPtr parseMul();      // 乘除模：*, /, %
    ASTPtr parseUnary();    // 一元：+, -, !
    ASTPtr parsePrimary();  // 基本表达式：数字、标识符、括号
};
```

### 语法规则与实现

#### 1. 编译单元

```
CompUnit → FuncDef+
```

```cpp
vector<shared_ptr<FuncDef>> Parser::parseCompUnit() {
    vector<shared_ptr<FuncDef>> funcs;
    while (cur.type == TokenType::INT || cur.type == TokenType::VOID)
        funcs.push_back(parseFuncDef());
    return funcs;
}
```

#### 2. 函数定义

```
FuncDef → ("int" | "void") ID "(" Params? ")" Block
Params  → "int" ID ("," "int" ID)*
```

```cpp
shared_ptr<FuncDef> Parser::parseFuncDef() {
    string retType = cur.lexeme;  // int 或 void
    advance();
    
    string name = cur.lexeme;     // 函数名
    advance();
    
    expect(TokenType::LPAREN);
    auto params = parseParams();
    expect(TokenType::RPAREN);
    
    auto body = parseBlock();
    
    auto f = make_shared<FuncDef>();
    f->retType = retType;
    f->name = name;
    f->params = params;
    f->body = body;
    return f;
}
```

#### 3. 语句解析

```cpp
ASTPtr Parser::parseStmt() {
    // 块语句
    if (cur.type == TokenType::LBRACE)
        return parseBlock();
    
    // if 语句
    if (cur.type == TokenType::IF) {
        advance();
        expect(TokenType::LPAREN);
        auto cond = parseExpr();
        expect(TokenType::RPAREN);
        auto thenS = parseStmt();
        ASTPtr elseS = nullptr;
        if (match(TokenType::ELSE))
            elseS = parseStmt();
        return make_shared<IfStmt>(cond, thenS, elseS);
    }
    
    // while 语句
    if (cur.type == TokenType::WHILE) {
        advance();
        expect(TokenType::LPAREN);
        auto cond = parseExpr();
        expect(TokenType::RPAREN);
        auto body = parseStmt();
        return make_shared<WhileStmt>(cond, body);
    }
    
    // return 语句
    if (match(TokenType::RETURN)) {
        ASTPtr e = nullptr;
        if (cur.type != TokenType::SEMI)
            e = parseExpr();
        expect(TokenType::SEMI);
        return make_shared<ReturnStmt>(e);
    }
    
    // 变量声明：int x = expr;
    if (cur.type == TokenType::INT) {
        advance();
        string name = cur.lexeme;
        advance();
        expect(TokenType::ASSIGN);
        auto e = parseExpr();
        expect(TokenType::SEMI);
        return make_shared<DeclStmt>(name, e);
    }
    
    // 赋值语句：x = expr;
    if (cur.type == TokenType::ID && nxt.type == TokenType::ASSIGN) {
        string name = cur.lexeme;
        advance();
        advance();
        auto e = parseExpr();
        expect(TokenType::SEMI);
        return make_shared<AssignStmt>(name, e);
    }
    
    // ...
}
```

#### 4. 表达式解析（运算符优先级）

表达式解析通过分层函数实现运算符优先级：

```cpp
// 优先级从低到高
ASTPtr parseExpr()     { return parseLOr(); }     // 入口
ASTPtr parseLOr()      { /* 处理 || */ }          // 优先级 1
ASTPtr parseLAnd()     { /* 处理 && */ }          // 优先级 2
ASTPtr parseRel()      { /* 处理 <, >, ==, != */ }// 优先级 3
ASTPtr parseAdd()      { /* 处理 +, - */ }        // 优先级 4
ASTPtr parseMul()      { /* 处理 *, /, % */ }     // 优先级 5
ASTPtr parseUnary()    { /* 处理 +, -, ! */ }     // 优先级 6
ASTPtr parsePrimary()  { /* 数字、标识符、括号 */ }// 优先级 7
```

示例：解析加法表达式
```cpp
ASTPtr Parser::parseAdd() {
    auto left = parseMul();  // 先解析更高优先级的乘法
    while (cur.type == TokenType::PLUS || cur.type == TokenType::MINUS) {
        string op = cur.lexeme;
        advance();
        auto right = parseMul();
        left = make_shared<BinaryExpr>(op, left, right);
    }
    return left;
}
```

### 示例：解析过程追踪

**输入代码**：
```c
int main() {
    int x = 1;
    x = x + 2;
    return x;
}
```

**Token 流** → **AST**：

```
Tokens:                           AST:
INT ID(main) LPAREN RPAREN        FuncDef {
LBRACE                              retType: "int"
  INT ID(x) ASSIGN NUMBER(1)        name: "main"
  SEMI                               params: []
  ID(x) ASSIGN ID(x) PLUS           body: BlockStmt {
  NUMBER(2) SEMI                      stmts: [
  RETURN ID(x) SEMI                     DeclStmt { name="x", expr=NumberExpr(1) }
RBRACE                                  AssignStmt { 
END                                       name="x", 
                                          expr=BinaryExpr {
                                            op="+",
                                            lhs=IdentifierExpr("x"),
                                            rhs=NumberExpr(2)
                                          }
                                        }
                                        ReturnStmt { expr=IdentifierExpr("x") }
                                      ]
                                    }
                                  }
```

---

## 阶段 3：LLVM IR 生成

### 功能说明

LLVM IR 生成器 [llvm_ir.cpp](../src/llvm_ir.cpp) 将 AST 转换为 **LLVM 中间表示（IR）**。

LLVM IR 是一种低级的、类似汇编的中间语言，具有以下特点：
- **SSA 形式**（Static Single Assignment）：每个变量只赋值一次
- **类型化**：每个值都有明确的类型（如 i32）
- **基于寄存器**：使用虚拟寄存器（%1, %2, ...）
- **显式内存操作**：使用 `alloca`、`load`、`store` 指令

### 核心数据结构

```cpp
class LLVMIRGenerator {
    int tempCount;                           // 临时变量计数器
    int labelCount;                          // 标签计数器
    int varCount;                            // 变量计数器
    vector<map<string, string>> scopeStack;  // 作用域栈
    string currentInstructions;              // 指令序列
    vector<string> breakLabels;              // break 标签栈
    vector<string> continueLabels;           // continue 标签栈
    bool hasReturn;                          // 是否有 return
    
    // 核心方法
    string generateFunction(shared_ptr<FuncDef> funcDef);
    string generateExpr(ASTPtr expr);
    void generateStmt(ASTPtr stmt);
};
```

### IR 生成流程

#### 1. 函数生成

```cpp
string LLVMIRGenerator::generateFunction(shared_ptr<FuncDef> &funcDef) {
    // 1. 重置状态
    varCount = funcDef->params.size();
    scopeStack.clear();
    enterScope();  // 创建函数作用域
    currentInstructions = "";
    hasReturn = false;
    
    // 2. 函数签名
    string retType = (funcDef->retType == "void") ? "void" : "i32";
    string ir = "define dso_local " + retType + " @" + funcDef->name + "(";
    
    // 参数列表
    for (size_t i = 0; i < params.size(); ++i) {
        if (i > 0) ir += ", ";
        ir += "i32 noundef %" + to_string(i);
    }
    ir += ") #0 {\n";
    
    // 3. main 函数的返回值变量
    if (funcDef->name == "main") {
        string retVar = newVar();
        addVariable("main_ret", retVar);
        addInstruction("%" + retVar + " = alloca i32, align 4");
        addInstruction("store i32 0, ptr %" + retVar + ", align 4");
    }
    
    // 4. 参数的 alloca + store
    for (size_t i = 0; i < params.size(); ++i) {
        string slot = newVar();
        addInstruction("%" + slot + " = alloca i32, align 4");
        addInstruction("store i32 %" + to_string(i) + ", ptr %" + slot + ", align 4");
        addVariable(origParamName[i], slot);
    }
    
    // 5. 生成函数体
    generateBlock(funcDef->body);
    
    // 6. 添加指令
    ir += currentInstructions;
    
    // 7. 默认返回
    if (!hasReturn) {
        if (retType == "i32")
            ir += "  ret i32 0\n";
        else
            ir += "  ret void\n";
    }
    
    ir += "}\n\n";
    return ir;
}
```

#### 2. 表达式生成

```cpp
string LLVMIRGenerator::generateExpr(ASTPtr expr) {
    // 数字字面量：直接返回值
    if (auto numExpr = dynamic_pointer_cast<NumberExpr>(expr)) {
        return to_string(numExpr->value);
    }
    
    // 标识符：生成 load 指令
    if (auto idExpr = dynamic_pointer_cast<IdentifierExpr>(expr)) {
        string varName = findVariable(idExpr->name);
        string temp = newTemp();
        addInstruction(temp + " = load i32, ptr %" + varName + ", align 4");
        return temp;
    }
    
    // 二元运算
    if (auto binExpr = dynamic_pointer_cast<BinaryExpr>(expr)) {
        string lhs = generateExpr(binExpr->lhs);
        string rhs = generateExpr(binExpr->rhs);
        string result = newTemp();
        
        if (binExpr->op == "+") {
            addInstruction(result + " = add nsw i32 " + lhs + ", " + rhs);
        } else if (binExpr->op == "-") {
            addInstruction(result + " = sub nsw i32 " + lhs + ", " + rhs);
        } else if (binExpr->op == "*") {
            addInstruction(result + " = mul nsw i32 " + lhs + ", " + rhs);
        }
        // ... 其他运算符
        
        return result;
    }
    
    // 函数调用
    if (auto callExpr = dynamic_pointer_cast<CallExpr>(expr)) {
        // 生成参数
        vector<string> argTemps;
        for (auto &arg : callExpr->args) {
            argTemps.push_back(generateExpr(arg));
        }
        
        // 生成调用指令
        string result = newTemp();
        string argList = "";
        for (size_t i = 0; i < argTemps.size(); ++i) {
            if (i > 0) argList += ", ";
            argList += "i32 " + argTemps[i];
        }
        addInstruction(result + " = call i32 @" + callExpr->callee + 
                      "(" + argList + ")");
        return result;
    }
    
    return "0";
}
```

#### 3. 语句生成

```cpp
void LLVMIRGenerator::generateStmt(ASTPtr stmt) {
    // 变量声明
    if (auto declStmt = dynamic_pointer_cast<DeclStmt>(stmt)) {
        string slot = newVar();
        addVariable(declStmt->name, slot);
        addInstruction("%" + slot + " = alloca i32, align 4");
        
        string value = generateExpr(declStmt->expr);
        addInstruction("store i32 " + value + ", ptr %" + slot + ", align 4");
    }
    
    // 赋值语句
    else if (auto assignStmt = dynamic_pointer_cast<AssignStmt>(stmt)) {
        string varName = findVariable(assignStmt->name);
        string value = generateExpr(assignStmt->expr);
        addInstruction("store i32 " + value + ", ptr %" + varName + ", align 4");
    }
    
    // return 语句
    else if (auto retStmt = dynamic_pointer_cast<ReturnStmt>(stmt)) {
        if (retStmt->expr) {
            string value = generateExpr(retStmt->expr);
            addInstruction("ret i32 " + value);
        } else {
            addInstruction("ret void");
        }
        hasReturn = true;
    }
    
    // if 语句
    else if (auto ifStmt = dynamic_pointer_cast<IfStmt>(stmt)) {
        string thenLabel = newLabel("then");
        string elseLabel = newLabel("else");
        string endLabel = newLabel("if_end");
        
        // 生成条件
        string cond = generateExpr(ifStmt->cond);
        
        // 条件分支
        if (ifStmt->elseStmt) {
            addInstruction("br i1 " + cond + ", label %" + thenLabel + 
                          ", label %" + elseLabel);
        } else {
            addInstruction("br i1 " + cond + ", label %" + thenLabel + 
                          ", label %" + endLabel);
        }
        
        // then 分支
        addInstruction(thenLabel + ":", true);
        generateStmt(ifStmt->thenStmt);
        addInstruction("br label %" + endLabel);
        
        // else 分支
        if (ifStmt->elseStmt) {
            addInstruction(elseLabel + ":", true);
            generateStmt(ifStmt->elseStmt);
            addInstruction("br label %" + endLabel);
        }
        
        // 结束标签
        addInstruction(endLabel + ":", true);
    }
    
    // while 语句
    else if (auto whileStmt = dynamic_pointer_cast<WhileStmt>(stmt)) {
        string condLabel = newLabel("while_cond");
        string bodyLabel = newLabel("while_body");
        string endLabel = newLabel("while_end");
        
        breakLabels.push_back(endLabel);
        continueLabels.push_back(condLabel);
        
        // 跳转到条件检查
        addInstruction("br label %" + condLabel);
        
        // 条件块
        addInstruction(condLabel + ":", true);
        string cond = generateExpr(whileStmt->cond);
        addInstruction("br i1 " + cond + ", label %" + bodyLabel + 
                      ", label %" + endLabel);
        
        // 循环体
        addInstruction(bodyLabel + ":", true);
        generateStmt(whileStmt->body);
        addInstruction("br label %" + condLabel);
        
        // 结束标签
        addInstruction(endLabel + ":", true);
        
        breakLabels.pop_back();
        continueLabels.pop_back();
    }
    
    // 语句块
    else if (auto blockStmt = dynamic_pointer_cast<BlockStmt>(stmt)) {
        enterScope();  // 进入新作用域
        for (auto &s : blockStmt->stmts) {
            generateStmt(s);
        }
        exitScope();   // 退出作用域
    }
}
```

### 示例：IR 生成过程

**输入 AST**（来自前面的示例）：
```
FuncDef {
  retType: "int", name: "main"
  body: BlockStmt {
    DeclStmt { name="x", expr=NumberExpr(1) }
    AssignStmt { name="x", expr=BinaryExpr("+", IdentifierExpr("x"), NumberExpr(2)) }
    ReturnStmt { expr=IdentifierExpr("x") }
  }
}
```

**生成的 LLVM IR**：
```llvm
; ModuleID = 'toyc'
source_filename = "toyc"
target triple = "riscv32-unknown-elf"

define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4        ; main 函数返回值变量
  store i32 0, ptr %1, align 4    ; 初始化为 0
  
  %2 = alloca i32, align 4        ; 分配变量 x
  store i32 1, ptr %2, align 4    ; x = 1
  
  %3 = load i32, ptr %2, align 4  ; 加载 x 的值到 %3
  %4 = add nsw i32 %3, 2          ; %4 = %3 + 2
  store i32 %4, ptr %2, align 4   ; 存储回 x
  
  %5 = load i32, ptr %2, align 4  ; 加载 x 的值到 %5
  ret i32 %5                       ; 返回 %5
}
```

**数据流分析**：

| 步骤 | 操作 | 说明 |
|------|------|------|
| 1 | `%1 = alloca i32` | 为 main 返回值分配栈空间 |
| 2 | `store i32 0, ptr %1` | 初始化返回值为 0 |
| 3 | `%2 = alloca i32` | 为变量 x 分配栈空间 |
| 4 | `store i32 1, ptr %2` | x = 1（存储到内存） |
| 5 | `%3 = load i32, ptr %2` | 读取 x 的值到寄存器 %3 |
| 6 | `%4 = add nsw i32 %3, 2` | 计算 %3 + 2，结果存到 %4 |
| 7 | `store i32 %4, ptr %2` | 将 %4 存回 x |
| 8 | `%5 = load i32, ptr %2` | 读取 x 的值到寄存器 %5 |
| 9 | `ret i32 %5` | 返回 %5 |

### LLVM IR 关键概念

#### SSA 形式
每个虚拟寄存器只赋值一次：
```llvm
%1 = add i32 1, 2    ; %1 被赋值一次
%2 = mul i32 %1, 3   ; %2 被赋值一次
; 不会出现 %1 = ... 第二次赋值
```

#### 内存操作
- `alloca`：在栈上分配空间
- `store`：将值写入内存
- `load`：从内存读取值

```llvm
%ptr = alloca i32        ; 分配 4 字节
store i32 42, ptr %ptr   ; 写入值 42
%val = load i32, ptr %ptr; 读取值到 %val
```

#### 控制流
- `br`：分支跳转
- `label`：基本块标签

```llvm
br i1 %cond, label %then, label %else  ; 条件分支
br label %target                        ; 无条件跳转

then:                                   ; 标签
  ; ...
```

---

## 阶段 4：RISC-V 汇编生成

### 功能说明

RISC-V 汇编生成器 [riscv_gen.cpp](../src/riscv_gen.cpp) 将 LLVM IR 转换为 **RISC-V32 汇编代码**。

这个阶段包含：
1. **指令选择**：将 IR 指令映射到 RISC-V 指令
2. **寄存器分配**：为虚拟寄存器分配物理寄存器
3. **栈帧管理**：管理函数调用的栈空间

### 核心数据结构

```cpp
class RISCVGenerator {
    map<string, int> variables;           // 变量名 → 栈偏移
    int stackOffset;                      // 当前栈偏移
    int totalStackSize;                   // 总栈帧大小
    string currentInstructions;           // 指令序列
    string currentFunction;               // 当前函数名
    
    // 寄存器分配器
    unique_ptr<LinearScanAllocator> registerAllocator;
    map<string, unique_ptr<LinearScanAllocator>> functionAllocators;
    
    // 核心方法
    string generateModule(const string &llvmIR);
    void parseLLVMInstruction(const string &line);
    void generateFunctionDef(const string &funcName, const string &retType);
};
```

### RISC-V 寄存器约定

| 寄存器 | 用途 | 是否需要保存 |
|--------|------|------------|
| a0-a7  | 参数和返回值 | Caller-saved |
| t0-t6  | 临时寄存器 | Caller-saved |
| s0-s11 | 保存寄存器 | Callee-saved |
| ra     | 返回地址 | Callee-saved |
| sp     | 栈指针 | Callee-saved |

### 汇编生成流程

#### 1. 函数序言（Prologue）

```cpp
void RISCVGenerator::generateFunctionDef(const string &funcName, const string &retType) {
    currentFunction = funcName;
    
    // 函数标签
    addInstruction(funcName + ":                                   # @" + funcName);
    addInstruction("# %bb.0:");
    
    // 栈帧分配（稍后会被替换为实际大小）
    addInstruction("	__STACK_FRAME_ALLOCATION_PLACEHOLDER__");
    
    // 实际会生成：
    // addi sp, sp, -<stackSize>     ; 分配栈空间
    // sw   ra, <offset>(sp)         ; 保存返回地址
    // sw   s0, <offset>(sp)         ; 保存帧指针
    // addi s0, sp, <stackSize>      ; 设置帧指针
}
```

#### 2. IR 指令到汇编指令的映射

```cpp
void RISCVGenerator::parseLLVMInstruction(const string &line) {
    // alloca 指令：分配栈空间
    // %1 = alloca i32, align 4
    if (regex_match(line, REGEX_ALLOCA)) {
        string var = match[1];  // %1
        int offset = allocateStack();
        variables[var] = offset;
        // 生成注释，不需要运行时指令
        addInstruction("	# " + var + " at " + to_string(offset) + "(s0)");
    }
    
    // store 指令：存储值到内存
    // store i32 42, ptr %1, align 4
    else if (regex_match(line, REGEX_STORE)) {
        string value = match[2];  // 42 或 %2
        string ptr = match[3];    // %1
        
        int offset = variables[ptr];
        
        if (isImmediate(value)) {
            // 立即数
            addInstruction("	li	t1, " + value);
            addInstruction("	sw	t1, " + to_string(offset) + "(s0)");
        } else {
            // 寄存器
            string reg = getReg(value);
            addInstruction("	sw	" + reg + ", " + to_string(offset) + "(s0)");
        }
    }
    
    // load 指令：从内存加载值
    // %3 = load i32, ptr %2, align 4
    else if (regex_match(line, REGEX_LOAD)) {
        string dest = match[1];   // %3
        string ptr = match[3];    // %2
        
        int offset = variables[ptr];
        string destReg = allocateReg(dest);
        
        addInstruction("	lw	" + destReg + ", " + to_string(offset) + "(s0)");
    }
    
    // 算术运算：add, sub, mul, div
    // %4 = add nsw i32 %3, 2
    else if (regex_match(line, REGEX_ARITHMETIC)) {
        string dest = match[1];   // %4
        string op = match[2];     // add
        string lhs = match[4];    // %3
        string rhs = match[5];    // 2
        
        string lhsReg = getReg(lhs);
        string destReg = allocateReg(dest);
        
        if (op == "add") {
            if (isImmediate(rhs)) {
                addInstruction("	addi	" + destReg + ", " + lhsReg + ", " + rhs);
            } else {
                string rhsReg = getReg(rhs);
                addInstruction("	add	" + destReg + ", " + lhsReg + ", " + rhsReg);
            }
        }
        else if (op == "sub") {
            if (isImmediate(rhs)) {
                addInstruction("	addi	" + destReg + ", " + lhsReg + ", -" + rhs);
            } else {
                string rhsReg = getReg(rhs);
                addInstruction("	sub	" + destReg + ", " + lhsReg + ", " + rhsReg);
            }
        }
        else if (op == "mul") {
            string rhsReg = getReg(rhs);
            addInstruction("	mul	" + destReg + ", " + lhsReg + ", " + rhsReg);
        }
        else if (op == "sdiv") {
            string rhsReg = getReg(rhs);
            addInstruction("	div	" + destReg + ", " + lhsReg + ", " + rhsReg);
        }
    }
    
    // 比较指令：icmp
    // %5 = icmp slt i32 %4, 10
    else if (regex_match(line, REGEX_ICMP)) {
        string dest = match[1];   // %5
        string cond = match[2];   // slt
        string lhs = match[3];    // %4
        string rhs = match[4];    // 10
        
        string lhsReg = getReg(lhs);
        string rhsReg = getReg(rhs);
        string destReg = allocateReg(dest);
        
        if (cond == "slt") {       // <
            addInstruction("	slt	" + destReg + ", " + lhsReg + ", " + rhsReg);
        }
        else if (cond == "sgt") {  // >
            addInstruction("	slt	" + destReg + ", " + rhsReg + ", " + lhsReg);
        }
        else if (cond == "eq") {   // ==
            addInstruction("	sub	t1, " + lhsReg + ", " + rhsReg);
            addInstruction("	seqz	" + destReg + ", t1");
        }
        else if (cond == "ne") {   // !=
            addInstruction("	sub	t1, " + lhsReg + ", " + rhsReg);
            addInstruction("	snez	" + destReg + ", t1");
        }
    }
    
    // 分支指令：br
    // br i1 %5, label %then, label %else
    else if (regex_match(line, REGEX_BR_COND)) {
        string cond = match[1];       // %5
        string trueLabel = match[2];  // then
        string falseLabel = match[3]; // else
        
        string condReg = getReg(cond);
        addInstruction("	bnez	" + condReg + ", ." + trueLabel);
        addInstruction("	j	." + falseLabel);
    }
    
    // 无条件分支：br label %target
    else if (regex_match(line, REGEX_BR_UNCOND)) {
        string label = match[1];
        addInstruction("	j	." + label);
    }
    
    // 标签：then:
    else if (regex_match(line, REGEX_LABEL)) {
        string label = match[1];
        addInstruction("." + label + ":");
    }
    
    // 返回指令：ret i32 %5
    else if (regex_match(line, REGEX_RET)) {
        string type = match[1];   // i32
        string value = match[2];  // %5
        
        if (type == "i32") {
            if (value == "0") {
                addInstruction("	li	a0, 0");
            } else {
                string reg = getReg(value);
                addInstruction("	mv	a0, " + reg);
            }
        }
        
        hasReturn = true;
    }
    
    // 函数调用：%1 = call i32 @foo(i32 %2, i32 %3)
    else if (regex_match(line, REGEX_CALL)) {
        string dest = match[1];       // %1
        string retType = match[2];    // i32
        string funcName = match[3];   // foo
        string argList = match[4];    // i32 %2, i32 %3
        
        // 准备参数到 a0-a7
        vector<string> args = parseArguments(argList);
        for (size_t i = 0; i < args.size(); ++i) {
            string argReg = getReg(args[i]);
            addInstruction("	mv	a" + to_string(i) + ", " + argReg);
        }
        
        // 调用函数
        addInstruction("	call	" + funcName);
        
        // 保存返回值
        if (retType == "i32") {
            string destReg = allocateReg(dest);
            addInstruction("	mv	" + destReg + ", a0");
        }
    }
}
```

#### 3. 寄存器分配（线性扫描算法）

本项目使用 **线性扫描寄存器分配** 算法（实现在 [ra_linear_scan.cpp](../src/ra_linear_scan.cpp)）：

```cpp
class LinearScanAllocator {
    // 活跃区间管理
    vector<LiveInterval> intervals;  // 所有虚拟寄存器的活跃区间
    list<LiveInterval*> active;      // 当前活跃的区间
    
    // 寄存器分配
    void allocate() {
        // 按起始点排序活跃区间
        sort(intervals.begin(), intervals.end());
        
        for (auto &interval : intervals) {
            // 释放已结束的区间
            expireOldIntervals(interval);
            
            // 尝试分配寄存器
            if (freeRegisters.empty()) {
                spillAtInterval(interval);  // 溢出到栈
            } else {
                int reg = freeRegisters.front();
                freeRegisters.pop_front();
                interval.reg = reg;
                active.push_back(&interval);
            }
        }
    }
};
```

**活跃区间示例**：
```llvm
  %3 = load i32, ...      ; %3 定义点（起始）
  %4 = add i32 %3, 2      ; %3 使用点
  store i32 %4, ...       ; %4 最后使用点（结束）
  
  %3 活跃区间：[指令1, 指令2]
  %4 活跃区间：[指令2, 指令3]
```

#### 4. 函数尾声（Epilogue）

```cpp
void RISCVGenerator::generateFunctionEnd() {
    // 恢复被调用者保存寄存器
    // lw s0, ...
    // lw ra, ...
    
    // 栈帧回收
    addInstruction("	__STACK_FRAME_DEALLOCATION_PLACEHOLDER__");
    
    // 返回
    addInstruction("	ret");
    
    // 实际会生成：
    // lw   ra, <offset>(sp)         ; 恢复返回地址
    // lw   s0, <offset>(sp)         ; 恢复帧指针
    // addi sp, sp, <stackSize>      ; 回收栈空间
    // ret                           ; 返回
    
    addInstruction("                                        # -- End function");
}
```

#### 5. 栈帧布局

```
高地址
┌──────────────┐
│   参数区域    │ (调用其他函数时使用)
├──────────────┤
│   ra (返回地址)│ totalStackSize - 4
├──────────────┤
│   s0 (帧指针) │ totalStackSize - 8
├──────────────┤
│   局部变量1   │ offset = -4
├──────────────┤
│   局部变量2   │ offset = -8
├──────────────┤
│   ...        │
└──────────────┘ ← sp (栈指针)
低地址
```

### 示例：汇编生成过程

**输入 LLVM IR**（来自前面的示例）：
```llvm
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  %2 = alloca i32, align 4
  store i32 1, ptr %2, align 4
  %3 = load i32, ptr %2, align 4
  %4 = add nsw i32 %3, 2
  store i32 %4, ptr %2, align 4
  %5 = load i32, ptr %2, align 4
  ret i32 %5
}
```

**生成的 RISC-V 汇编**：
```riscv
	.text
	.globl	main                            # -- Begin function main
main:                                   # @main
# %bb.0:
	addi	sp, sp, -16                     # 分配 16 字节栈帧
	sw	ra, 12(sp)                      # 保存返回地址
	sw	s0, 8(sp)                       # 保存帧指针
	addi	s0, sp, 16                      # 设置帧指针
	
	li	t1, 0                           # 加载立即数 0
	sw	t1, -12(s0)                     # store 0 到 %1 (%1 在 -12(s0))
	
	li	t1, 1                           # 加载立即数 1
	sw	t1, -8(s0)                      # store 1 到 %2 (%2 在 -8(s0))
	
	lw	t2, -8(s0)                      # load %2 到 t2 (%3 = t2)
	addi	t3, t2, 2                       # %4 = %3 + 2 (t3 = t2 + 2)
	sw	t3, -8(s0)                      # store %4 回 %2
	
	lw	t4, -8(s0)                      # load %2 到 t4 (%5 = t4)
	mv	a0, t4                          # 将返回值移到 a0
	
	lw	ra, 12(sp)                      # 恢复返回地址
	lw	s0, 8(sp)                       # 恢复帧指针
	addi	sp, sp, 16                      # 回收栈空间
	ret                                     # 返回
                                        # -- End function
```

**数据流追踪**：

| IR 指令 | 汇编指令 | 说明 |
|---------|----------|------|
| `%1 = alloca i32` | - | %1 分配到 -12(s0) |
| `store i32 0, ptr %1` | `li t1, 0`<br>`sw t1, -12(s0)` | 0 → t1 → 内存[%1] |
| `%2 = alloca i32` | - | %2 分配到 -8(s0) |
| `store i32 1, ptr %2` | `li t1, 1`<br>`sw t1, -8(s0)` | 1 → t1 → 内存[%2] |
| `%3 = load i32, ptr %2` | `lw t2, -8(s0)` | 内存[%2] → t2 (%3) |
| `%4 = add nsw i32 %3, 2` | `addi t3, t2, 2` | t2 + 2 → t3 (%4) |
| `store i32 %4, ptr %2` | `sw t3, -8(s0)` | t3 → 内存[%2] |
| `%5 = load i32, ptr %2` | `lw t4, -8(s0)` | 内存[%2] → t4 (%5) |
| `ret i32 %5` | `mv a0, t4` | t4 → a0（返回值） |

---

## 完整示例：端到端数据流

让我们用一个稍微复杂的例子来展示完整的编译流程：

### 输入：C 源代码

```c
int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 10;
    int z = add(x, y);
    return z;
}
```

### 阶段 1：词法分析

```
Tokens:
INT ID(add) LPAREN INT ID(a) COMMA INT ID(b) RPAREN LBRACE
RETURN ID(a) PLUS ID(b) SEMI RBRACE
INT ID(main) LPAREN RPAREN LBRACE
INT ID(x) ASSIGN NUMBER(5) SEMI
INT ID(y) ASSIGN NUMBER(10) SEMI
INT ID(z) ASSIGN ID(add) LPAREN ID(x) COMMA ID(y) RPAREN SEMI
RETURN ID(z) SEMI RBRACE END
```

### 阶段 2：语法分析（AST）

```
CompUnit {
  FuncDef {
    retType: "int"
    name: "add"
    params: [Param("a"), Param("b")]
    body: BlockStmt {
      ReturnStmt {
        expr: BinaryExpr {
          op: "+"
          lhs: IdentifierExpr("a")
          rhs: IdentifierExpr("b")
        }
      }
    }
  }
  
  FuncDef {
    retType: "int"
    name: "main"
    params: []
    body: BlockStmt {
      DeclStmt { name: "x", expr: NumberExpr(5) }
      DeclStmt { name: "y", expr: NumberExpr(10) }
      DeclStmt {
        name: "z"
        expr: CallExpr {
          callee: "add"
          args: [IdentifierExpr("x"), IdentifierExpr("y")]
        }
      }
      ReturnStmt { expr: IdentifierExpr("z") }
    }
  }
}
```

### 阶段 3：LLVM IR 生成

```llvm
; ModuleID = 'toyc'
source_filename = "toyc"
target triple = "riscv32-unknown-elf"

define dso_local i32 @add(i32 noundef %0, i32 noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  store i32 %0, ptr %3, align 4    ; 参数 a
  store i32 %1, ptr %4, align 4    ; 参数 b
  %5 = load i32, ptr %3, align 4   ; 加载 a
  %6 = load i32, ptr %4, align 4   ; 加载 b
  %7 = add nsw i32 %5, %6          ; a + b
  ret i32 %7
}

define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4         ; main 返回值
  store i32 0, ptr %1, align 4
  
  %2 = alloca i32, align 4         ; 变量 x
  store i32 5, ptr %2, align 4
  
  %3 = alloca i32, align 4         ; 变量 y
  store i32 10, ptr %3, align 4
  
  %4 = alloca i32, align 4         ; 变量 z
  %5 = load i32, ptr %2, align 4   ; 加载 x
  %6 = load i32, ptr %3, align 4   ; 加载 y
  %7 = call i32 @add(i32 %5, i32 %6)  ; 调用 add(x, y)
  store i32 %7, ptr %4, align 4    ; 存储到 z
  
  %8 = load i32, ptr %4, align 4   ; 加载 z
  ret i32 %8                        ; 返回 z
}
```

### 阶段 4：RISC-V 汇编生成

```riscv
	.text
	.globl	main

add:                                    # @add
# %bb.0:
	addi	sp, sp, -16
	sw	ra, 12(sp)
	sw	s0, 8(sp)
	addi	s0, sp, 16
	
	sw	a0, -8(s0)                      # 保存参数 a
	sw	a1, -12(s0)                     # 保存参数 b
	
	lw	t1, -8(s0)                      # 加载 a
	lw	t2, -12(s0)                     # 加载 b
	add	t3, t1, t2                      # a + b
	mv	a0, t3                          # 返回值
	
	lw	ra, 12(sp)
	lw	s0, 8(sp)
	addi	sp, sp, 16
	ret
                                        # -- End function

main:                                   # @main
# %bb.0:
	addi	sp, sp, -32
	sw	ra, 28(sp)
	sw	s0, 24(sp)
	addi	s0, sp, 32
	
	li	t1, 0
	sw	t1, -12(s0)                     # main 返回值
	
	li	t1, 5
	sw	t1, -16(s0)                     # x = 5
	
	li	t1, 10
	sw	t1, -20(s0)                     # y = 10
	
	lw	a0, -16(s0)                     # 加载 x 到 a0
	lw	a1, -20(s0)                     # 加载 y 到 a1
	call	add                             # 调用 add
	sw	a0, -24(s0)                     # 保存返回值到 z
	
	lw	t1, -24(s0)                     # 加载 z
	mv	a0, t1                          # 返回值
	
	lw	ra, 28(sp)
	lw	s0, 24(sp)
	addi	sp, sp, 32
	ret
                                        # -- End function
```

---

## 关键技术点总结

### 1. 作用域管理

使用作用域栈管理变量可见性：

```cpp
vector<map<string, string>> scopeStack;  // 每层作用域的符号表

void enterScope() {
    scopeStack.push_back(map<string, string>());
}

void exitScope() {
    scopeStack.pop_back();
}

string findVariable(const string &name) {
    // 从内层到外层查找
    for (int i = scopeStack.size() - 1; i >= 0; --i) {
        if (scopeStack[i].count(name))
            return scopeStack[i][name];
    }
    return "";  // 未找到
}
```

### 2. 控制流处理

**if-else 语句**：
```
        cond
         ↓
      br cond, then, else
       ↙       ↘
    then        else
       ↓         ↓
      br end   br end
        ↘     ↙
         end
```

**while 循环**：
```
      br cond
         ↓
       cond ←────┐
         ↓       │
    br cond, body, end
         ↓       │
       body      │
         ↓       │
      br cond ───┘
         ↓
        end
```

### 3. 短路求值

逻辑运算符 `&&` 和 `||` 需要短路求值：

```cpp
// a && b 的实现
string generateLogicalAnd(ASTPtr lhs, ASTPtr rhs) {
    string lhsVal = generateExpr(lhs);
    string rhsLabel = newLabel("and_rhs");
    string endLabel = newLabel("and_end");
    string result = newTemp();
    
    // 分配结果变量
    addInstruction(result + " = alloca i1");
    
    // 如果 lhs 为假，直接跳到结束
    addInstruction("br i1 " + lhsVal + ", label %" + rhsLabel + 
                  ", label %" + endLabel);
    
    // 计算右侧
    addInstruction(rhsLabel + ":");
    string rhsVal = generateExpr(rhs);
    addInstruction("store i1 " + rhsVal + ", ptr " + result);
    addInstruction("br label %" + endLabel);
    
    // 结束
    addInstruction(endLabel + ":");
    string finalResult = newTemp();
    addInstruction(finalResult + " = load i1, ptr " + result);
    return finalResult;
}
```

### 4. 寄存器分配优化

**活跃区间分析**：
- 定义点（Def）：变量被赋值的位置
- 使用点（Use）：变量被读取的位置
- 活跃区间：从定义点到最后使用点的范围

**线性扫描算法**：
1. 按活跃区间起始点排序
2. 遍历每个区间：
   - 释放已结束的区间占用的寄存器
   - 为当前区间分配空闲寄存器
   - 如果无空闲寄存器，溢出到栈

### 5. 函数调用约定（RISC-V）

**参数传递**：
- 前 8 个参数：a0-a7
- 更多参数：通过栈传递

**返回值**：
- 整数返回值：a0
- void 函数：无返回值

**寄存器保存**：
- Caller-saved：调用者保存（a0-a7, t0-t6）
- Callee-saved：被调用者保存（s0-s11, ra）

---

## 编译器使用示例

### 基本用法

```bash
# 编译 C 文件到汇编
./toyc test.c --mode asm

# 输出 AST
./toyc test.c --mode ast

# 输出 LLVM IR
./toyc test.c --mode ir

# 输出所有阶段
./toyc test.c --mode all

# 输出到文件
./toyc test.c --mode asm --output test.s

# 从标准输入读取
cat test.c | ./toyc --mode asm
```

### 完整编译流程

```bash
# 1. C 源码 → 汇编
./toyc test.c --mode asm --output test.s

# 2. 汇编 → 目标文件（需要 RISC-V 工具链）
riscv32-unknown-elf-as test.s -o test.o

# 3. 链接生成可执行文件
riscv32-unknown-elf-gcc test.o crt0.o -o test.elf

# 4. 在 RISC-V 模拟器中运行
spike pk test.elf
```

---

## 附录：数据结构速查

### Token 类型
```cpp
ID, NUMBER,                              // 字面量
INT, VOID, IF, ELSE, WHILE, RETURN,      // 关键字
PLUS, MINUS, TIMES, DIV, MOD,            // 算术
GT, LT, GE, LE, EQ, NE,                  // 比较
OR, AND, NOT,                             // 逻辑
ASSIGN,                                   // 赋值
LPAREN, RPAREN, LBRACE, RBRACE, SEMI, COMMA  // 分隔符
```

### AST 节点类型
```cpp
// 表达式
NumberExpr, IdentifierExpr, BinaryExpr, UnaryExpr, CallExpr

// 语句
DeclStmt, AssignStmt, IfStmt, WhileStmt, ReturnStmt,
BreakStmt, ContinueStmt, BlockStmt

// 顶层
FuncDef
```

### LLVM IR 指令
```llvm
alloca     ; 分配栈空间
store      ; 存储到内存
load       ; 从内存加载
add/sub/mul/sdiv/srem  ; 算术运算
icmp       ; 比较
br         ; 分支跳转
call       ; 函数调用
ret        ; 返回
```

### RISC-V 指令
```riscv
li         ; 加载立即数
mv         ; 移动寄存器
lw/sw      ; 加载/存储字
add/sub/mul/div  ; 算术运算
addi       ; 立即数加法
slt        ; 小于比较
beq/bne/blt/bge  ; 条件分支
j          ; 无条件跳转
call/ret   ; 函数调用/返回
```

---

## 总结

ToyC 编译器的完整流程：

1. **词法分析**：源代码 → Token 流
   - 识别关键字、标识符、数字、运算符
   - 跳过空白和注释

2. **语法分析**：Token 流 → AST
   - 递归下降解析
   - 构建抽象语法树

3. **IR 生成**：AST → LLVM IR
   - SSA 形式
   - 显式内存操作（alloca/load/store）
   - 控制流图（基本块 + 分支）

4. **汇编生成**：LLVM IR → RISC-V 汇编
   - 指令选择
   - 寄存器分配（线性扫描）
   - 栈帧管理

每个阶段都有明确的输入输出，数据在各阶段之间逐步转换和细化，最终生成可执行的机器代码。
