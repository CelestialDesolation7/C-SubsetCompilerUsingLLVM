# 寄存器分配器与代码生成器的集成详解

## 一、寄存器分配器的封装方式

### 1.1 核心类结构

```cpp
// 寄存器分配器的核心类
class LinearScanAllocator {
private:
    AllocationResult result;        // 分配结果（内部管理）
    const RegInfo& regInfo;         // 寄存器信息（只读）
    std::vector<LiveInterval*> active;  // 当前活跃区间
    std::set<int, PhysRegComparator> freePhysRegs;  // 空闲物理寄存器池
    
public:
    // 主分配接口
    AllocationResult allocate(FunctionIR& F);
    
    // 查询接口
    const AllocationResult& getAllocationResult() const { return result; }
    std::set<int> getUsedPhysRegs() const;
    std::set<int> getCalleeSavedRegs() const;
    
    // 运行时辅助
    int allocateSpillTempReg();  // 分配溢出临时寄存器
};
```

**封装特点**：
1. **结果内部管理**：`AllocationResult`由分配器持有，外部通过`const&`访问
2. **只读寄存器信息**：`RegInfo`作为构造参数传入，分配器不修改
3. **状态封装**：活跃区间、空闲寄存器等状态完全私有

---

### 1.2 分配结果数据结构

```cpp
struct AllocationResult {
    std::unordered_map<int, int> vregToPhys;      // 虚拟寄存器 → 物理寄存器
    std::unordered_map<int, int> vregToStack;     // 虚拟寄存器 → 栈偏移
    std::unordered_map<int, int> paramVregToLocation;  // 参数虚拟寄存器 → 位置
    
    // 瞬时位置信息（在某条指令处，虚拟寄存器的实际位置）
    std::unordered_map<int, std::unordered_map<int, Location>> instrVregLocations;
};

struct Location {
    enum Type { REG, STACK, BOTH } type;
    int physReg;      // 物理寄存器ID（type=REG/BOTH时有效）
    int stackOffset;  // 栈偏移（type=STACK/BOTH时有效）
};
```

**关键信息**：
- `vregToPhys`：最终分配的物理寄存器（如果有）
- `vregToStack`：溢出到栈的位置（如果有）
- `paramVregToLocation`：参数的特殊处理（前8个在a0-a7，其余在栈）
- `instrVregLocations`：**精确的瞬时位置**（某条指令使用时，值在哪里）

---

## 二、分配器与生成器的连接方式

### 2.1 生成器中的分配器管理

```cpp
class RISCVGenerator {
private:
    // 寄存器信息（全局共享）
    const ra_ls::RegInfo regInfo;
    
    // 每个函数对应一个独立的分配器实例
    std::map<std::string, std::unique_ptr<ra_ls::LinearScanAllocator>> functionAllocators;
    
    // 当前处理的函数名
    std::string currentFunction;
};
```

**关键设计**：
1. **一个函数一个分配器**：每个函数有独立的`LinearScanAllocator`实例
2. **提前全部计算**：在生成任何汇编之前，预计算所有函数的分配结果
3. **按需查询**：生成指令时，通过函数名查找对应的分配器

---

### 2.2 连接流程图

```
[RISCVGenerator::generateModule]
        ↓
    precomputeAllFunctionAllocations()  ← 预计算阶段
        ↓
    [解析所有函数定义]
        ↓
    对每个函数：
        ├─ 创建 LinearScanAllocator 实例
        ├─ parseFunctionFromLLVMIR() → FunctionIR
        ├─ allocator->allocate(FunctionIR) → AllocationResult
        └─ 存储到 functionAllocators[funcName]
        ↓
    [开始生成汇编代码]  ← 代码生成阶段
        ↓
    对每条指令：
        ├─ parseOperand() / parseRegUse() / parseRegDef()
        ├─ 查询 functionAllocators[currentFunction]
        ├─ 获取 AllocationResult
        └─ 生成对应的物理寄存器/栈访问指令
```

---

## 三、预计算阶段详解

### 3.1 入口函数

```cpp
void RISCVGenerator::precomputeAllFunctionAllocations(const std::string &llvmIR)
{
    std::istringstream iss(llvmIR);
    std::string line;

    while (std::getline(iss, line))
    {
        // 查找函数定义
        if (line.find("define") != std::string::npos)
        {
            std::regex funcRegex(REGEX_FUNCTION_DEF);
            std::smatch match;
            if (std::regex_search(line, match, funcRegex))
            {
                std::string funcName = match[2].str();

                // 1. 为每个函数创建独立的分配器实例
                auto allocator = std::make_unique<ra_ls::LinearScanAllocator>(regInfo);
                
                // 2. 解析函数的LLVM IR
                auto functionIR = ra_ls::parseFunctionFromLLVMIR(llvmIR, funcName);

                if (functionIR)
                {
                    // 3. 执行寄存器分配
                    allocator->allocate(*functionIR);

                    // 4. 存储分配器实例（包含AllocationResult）
                    functionAllocators[funcName] = std::move(allocator);
                }
            }
        }
    }
}
```

**关键点**：
1. **第一次扫描IR**：只寻找函数定义
2. **每个函数独立处理**：避免相互干扰
3. **完整的寄存器分配**：包括活跃性分析、区间构建、线性扫描
4. **结果持久化**：分配器对象存储在`functionAllocators`中

---

### 3.2 IR解析到分配的完整流程

```cpp
// ra_ls命名空间中的辅助函数
std::unique_ptr<FunctionIR> parseFunctionFromLLVMIR(
    const std::string &llvmIR, 
    const std::string &funcName)
{
    auto F = std::make_unique<FunctionIR>();
    F->name = funcName;
    
    // 1. 解析基本块和指令
    parseBasicBlocks(llvmIR, funcName, *F);
    
    // 2. 构建控制流图
    F->buildControlFlowGraph();
    
    return F;
}
```

```cpp
// LinearScanAllocator::allocate 内部流程
AllocationResult LinearScanAllocator::allocate(FunctionIR &F)
{
    // 1. 处理参数映射（前8个→a0-a7，其余→栈）
    processParameters(F.parameters);

    // 2. 活跃性分析
    LivenessAnalysis liveness;
    liveness.run(F);  // 包含：use/def计算 + RPO + 迭代不动点

    // 3. 指令线性化编号
    assignInstrPositions(F);

    // 4. 构建活跃区间
    LiveIntervalBuilder builder(F, liveness, intervalSplittingEnabled);
    auto intervals = builder.build();

    // 5. 执行线性扫描分配
    result = runLinearScan(intervals);

    // 6. 计算瞬时位置
    computeInstrVregLocations(F);

    return result;
}
```

**输出**：`functionAllocators[funcName]`持有完整的分配结果

---

## 四、代码生成阶段详解

### 4.1 主生成流程

```cpp
std::string RISCVGenerator::generateModule(const std::string &llvmIR)
{
    std::string assembly = "";

    // ===== 阶段1：预计算所有函数的寄存器分配 =====
    precomputeAllFunctionAllocations(llvmIR);

    // ===== 阶段2：添加汇编文件头 =====
    assembly += "	.text\n";
    assembly += "	.globl	main                            # -- Begin function main\n";

    // ===== 阶段3：第二次扫描IR，生成汇编 =====
    std::istringstream iss(llvmIR);
    std::string line;

    while (std::getline(iss, line))
    {
        // 跳过注释和空行
        if (line.empty() || line[0] == ';' || ...) continue;

        // 3.1 解析函数定义
        if (line.find("define") != std::string::npos)
        {
            // 提取函数名
            std::string funcName = extractFunctionName(line);
            
            // 重置函数状态
            resetFunctionState();
            currentFunction = funcName;  // 设置当前函数名（关键！）
            
            // 生成函数序言
            generateFunctionDef(funcName, retType);
        }
        
        // 3.2 解析标签
        else if (line.find(":") != std::string::npos)
        {
            generateLabel(label);
        }
        
        // 3.3 解析指令
        else if (line[0] == ' ')
        {
            parseLLVMInstruction(line);  // 核心指令解析
        }
        
        // 3.4 函数结束
        else if (line == "}")
        {
            generateFunctionEnd();
            calculateStackFrame();
            assembly += currentInstructions;  // 输出汇编
        }
    }

    return assembly;
}
```

**关键点**：
- **第二次扫描**：按顺序生成汇编，不再构建CFG
- **currentFunction**：标记当前处理的函数，用于查询分配结果
- **currentInstructions**：缓冲区，存储当前函数的所有汇编指令

---

### 4.2 指令解析流程

```cpp
void RISCVGenerator::parseLLVMInstruction(const std::string &line)
{
    preciseInstructionCount++;  // 指令计数（用于调试）

    // 4.2.1 alloca指令
    if (line.find("alloca") != std::string::npos)
    {
        generateAlloca(var, type);
    }
    
    // 4.2.2 store指令
    else if (line.find("store") != std::string::npos)
    {
        // store i32 %0, ptr %1
        std::string value = extractValue(line);  // "%0"
        std::string ptr = extractPtr(line);      // "%1"
        
        generateStore(value, ptr);
    }
    
    // 4.2.3 load指令
    else if (line.find("load") != std::string::npos)
    {
        // %2 = load i32, ptr %1
        std::string result = extractResult(line);  // "%2"
        std::string ptr = extractPtr(line);        // "%1"
        
        std::string resultReg = parseRegDef(result);  // 查询分配结果
        int offset = getVariableOffset(ptr);
        addInstruction("	lw	" + resultReg + ", " + std::to_string(offset) + "(s0)");
    }
    
    // 4.2.4 算术运算
    else if (line.find("add") != std::string::npos || ...)
    {
        // %3 = add nsw i32 %1, %2
        std::string result = extractResult(line);  // "%3"
        std::string lhs = extractLHS(line);        // "%1"
        std::string rhs = extractRHS(line);        // "%2"
        
        std::string resultReg = parseRegDef(result);  // 查询%3的分配
        std::string lhsReg = parseOperand(lhs);       // 查询%1的位置
        std::string rhsReg = parseOperand(rhs);       // 查询%2的位置
        
        addInstruction("	add	" + resultReg + ", " + lhsReg + ", " + rhsReg);
    }
    
    // ... 其他指令类似
}
```

**流程模式**：
```
解析IR指令 → 提取操作数 → parseOperand/parseRegDef → 查询分配结果 → 生成汇编
```

---

### 4.3 核心查询接口

#### 4.3.1 parseOperand（处理使用）

```cpp
std::string RISCVGenerator::parseOperand(const std::string &operand)
{
    if (operand[0] == '%')
    {
        // 虚拟寄存器 → 调用parseRegUse
        return parseRegUse(operand);
    }
    else if (operand.find_first_not_of("0123456789-") == std::string::npos)
    {
        // 立即数 → 使用临时寄存器加载
        int imm = parseImmediate(operand);
        
        auto allocator = functionAllocators[currentFunction].get();
        int tempReg = allocator->allocateSpillTempReg();  // t5或t6
        std::string temp = regInfo.getReg(tempReg).name;
        
        addInstruction("	li	" + temp + ", " + std::to_string(imm));
        return temp;
    }
    // ... 处理其他格式
}
```

**功能**：统一处理各种操作数格式（虚拟寄存器、立即数、类型标注等）

---

#### 4.3.2 parseRegUse（虚拟寄存器使用）

```cpp
std::string RISCVGenerator::parseRegUse(const std::string &vreg)
{
    // 提取虚拟寄存器编号
    int vregId = std::stoi(vreg.substr(1));  // "%3" → 3

    // 查询当前函数的分配器
    auto it = functionAllocators.find(currentFunction);
    if (it != functionAllocators.end())
    {
        const auto &result = it->second->getAllocationResult();

        // 1. 检查是否是参数
        auto paramIt = result.paramVregToLocation.find(vregId);
        if (paramIt != result.paramVregToLocation.end())
        {
            if (paramIt->second >= 0)
                return regInfo.getReg(paramIt->second).name;  // a0-a7
            else
            {
                // 参数在栈上 → 需要加载
                int tempReg = it->second->allocateSpillTempReg();
                std::string tempRegName = regInfo.getReg(tempReg).name;
                int stackOffset = paramIt->second;
                addInstruction("	lw	" + tempRegName + ", " + std::to_string(stackOffset) + "(sp)");
                return tempRegName;
            }
        }

        // 2. 检查是否分配到物理寄存器
        auto physIt = result.vregToPhys.find(vregId);
        if (physIt != result.vregToPhys.end() && physIt->second != -1)
        {
            return regInfo.getReg(physIt->second).name;  // 直接返回物理寄存器
        }

        // 3. 检查是否溢出到栈
        auto stackIt = result.vregToStack.find(vregId);
        if (stackIt != result.vregToStack.end())
        {
            // 从栈加载到临时寄存器
            int tempReg = it->second->allocateSpillTempReg();
            std::string tempRegName = regInfo.getReg(tempReg).name;
            int stackOffset = stackIt->second;
            addInstruction("	lw	" + tempRegName + ", " + std::to_string(stackOffset) + "(sp)");
            return tempRegName;
        }
    }

    throw std::runtime_error("parseRegUse: vreg not found");
}
```

**查询优先级**：
1. 参数映射（特殊处理）
2. 物理寄存器分配
3. 栈溢出（需要额外的load指令）

---

#### 4.3.3 parseRegDef（虚拟寄存器定义）

```cpp
std::string RISCVGenerator::parseRegDef(const std::string &vreg)
{
    int vregId = std::stoi(vreg.substr(1));

    auto it = functionAllocators.find(currentFunction);
    if (it != functionAllocators.end())
    {
        const auto &result = it->second->getAllocationResult();

        // 1. 检查是否分配到物理寄存器
        auto physIt = result.vregToPhys.find(vregId);
        if (physIt != result.vregToPhys.end() && physIt->second != -1)
        {
            return regInfo.getReg(physIt->second).name;  // 直接写入物理寄存器
        }

        // 2. 检查是否需要溢出到栈
        auto stackIt = result.vregToStack.find(vregId);
        if (stackIt != result.vregToStack.end())
        {
            // 先写入临时寄存器，调用者需要再存储到栈
            int tempReg = it->second->allocateSpillTempReg();
            std::string tempRegName = regInfo.getReg(tempReg).name;
            
            // 注意：这里只返回临时寄存器名
            // 调用者需要手动生成 sw 指令存储到栈
            return tempRegName;
        }
    }

    throw std::runtime_error("parseRegDef: vreg not found");
}
```

**关键差异**：
- `parseRegUse`：可能生成`lw`指令（从栈加载）
- `parseRegDef`：只返回目标寄存器，不自动生成`sw`指令

---

## 五、完整示例

### 5.1 LLVM IR输入

```llvm
define i32 @foo(i32 %0, i32 %1) {
entry:
  %2 = add nsw i32 %0, %1
  %3 = mul nsw i32 %2, 3
  ret i32 %3
}
```

---

### 5.2 预计算阶段

```cpp
precomputeAllFunctionAllocations(llvmIR)
    ↓
parseFunctionFromLLVMIR(llvmIR, "foo")
    ↓
FunctionIR {
    name: "foo",
    parameters: [0, 1],  // %0, %1
    blocks: [
        BasicBlock {
            insts: [
                Instruction{idx:0, text:"%2 = add..."},
                Instruction{idx:1, text:"%3 = mul..."},
                Instruction{idx:2, text:"ret..."}
            ]
        }
    ]
}
    ↓
allocator->allocate(FunctionIR)
    ↓
processParameters([0, 1])
    result.paramVregToLocation[0] = 10  // a0
    result.paramVregToLocation[1] = 11  // a1
    ↓
LivenessAnalysis::run()
    block->useSet = {0, 1}
    block->defSet = {2, 3}
    block->liveIn = {0, 1}
    block->liveOut = {3}
    ↓
assignInstrPositions()
    inst[0]->idx = 0  // pos: def=0, use=1
    inst[1]->idx = 1  // pos: def=2, use=3
    inst[2]->idx = 2  // pos: def=4, use=5
    ↓
buildIntervals()
    intervals[0] = [0, 1]  // %0活跃在指令0的use点
    intervals[1] = [0, 1]  // %1活跃在指令0的use点
    intervals[2] = [0, 3]  // %2从指令0的def点到指令1的use点
    intervals[3] = [2, 5]  // %3从指令1的def点到指令2的use点
    ↓
runLinearScan()
    intervals[0]: 参数，已分配到a0
    intervals[1]: 参数，已分配到a1
    intervals[2]: 分配到t2（free池中取出）
    intervals[3]: 分配到a0（%0已过期，a0可复用）
    ↓
result = AllocationResult {
    paramVregToLocation: {0→10(a0), 1→11(a1)},
    vregToPhys: {2→7(t2), 3→10(a0)},
    vregToStack: {}
}
    ↓
functionAllocators["foo"] = allocator（持有result）
```

---

### 5.3 代码生成阶段

```cpp
generateModule(llvmIR)
    ↓
// 第二次扫描
currentFunction = "foo"
    ↓
// 解析 "%2 = add nsw i32 %0, %1"
parseLLVMInstruction(line)
    ↓
result = "%2"
lhs = "%0"
rhs = "%1"
    ↓
resultReg = parseRegDef("%2")
    → 查询 functionAllocators["foo"]->result.vregToPhys[2]
    → 返回 "t2"
    ↓
lhsReg = parseOperand("%0")
    → parseRegUse("%0")
    → 查询 paramVregToLocation[0]
    → 返回 "a0"
    ↓
rhsReg = parseOperand("%1")
    → parseRegUse("%1")
    → 查询 paramVregToLocation[1]
    → 返回 "a1"
    ↓
addInstruction("	add	t2, a0, a1")
```

```cpp
// 解析 "%3 = mul nsw i32 %2, 3"
parseLLVMInstruction(line)
    ↓
result = "%3"
lhs = "%2"
rhs = "3"
    ↓
resultReg = parseRegDef("%3")
    → 查询 vregToPhys[3]
    → 返回 "a0"
    ↓
lhsReg = parseOperand("%2")
    → parseRegUse("%2")
    → 查询 vregToPhys[2]
    → 返回 "t2"
    ↓
rhsReg = parseOperand("3")
    → 检测到立即数
    → 分配临时寄存器 t5 = allocateSpillTempReg()
    → addInstruction("	li	t5, 3")
    → 返回 "t5"
    ↓
addInstruction("	mul	a0, t2, t5")
```

```cpp
// 解析 "ret i32 %3"
generateReturn("%3")
    ↓
valueReg = parseOperand("%3")
    → parseRegUse("%3")
    → 查询 vregToPhys[3]
    → 返回 "a0"
    ↓
// a0已经是返回值寄存器，无需mv
addInstruction("	mv	a0, a0")  // 实际代码会优化掉
```

---

### 5.4 最终汇编输出

```assembly
foo:
# %bb.0:
    addi	sp, sp, -16
    sw	ra, 12(sp)
    sw	s0, 8(sp)
    addi	s0, sp, 16
    add	t2, a0, a1        # %2 = add %0, %1
    li	t5, 3
    mul	a0, t2, t5        # %3 = mul %2, 3
    lw	ra, 12(sp)
    lw	s0, 8(sp)
    addi	sp, sp, 16
    ret
```

---

## 六、关键设计模式总结

### 6.1 分离关注点

```
寄存器分配器：
- 关注：虚拟寄存器 → 物理位置
- 输入：FunctionIR（CFG + 指令）
- 输出：AllocationResult

代码生成器：
- 关注：LLVM IR → RISC-V汇编
- 依赖：AllocationResult（查询分配结果）
- 输出：汇编字符串
```

---

### 6.2 两阶段处理

```
阶段1：预计算（第一次扫描）
  - 构建所有函数的FunctionIR
  - 执行寄存器分配
  - 存储AllocationResult

阶段2：代码生成（第二次扫描）
  - 按顺序解析IR
  - 查询分配结果
  - 生成汇编指令
```

---

### 6.3 查询驱动

```
生成器不关心分配算法：
  parseOperand(vreg)
      ↓
  查询 functionAllocators[currentFunction]
      ↓
  if (in paramVregToLocation)   → 返回 a0-a7 或栈参数
  elif (in vregToPhys)          → 返回 物理寄存器
  elif (in vregToStack)         → 生成 lw + 返回临时寄存器
```

---

### 6.4 状态隔离

```
每个函数独立：
- 独立的 LinearScanAllocator 实例
- 独立的 AllocationResult
- 通过 currentFunction 切换上下文
```

---

## 七、完整调用栈

```
main()
  ↓
generateRISCVAssembly(llvmIR)
  ↓
RISCVGenerator::generateModule(llvmIR)
  ├─ precomputeAllFunctionAllocations(llvmIR)  ← 阶段1：分配
  │  └─ [对每个函数]
  │     ├─ parseFunctionFromLLVMIR(llvmIR, funcName)
  │     │  ├─ parseBasicBlocks()
  │     │  └─ buildControlFlowGraph()
  │     ├─ allocator->allocate(FunctionIR)
  │     │  ├─ processParameters()
  │     │  ├─ LivenessAnalysis::run()
  │     │  ├─ assignInstrPositions()
  │     │  ├─ LiveIntervalBuilder::build()
  │     │  ├─ runLinearScan()
  │     │  └─ computeInstrVregLocations()
  │     └─ functionAllocators[funcName] = allocator
  │
  └─ [第二次扫描IR]  ← 阶段2：生成
     ├─ generateFunctionDef()
     ├─ [对每条指令]
     │  └─ parseLLVMInstruction(line)
     │     ├─ parseOperand() / parseRegUse() / parseRegDef()
     │     │  └─ 查询 functionAllocators[currentFunction]->result
     │     └─ addInstruction(assembly)
     └─ generateFunctionEnd()
```

---

这就是你的寄存器分配器和代码生成器的完整集成方式！核心思想是**两阶段处理**和**查询驱动**，非常清晰和模块化。