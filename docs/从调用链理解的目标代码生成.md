# 从调用链理解的目标代码生成

## 总览：入口函数调用栈

```
RISCVCodeGen::generate(const ir::Module &module)        // 主入口
├─ precomputeAllocations(module)                         // 0. 为每个函数执行寄存器分配
│  └─ LinearScanAllocator::allocate(F)                   //    (详见寄存器分配文档)
│
└─ for each function:
   generateFunction(func)                                // 1. 生成单个函数
   ├─ resetFunctionState()                               //    1.0 重置状态
   ├─ 预计算 frameOverhead_ / callSaveSize_ / callArgAreaSize_
   ├─ emit: .globl funcName                              //    1.1 ELF 指令头
   ├─ emit: funcName:                                    //    1.2 入口标签
   ├─ emit: __PROLOGUE_PLACEHOLDER__                     //    1.3 序言占位符
   ├─ for each basic block:
   │  ├─ emit: .blockLabel:                              //    1.4 基本块标签
   │  └─ for each instruction:
   │     generateInst(inst)                               //    1.5 指令翻译
   │     ├─ genAlloca(inst)                               //        alloca（不生成汇编）
   │     ├─ genStore(inst)                                //        store
   │     ├─ genLoad(inst)                                 //        load
   │     ├─ genBinOp(inst)                                //        add/sub/mul/sdiv/srem
   │     ├─ genICmp(inst)                                 //        icmp
   │     ├─ genCondBr(inst)                               //        条件分支
   │     ├─ genBr(inst)                                   //        无条件分支
   │     ├─ genCall(inst)                                 //        函数调用
   │     └─ genRet(inst)                                  //        返回 / void 返回
   │
   ├─ calculateStackFrame()                               //    1.6 计算栈帧大小
   └─ updateStackFramePlaceholders()                      //    1.7 回填序言/尾声
```

所有代码位于 [riscv_codegen.h](../src/include/riscv_codegen.h) 和 [riscv_codegen.cpp](../src/riscv_codegen.cpp) 中，命名空间 `toyc`。

---

## 阶段 0：预计算分配

### precomputeAllocations()

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::precomputeAllocations(const ir::Module &module) {
    for (auto &func : module.functions) {
        auto allocator = std::make_unique<LinearScanAllocator>();
        allocator->allocate(*func);
        funcAllocators_[func->name] = std::move(allocator);
    }
}
```

为模块中的每个函数创建独立的 `LinearScanAllocator`，执行完整的寄存器分配流程（详见[寄存器分配流程文档](./从调用链理解的寄存器分配流程.md)），结果存储在 `funcAllocators_` 映射中。

**设计原则**：分配与代码生成分离 — 先为所有函数完成分配，再逐一生成代码。这样代码生成阶段只需查询 `AllocationResult`，不需要考虑分配逻辑。

---

## 阶段 1：函数代码生成

### generateFunction()

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::generateFunction(Function &func) {
    resetFunctionState();
    currentFunction_ = func.name;
    isMainFunction_ = (func.name == "main");

    // 预计算帧开销（ra + s0 + callee-saved），供 alloca 偏移使用
    auto &alloc = funcAllocators_[currentFunction_]->getAllocationResult();
    int calleeSavedCount = static_cast<int>(alloc.calleeSavedRegs.size());
    frameOverhead_ = 8 + calleeSavedCount * 4;

    // 预计算函数调用时 caller-saved 保存区大小
    {
        std::set<int> csRegs;
        for (auto &[vreg, physReg] : alloc.vregToPhys) {
            if (regInfo_.isCallerSaved(physReg) &&
                !funcAllocators_[currentFunction_]->isSpillTempReg(physReg))
                csRegs.insert(physReg);
        }
        callSaveSize_ = static_cast<int>(csRegs.size()) * 4;
    }

    // 预计算出栈参数区大小（超过 8 个参数的调用需要栈传参）
    {
        int maxStackArgs = 0;
        for (auto &bb : func.blocks) {
            for (auto &inst : bb->insts) {
                if (inst->opcode == Opcode::Call) {
                    int extraArgs = std::max(0, static_cast<int>(inst->ops.size()) - 8);
                    maxStackArgs = std::max(maxStackArgs, extraArgs);
                }
            }
        }
        callArgAreaSize_ = maxStackArgs * 4;
    }

    output_ += "    .globl " + func.name + "\n";
    output_ += func.name + ":\n";
    std::string prologuePlaceholder = "__PROLOGUE_PLACEHOLDER_" + func.name + "__";
    output_ += prologuePlaceholder + "\n";

    // 遍历所有基本块
    for (size_t bi = 0; bi < func.blocks.size(); ++bi) {
        auto &bb = func.blocks[bi];
        if (bi > 0)
            output_ += "." + func.name + "_" + bb->name + ":\n";
        for (auto &inst : bb->insts)
            generateInst(*inst);
    }

    // 计算栈帧并替换占位符
    calculateStackFrame();
    updateStackFramePlaceholders();

    output_ += "    .size " + func.name + ", .-" + func.name + "\n\n";
}
```

**关键设计 — 三个预计算步骤**：

在遍历指令之前，`generateFunction` 预计算三个帧相关值：

1. **`frameOverhead_`**（ra + s0 + callee-saved 寄存器）— 供 `getAllocaOffset()` 在 alloca 偏移中跳过这些区域
2. **`callSaveSize_`**（caller-saved 保存区大小）— 供 `genCall` 保存/恢复 caller-saved 寄存器，也影响溢出槽的 sp 偏移计算
3. **`callArgAreaSize_`**（出栈参数区大小）— 扫描所有 `call` 指令，找到最大的超出 8 个参数的个数，预留在帧底部

**占位符机制**：

生成函数体时，序言的栈帧大小未知（因为 alloca 和 spill slot 的总大小只有在遍历完所有指令后才能确定）。解决方案是：
1. 先输出 `__PROLOGUE_PLACEHOLDER_funcName__`
2. 遍历完所有指令后调用 `calculateStackFrame()` 计算总大小
3. `updateStackFramePlaceholders()` 用字符串替换将占位符替换为实际的序言/尾声代码

---

## 指令翻译核心：generateInst()

```cpp
void RISCVCodeGen::generateInst(const ir::Instruction &inst,
                                 const AllocationResult &alloc) {
    switch (inst.op) {
        case ir::Opcode::Alloca:    genAlloca(inst, alloc);    break;
        case ir::Opcode::Store:     genStore(inst, alloc);     break;
        case ir::Opcode::Load:      genLoad(inst, alloc);      break;
        case ir::Opcode::Add:
        case ir::Opcode::Sub:
        case ir::Opcode::Mul:
        case ir::Opcode::SDiv:
        case ir::Opcode::SRem:      genBinOp(inst, alloc);     break;
        case ir::Opcode::ICmp:      genICmp(inst, alloc);      break;
        case ir::Opcode::Br:        genBr(inst, alloc);        break;
        case ir::Opcode::CondBr:    genCondBr(inst, alloc);    break;
        case ir::Opcode::Call:      genCall(inst, alloc);      break;
        case ir::Opcode::Ret:       genRet(inst, alloc);       break;
        case ir::Opcode::RetVoid:   genRetVoid(inst, alloc);   break;
        default: break;
    }
}
```

基于 `Opcode` 枚举的 switch 分派，取代了旧版基于正则表达式字符串解析的方式。

---

## 辅助函数：resolveUse() / resolveDef()

在详解每个 gen* 方法之前，先理解最重要的两个辅助函数。

### resolveUse() — 解析操作数为物理寄存器

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

std::string RISCVCodeGen::resolveUse(const Operand &op) {
    if (op.isImm()) {
        // 立即数 → li 加载到临时寄存器（t0/t1 交替分配）
        auto &allocator = funcAllocators_[currentFunction_];
        int tmpReg = allocator->allocateSpillTempReg();
        std::string tmpName = regInfo_.getRegName(tmpReg);
        emit("li " + tmpName + ", " + std::to_string(op.immValue()));
        return tmpName;
    }
    if (op.isVReg()) {
        int vreg = op.regId();
        auto &alloc = funcAllocators_[currentFunction_]->getAllocationResult();

        // 物理寄存器映射
        auto physIt = alloc.vregToPhys.find(vreg);
        if (physIt != alloc.vregToPhys.end())
            return regInfo_.getRegName(physIt->second);

        // 溢出到栈或栈传入参数
        auto stackIt = alloc.vregToStack.find(vreg);
        if (stackIt != alloc.vregToStack.end()) {
            auto &allocator = funcAllocators_[currentFunction_];
            int tmpReg = allocator->allocateSpillTempReg();
            std::string tmpName = regInfo_.getRegName(tmpReg);
            if (stackIt->second > 0) {
                // 正偏移 = 栈传入参数（第 9+ 个参数），位于调用者帧底部
                int s0Offset = stackIt->second - 4;
                emit("lw " + tmpName + ", " + std::to_string(s0Offset) + "(s0)");
            } else {
                // 负偏移 = 溢出栈槽，经 spillSlotToSpOffset 转换为 sp 正偏移
                int spOffset = spillSlotToSpOffset(stackIt->second);
                emit("lw " + tmpName + ", " + std::to_string(spOffset) + "(sp)");
            }
            return tmpName;
        }
    }
    return "zero";
}
```

**四种情况**：
1. **立即数** → `li t0/t1, value`，返回临时寄存器名（t0/t1 交替）
2. **已分配物理寄存器的虚拟寄存器** → 直接返回物理寄存器名（如 "a0"）
3. **溢出到栈的虚拟寄存器**（负偏移）→ `lw t0/t1, spillSlotToSpOffset(slot)(sp)`
4. **栈传入参数**（正偏移）→ `lw t0/t1, (slot-4)(s0)`，通过帧指针从调用者帧底部读取

临时寄存器通过 `allocateSpillTempReg()` 交替分配 t0/t1，避免同一条指令的两个操作数冲突。

### resolveDef() — 解析定义目标

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

std::string RISCVCodeGen::resolveDef(const Operand &op) {
    if (!op.isVReg()) {
        lastDefRegName_ = "a0";
        return lastDefRegName_;
    }
    int vreg = op.regId();
    auto &alloc = funcAllocators_[currentFunction_]->getAllocationResult();

    auto physIt = alloc.vregToPhys.find(vreg);
    if (physIt != alloc.vregToPhys.end()) {
        lastDefRegName_ = regInfo_.getRegName(physIt->second);
        return lastDefRegName_;
    }
    // 溢出 → 分配临时寄存器，并保存到 lastDefRegName_
    auto &allocator = funcAllocators_[currentFunction_];
    int tmpReg = allocator->allocateSpillTempReg();
    lastDefRegName_ = regInfo_.getRegName(tmpReg);
    return lastDefRegName_;
}
```

**关键设计**：`resolveDef` 将结果保存到 `lastDefRegName_` 成员变量。这是为了解决 Bug #10——中间的 `resolveUse` 调用会推进 t0/t1 交替计数器，导致后续 `spillDefIfNeeded` 获取到不同的临时寄存器。通过 `lastDefRegName_` 绑定，两者始终使用同一个寄存器。

### spillDefIfNeeded() — 溢出回写

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::spillDefIfNeeded(const Instruction &inst) {
    int dr = inst.defReg();
    if (dr < 0) return;
    auto &alloc = funcAllocators_[currentFunction_]->getAllocationResult();
    auto it = alloc.vregToStack.find(dr);
    if (it != alloc.vregToStack.end() && it->second < 0 &&
        allocaOffsets_.find(dr) == allocaOffsets_.end()) {
        // 使用 lastDefRegName_（与 resolveDef 绑定的同一寄存器）
        int spOffset = spillSlotToSpOffset(it->second);
        emit("sw " + lastDefRegName_ + ", " + std::to_string(spOffset) + "(sp)");
    }
}
```

**三个过滤条件**：
1. `it->second < 0` — 只处理溢出栈槽（负偏移），正偏移的栈传入参数不需要写回
2. `allocaOffsets_.find(dr) == allocaOffsets_.end()` — alloca 变量不走溢出路径
3. 使用 `lastDefRegName_` 而非重新调用 `allocateSpillTempReg()`

### spillSlotToSpOffset() — 溢出槽偏移转换

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

int RISCVCodeGen::spillSlotToSpOffset(int slot) {
    return callArgAreaSize_ + callSaveSize_ + ((-slot) - 4);
}
```

将分配器返回的负槽值（-4, -8, ...）映射为帧底部的正偏移：
- 出栈参数区（`callArgAreaSize_`）在最底部
- caller-saved 保存区（`callSaveSize_`）在其上
- 溢出槽在保存区之上

---

## 各指令的代码生成详解

### genAlloca — 栈空间分配

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::genAlloca(const Instruction &inst) {
    int vreg = inst.defReg();
    int size = (inst.type == "i1") ? 1 : 4;
    stackOffset_ += size;
    // 对齐到 4
    if (stackOffset_ % 4 != 0)
        stackOffset_ += (4 - stackOffset_ % 4);
    allocaOffsets_[vreg] = stackOffset_;
}
```

**语义**：alloca 不生成任何汇编指令，仅在编译时追踪栈偏移。每次 alloca 将 `stackOffset_` 增加 `size`（i32=4, i1=1），并对齐到 4 字节边界。偏移值记录到 `allocaOffsets_`，后续 `genStore`/`genLoad` 通过 `getAllocaOffset()` 将其转换为实际的帧偏移。

**`getAllocaOffset()` 的作用**：
```cpp
int RISCVCodeGen::getAllocaOffset(int vreg) {
    return allocaOffsets_[vreg] + frameOverhead_;
}
```
`frameOverhead_`（ra + s0 + callee-saved 区域总大小）使 alloca 偏移跳过帧顶部的保存区域，正确定位到 alloca 变量区域。最终在 genStore/genLoad 中以 `-getAllocaOffset(vreg)(s0)` 形式访问。

**示例**：
```llvm
%2 = alloca i32    ; stackOffset_ = 4,  allocaOffsets_[2] = 4
%3 = alloca i32    ; stackOffset_ = 8,  allocaOffsets_[3] = 8
```
假设 `frameOverhead_ = 8`（无 callee-saved）：
- `getAllocaOffset(2) = 4 + 8 = 12` → genStore 生成 `sw ..., -12(s0)`
- `getAllocaOffset(3) = 8 + 8 = 16` → genStore 生成 `sw ..., -16(s0)`

### genStore — 存储

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::genStore(const Instruction &inst) {
    std::string valReg = resolveUse(inst.ops[0]);
    int ptrVreg = inst.ops[1].regId();
    int offset = getAllocaOffset(ptrVreg);

    if (inst.type == "i1") {
        emit("sb " + valReg + ", -" + std::to_string(offset) + "(s0)");
    } else {
        emit("sw " + valReg + ", -" + std::to_string(offset) + "(s0)");
    }
}
```

所有 store 操作的目标均为 alloca 产生的栈地址，通过 `getAllocaOffset()` 获取偏移并以 `s0` 为基址存储。`i1` 类型使用 `sb`（store byte），`i32` 使用 `sw`（store word）。

### genLoad — 加载

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::genLoad(const Instruction &inst) {
    std::string defReg = resolveDef(inst.def);
    int ptrVreg = inst.ops[0].regId();
    int offset = getAllocaOffset(ptrVreg);

    if (inst.type == "i1") {
        emit("lb " + defReg + ", -" + std::to_string(offset) + "(s0)");
    } else {
        emit("lw " + defReg + ", -" + std::to_string(offset) + "(s0)");
    }
    spillDefIfNeeded(inst);
}
```

对称于 `genStore`，从 alloca 栈地址加载值到目标寄存器。如果目标 vreg 被溢出到栈，`spillDefIfNeeded` 会将其写回溢出槽。

### genBinOp — 二元运算

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::genBinOp(const Instruction &inst) {
    std::string defReg = resolveDef(inst.def);

    // addi 优化：add/sub 且立即数在 12 位有符号范围 [-2048, 2047] 内
    auto inAddiRange = [](int v) { return v >= -2048 && v <= 2047; };

    // 情况1: add vreg, imm → addi rd, rs, imm
    if (inst.opcode == Opcode::Add && inst.ops[1].isImm()
        && inAddiRange(inst.ops[1].immValue())) {
        std::string lhsReg = resolveUse(inst.ops[0]);
        emit("addi " + defReg + ", " + lhsReg + ", "
             + std::to_string(inst.ops[1].immValue()));
        spillDefIfNeeded(inst);
        return;
    }
    // 情况2: add imm, vreg → addi rd, rs, imm（交换律）
    if (inst.opcode == Opcode::Add && inst.ops[0].isImm()
        && inAddiRange(inst.ops[0].immValue())) {
        std::string rhsReg = resolveUse(inst.ops[1]);
        emit("addi " + defReg + ", " + rhsReg + ", "
             + std::to_string(inst.ops[0].immValue()));
        spillDefIfNeeded(inst);
        return;
    }
    // 情况3: sub vreg, imm → addi rd, rs, -imm
    if (inst.opcode == Opcode::Sub && inst.ops[1].isImm()
        && inAddiRange(-inst.ops[1].immValue())) {
        std::string lhsReg = resolveUse(inst.ops[0]);
        emit("addi " + defReg + ", " + lhsReg + ", "
             + std::to_string(-inst.ops[1].immValue()));
        spillDefIfNeeded(inst);
        return;
    }

    // 通用情况
    std::string lhsReg = resolveUse(inst.ops[0]);
    std::string rhsReg = resolveUse(inst.ops[1]);
    std::string op;
    switch (inst.opcode) {
    case Opcode::Add:  op = "add";  break;
    case Opcode::Sub:  op = "sub";  break;
    case Opcode::Mul:  op = "mul";  break;
    case Opcode::SDiv: op = "div";  break;
    case Opcode::SRem: op = "rem";  break;
    default: return;
    }
    emit(op + " " + defReg + ", " + lhsReg + ", " + rhsReg);
    spillDefIfNeeded(inst);
}
```

**addi 优化**：

这是一个重要的窥孔优化，覆盖三种模式，且增加了 12 位立即数范围检查（`inAddiRange`）：

| IR 模式 | RISC-V 输出 | 条件 |
|---------|-------------|------|
| `add %x, 5` | `addi rd, rs, 5` | 右操作数为立即数且在 [-2048, 2047] 范围内 |
| `add 3, %x` | `addi rd, rs, 3` | 左操作数为立即数（利用交换律） |
| `sub %x, 2` | `addi rd, rs, -2` | 减法转加负数，`-imm` 在范围内 |

不满足上述条件时（立即数超出范围或非 add/sub），退化为通用的 R-type 指令——此时立即数由 `resolveUse` 自动通过 `li` 加载到临时寄存器。

### genICmp — 整数比较

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::genICmp(const Instruction &inst) {
    std::string lhsReg = resolveUse(inst.ops[0]);
    std::string rhsReg = resolveUse(inst.ops[1]);
    std::string defReg = resolveDef(inst.def);

    // 缓存比较信息供 branch fusion
    cmpMap_[inst.defReg()] = CmpInfo{inst.cmpPred, lhsReg, rhsReg};

    // 同时生成兜底指令（供值使用场景，如 store i1）
    switch (inst.cmpPred) {
    case CmpPred::EQ:
        emit("sub " + defReg + ", " + lhsReg + ", " + rhsReg);
        emit("seqz " + defReg + ", " + defReg);
        break;
    case CmpPred::NE:
        emit("sub " + defReg + ", " + lhsReg + ", " + rhsReg);
        emit("snez " + defReg + ", " + defReg);
        break;
    case CmpPred::SLT:
        emit("slt " + defReg + ", " + lhsReg + ", " + rhsReg);
        break;
    case CmpPred::SGT:
        emit("slt " + defReg + ", " + rhsReg + ", " + lhsReg);
        break;
    case CmpPred::SLE:
        emit("slt " + defReg + ", " + rhsReg + ", " + lhsReg);
        emit("xori " + defReg + ", " + defReg + ", 1");
        break;
    case CmpPred::SGE:
        emit("slt " + defReg + ", " + lhsReg + ", " + rhsReg);
        emit("xori " + defReg + ", " + defReg + ", 1");
        break;
    }
    spillDefIfNeeded(inst);
}
```

**比较谓词到 RISC-V 指令的映射**：

| 谓词 | 指令序列 | 原理 |
|-----|---------|------|
| EQ  | `sub → seqz` | a-b == 0 |
| NE  | `sub → snez` | a-b != 0 |
| SLT | `slt` | 直接使用 slt |
| SGT | `slt` (反转操作数) | a > b ⟺ b < a |
| SLE | `slt` (反转) → `xori 1` | a ≤ b ⟺ !(b < a) |
| SGE | `slt` → `xori 1` | a ≥ b ⟺ !(a < b) |

**cmpMap_ 缓存**：将比较结果（谓词 + 操作数）保存，供 `genCondBr` 的分支融合使用。

### genCondBr — 条件分支（含分支融合优化）

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::genCondBr(const Instruction &inst) {
    std::string trueLabel  = "." + currentFunction_ + "_" + inst.ops[1].labelName();
    std::string falseLabel = "." + currentFunction_ + "_" + inst.ops[2].labelName();

    int condVreg = inst.ops[0].isVReg() ? inst.ops[0].regId() : -1;
    auto cmpIt = cmpMap_.find(condVreg);

    if (cmpIt != cmpMap_.end()) {
        // Branch fusion：直接使用 icmp 的原始操作数
        auto &cmp = cmpIt->second;
        std::string brOp;
        switch (cmp.pred) {
        case CmpPred::EQ:  brOp = "beq";  break;
        case CmpPred::NE:  brOp = "bne";  break;
        case CmpPred::SLT: brOp = "blt";  break;
        case CmpPred::SGT: brOp = "bgt";  break;
        case CmpPred::SLE: brOp = "ble";  break;
        case CmpPred::SGE: brOp = "bge";  break;
        }
        emit(brOp + " " + cmp.lhsReg + ", " + cmp.rhsReg + ", " + trueLabel);
        emit("j " + falseLabel);
        cmpMap_.erase(cmpIt);   // 消费后清除
    } else {
        // 退化：使用比较结果寄存器
        std::string condReg = resolveUse(inst.ops[0]);
        emit("bnez " + condReg + ", " + trueLabel);
        emit("j " + falseLabel);
    }
}
```

**分支融合优化**：

未优化：
```asm
    # icmp: sub + seqz → 结果在 a2
    sub a2, a0, a1
    seqz a2, a2
    # condBr: 测试 a2
    bnez a2, .true
    j .false
```

优化（融合后）：
```asm
    sub a2, a0, a1        # icmp 的计算仍保留
    seqz a2, a2           # （但可以被后续优化消除）
    beq a0, a1, .true     # 直接用原始操作数比较
    j .false
```

`cmpMap_` 缓存使 condBr 能直接引用 icmp 的原始操作数，生成更高效的条件分支指令。

### genBr — 无条件分支

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::genBr(const Instruction &inst) {
    std::string target = "." + currentFunction_ + "_" + inst.ops[0].labelName();
    emit("j " + target);
}
```

### genCall — 函数调用

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::genCall(const Instruction &inst) {
    auto &alloc = funcAllocators_[currentFunction_]->getAllocationResult();

    // 确定 def 对应的物理寄存器（跳过保存/恢复）
    int defPhysReg = -1;
    if (inst.def.isVReg()) {
        auto physIt = alloc.vregToPhys.find(inst.def.regId());
        if (physIt != alloc.vregToPhys.end())
            defPhysReg = physIt->second;
    }

    // 收集需要保存的 caller-saved 寄存器
    // （排除溢出临时寄存器和 def 寄存器）
    std::vector<int> savedRegs;
    for (auto &[vreg, physReg] : alloc.vregToPhys) {
        if (regInfo_.isCallerSaved(physReg) &&
            !funcAllocators_[currentFunction_]->isSpillTempReg(physReg) &&
            physReg != defPhysReg) {
            if (std::find(savedRegs.begin(), savedRegs.end(), physReg)
                == savedRegs.end())
                savedRegs.push_back(physReg);
        }
    }
    std::sort(savedRegs.begin(), savedRegs.end());

    // ① 保存 caller-saved 到栈（位于出栈参数区之上）
    std::map<int, int> regToSaveOffset;
    int saveOffset = callArgAreaSize_;
    for (int reg : savedRegs) {
        emit("sw " + regInfo_.getRegName(reg) + ", "
             + std::to_string(saveOffset) + "(sp)");
        regToSaveOffset[reg] = saveOffset;
        saveOffset += 4;
    }

    // ② 超过 8 个的参数 → 存放到出栈参数区 sp+0, sp+4, ...
    for (size_t i = 8; i < inst.ops.size(); ++i) {
        int argOffset = static_cast<int>(i - 8) * 4;
        const auto &op = inst.ops[i];
        // ... 处理 imm / vreg（从 regToSaveOffset 或溢出槽加载）
    }

    // ③ 前 8 个参数 → 从已保存的栈位置直接加载到 a0-a7
    for (size_t i = 0; i < inst.ops.size() && i < 8; ++i) {
        std::string target = "a" + std::to_string(i);
        const auto &op = inst.ops[i];
        if (op.isImm()) {
            emit("li " + target + ", " + std::to_string(op.immValue()));
        } else if (op.isVReg()) {
            int vreg = op.regId();
            auto physIt = alloc.vregToPhys.find(vreg);
            if (physIt != alloc.vregToPhys.end()) {
                int physReg = physIt->second;
                auto saveIt = regToSaveOffset.find(physReg);
                if (saveIt != regToSaveOffset.end())
                    // caller-saved：从已保存的栈位置加载
                    emit("lw " + target + ", "
                         + std::to_string(saveIt->second) + "(sp)");
                else if (regInfo_.getRegName(physReg) != target)
                    // callee-saved：不会被覆盖，直接 mv
                    emit("mv " + target + ", " + regInfo_.getRegName(physReg));
            } else {
                // 溢出到栈的 vreg
                auto stackIt = alloc.vregToStack.find(vreg);
                if (stackIt != alloc.vregToStack.end()) {
                    int spOff = spillSlotToSpOffset(stackIt->second);
                    emit("lw " + target + ", " + std::to_string(spOff) + "(sp)");
                }
            }
        }
    }

    // ④ 调用
    emit("call " + inst.callee);

    // ⑤ 取出返回值（在恢复 caller-saved 之前！防止 a0 被覆盖）
    std::string defReg = resolveDef(inst.def);
    if (defReg != "a0")
        emit("mv " + defReg + ", a0");

    // ⑥ 恢复 caller-saved 寄存器
    saveOffset = callArgAreaSize_;
    for (int reg : savedRegs) {
        emit("lw " + regInfo_.getRegName(reg) + ", "
             + std::to_string(saveOffset) + "(sp)");
        saveOffset += 4;
    }

    spillDefIfNeeded(inst);
}
```

**genCall 的设计要点**：

**1. 并行移动问题的解决**

旧版本直接用 `mv aN, src` 将参数移动到 a0-a7。但如果参数 a 的源寄存器恰好是另一个参数 b 的目标寄存器，就会产生覆盖问题（经典的并行移动冲突）：

```
mv a1, a0    # ← 覆盖了 a0
mv a0, a1    # ← 此时 a1 已不是原始值
```

解决方案：**先保存所有 caller-saved 寄存器到栈，然后从栈位置加载到目标寄存器**。由于每个参数都独立地从栈上（而非寄存器中）读取，完全消除了指令顺序依赖。

```
sw a0, 0(sp)     # 保存原始 a0
sw a1, 4(sp)     # 保存原始 a1
lw a0, 4(sp)     # 从栈加载原始 a1 到 a0
lw a1, 0(sp)     # 从栈加载原始 a0 到 a1
```

**2. 栈区域布局**

genCall 使用的栈区域（在 sp 一侧）分为两部分：
- `sp+0` ~ `sp+callArgAreaSize_-1`：出栈参数区（caller 传给 callee 的第 9+ 个参数）
- `sp+callArgAreaSize_` ~ `sp+callArgAreaSize_+callSaveSize_-1`：caller-saved 保存区

**3. 返回值获取时机**

`resolveDef` + `mv` 必须在恢复 caller-saved 寄存器**之前**执行。因为恢复操作会覆盖 a0-a7，如果返回值在 a0 中且 a0 也是被保存的寄存器之一，先恢复会丢失返回值。

**4. >8 参数的栈传递**

超过 8 个参数通过 `sp+0, sp+4, ...` 传递（出栈参数区）。callee 通过正偏移的栈槽（`s0 + (slot-4)`）读取这些参数。

**调用时序图**：
```
  ┌─ sw caller-saved → sp+callArgAreaSize_ 区域
  ├─ sw 第 9+ 参数   → sp+0 区域（如有）
  ├─ lw/mv a0-a7     ← 从栈位置加载（避免并行移动冲突）
  ├─ call funcName
  ├─ mv rd, a0       ← 取返回值（在恢复之前！）
  └─ lw caller-saved ← 从 sp+callArgAreaSize_ 区域恢复
```

### genRet — 函数返回

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::genRet(const Instruction &inst) {
    hasReturn_ = true;
    if (inst.opcode == Opcode::Ret && !inst.ops.empty()) {
        std::string valReg = resolveUse(inst.ops[0]);
        if (valReg != "a0")
            emit("mv a0, " + valReg);
    }
    // 尾声占位符（稍后由 updateStackFramePlaceholders 替换）
    std::string epiloguePlaceholder =
        "__EPILOGUE_PLACEHOLDER_" + currentFunction_ + "__";
    output_ += epiloguePlaceholder + "\n";
    emit("ret");
}
```

`genRet` 同时处理 `ret i32` 和 `ret void` 两种情况。尾声（恢复 callee-saved 寄存器、恢复栈帧）由占位符延迟生成。

---

## 栈帧计算与占位符回填

### calculateStackFrame()

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::calculateStackFrame() {
    auto &alloc = funcAllocators_[currentFunction_]->getAllocationResult();

    int allocaSize = stackOffset_;
    int calleeSavedCount = static_cast<int>(alloc.calleeSavedRegs.size());

    // 仅计算溢出槽（负偏移），栈传入参数（正偏移）不计入
    int spillSize = 0;
    for (auto &[vreg, slot] : alloc.vregToStack) {
        if (slot < 0) {
            int absSlot = -slot;
            spillSize = std::max(spillSize, absSlot);
        }
    }

    int frameOverhead = 8 + calleeSavedCount * 4;  // ra + s0 + callee-saved
    totalStackSize_ = allocaSize + frameOverhead + spillSize
                    + callSaveSize_ + callArgAreaSize_;

    // 对齐到 16 字节边界
    totalStackSize_ = (totalStackSize_ + 15) & ~15;
}
```

**栈帧组成**：

| 区域 | 大小来源 | 说明 |
|------|---------|------|
| 出栈参数区 | `callArgAreaSize_` | 函数调用时第 9+ 个参数的存放区域 |
| caller-saved 保存区 | `callSaveSize_` | genCall 保存/恢复 caller-saved 寄存器 |
| 溢出区域 | `spillSize` | 寄存器分配溢出的虚拟寄存器 |
| alloca 变量区域 | `allocaSize` (`stackOffset_`) | 局部变量 |
| ra + s0 | 8 字节 | 固定保存 |
| callee-saved 寄存器 | `calleeSavedCount * 4` | s2-s11 等 |

**栈帧布局（从低地址到高地址）**：

```
高地址
┌─────────────────────────────┐ ← 调用者 sp（= 当前 s0）
│    (caller 帧)              │
├─────────────────────────────┤
│  ra                         │  s0-4  = sp+(totalStackSize_-4)
│  old s0                     │  s0-8  = sp+(totalStackSize_-8)
│  callee-saved regs          │  s0-12, s0-16, ...
├─────────────────────────────┤
│  alloca 变量区域             │  -getAllocaOffset(vreg)(s0)
├─────────────────────────────┤
│  溢出区域 (spill slots)     │  spillSlotToSpOffset(slot)(sp)
├─────────────────────────────┤
│  caller-saved 保存区         │  sp+callArgAreaSize_
├─────────────────────────────┤
│  出栈参数区                  │  sp+0, sp+4, ...
├─────────────────────────────┤ ← sp (栈指针)
│  (对齐填充)                 │
└─────────────────────────────┘
低地址
```

**偏移计算公式**：
- **alloca 变量**：`-getAllocaOffset(vreg)(s0)` = `-(allocaOffsets_[vreg] + frameOverhead_)(s0)`
- **溢出槽**：`spillSlotToSpOffset(slot)(sp)` = `(callArgAreaSize_ + callSaveSize_ + (-slot) - 4)(sp)`
- **caller-saved 保存位置**：`(callArgAreaSize_ + i*4)(sp)`
- **出栈参数**：`(i*4)(sp)`

### updateStackFramePlaceholders()

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::updateStackFramePlaceholders() {
    auto &alloc = funcAllocators_[currentFunction_]->getAllocationResult();

    // Prologue
    std::string prologue;
    prologue += "    addi sp, sp, -" + std::to_string(totalStackSize_) + "\n";
    prologue += "    sw ra, " + std::to_string(totalStackSize_ - 4) + "(sp)\n";
    prologue += "    sw s0, " + std::to_string(totalStackSize_ - 8) + "(sp)\n";
    prologue += "    addi s0, sp, " + std::to_string(totalStackSize_) + "\n";

    int offset = totalStackSize_ - 12;
    for (int reg : alloc.calleeSavedRegs) {
        prologue += "    sw " + regInfo_.getRegName(reg) + ", "
                  + std::to_string(offset) + "(sp)\n";
        offset -= 4;
    }

    // 替换 prologue 占位符
    std::string prologuePlaceholder =
        "__PROLOGUE_PLACEHOLDER_" + currentFunction_ + "__";
    // ... output_.find + replace ...

    // Epilogue
    std::string epilogue;
    offset = totalStackSize_ - 12;
    for (int reg : alloc.calleeSavedRegs) {
        epilogue += "    lw " + regInfo_.getRegName(reg) + ", "
                  + std::to_string(offset) + "(sp)\n";
        offset -= 4;
    }
    epilogue += "    lw ra, " + std::to_string(totalStackSize_ - 4) + "(sp)\n";
    epilogue += "    lw s0, " + std::to_string(totalStackSize_ - 8) + "(sp)\n";
    epilogue += "    addi sp, sp, " + std::to_string(totalStackSize_) + "\n";

    // 替换所有 epilogue 占位符（函数可能有多个 return 点）
    std::string epiloguePlaceholder =
        "__EPILOGUE_PLACEHOLDER_" + currentFunction_ + "__";
    // ... while loop: output_.find + replace ...
}
```

**序言**（Prologue）— 函数入口执行：
1. `addi sp, sp, -totalStackSize_` — 分配栈帧
2. `sw ra, (totalStackSize_-4)(sp)` — 保存返回地址（帧顶部）
3. `sw s0, (totalStackSize_-8)(sp)` — 保存帧指针
4. `addi s0, sp, totalStackSize_` — 设置新帧指针（s0 指向帧顶部）
5. `sw s2, ...` 等 — 保存 callee-saved 寄存器

**尾声**（Epilogue）— 函数返回前执行（序言的逆操作）：
1. 恢复 callee-saved 寄存器
2. 恢复 ra、s0
3. `addi sp, sp, totalStackSize_` — 释放栈帧

**Epilogue 的多实例替换**：使用 `while` 循环替换所有 `__EPILOGUE_PLACEHOLDER__`，因为函数可能包含多个 `ret` 指令（如 if-else 的不同分支各有一个 return）。

---

## 完整示例追踪

以 `int add(int a, int b) { return a + b; }` 为例：

**IR 输入**：
```llvm
define i32 @add(i32 %0, i32 %1) {
entry:
  %2 = alloca i32
  store i32 %0, ptr %2
  %3 = alloca i32
  store i32 %1, ptr %3
  %4 = load i32, ptr %2
  %5 = load i32, ptr %3
  %6 = add i32 %4, %5
  ret i32 %6
}
```

**寄存器分配结果**（来自 `AllocationResult`）：
```
%0 → a0    %1 → a1    %2 → stack    %3 → stack
%4 → a0    %5 → a1    %6 → a2
calleeSavedRegs = {}
```

**预计算**：
- `frameOverhead_ = 8`（ra + s0，无 callee-saved）
- `callSaveSize_ = 0`（函数体内无函数调用）
- `callArgAreaSize_ = 0`（无超过 8 个参数的调用）

**代码生成过程**：

| IR 指令 | gen* 方法 | 效果 |
|---------|-----------|------|
| `%2 = alloca i32` | genAlloca | `stackOffset_=4, allocaOffsets_[2]=4`（不生成汇编） |
| `store %0, %2` | genStore | `sw a0, -12(s0)` (offset = 4+8 = 12) |
| `%3 = alloca i32` | genAlloca | `stackOffset_=8, allocaOffsets_[3]=8` |
| `store %1, %3` | genStore | `sw a1, -16(s0)` (offset = 8+8 = 16) |
| `%4 = load %2` | genLoad | `lw a0, -12(s0)` |
| `%5 = load %3` | genLoad | `lw a1, -16(s0)` |
| `%6 = add %4, %5` | genBinOp | `add a2, a0, a1` |
| `ret %6` | genRet | `mv a0, a2` + epilogue 占位符 + `ret` |

**栈帧计算**：allocaSize=8, frameOverhead=8, spillSize=0, callSaveSize=0, callArgAreaSize=0 → total=16（已对齐）

**占位符替换后最终汇编**：
```asm
    .globl add
add:
    addi sp, sp, -16
    sw ra, 12(sp)
    sw s0, 8(sp)
    addi s0, sp, 16
    sw a0, -12(s0)
    sw a1, -16(s0)
    lw a0, -12(s0)
    lw a1, -16(s0)
    add a2, a0, a1
    mv a0, a2
    lw ra, 12(sp)
    lw s0, 8(sp)
    addi sp, sp, 16
    ret
    .size add, .-add
```
