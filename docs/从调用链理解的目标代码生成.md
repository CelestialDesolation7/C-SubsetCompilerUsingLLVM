# 从调用链理解的目标代码生成

## 总览：入口函数调用栈

```
RISCVCodeGen::generate(const ir::Module &module)        // 主入口
├─ precomputeAllocations(module)                         // 0. 为每个函数执行寄存器分配
│  └─ LinearScanAllocator::allocate(F)                   //    (详见寄存器分配文档)
│
└─ for each function:
   generateFunction(func)                                // 1. 生成单个函数
   ├─ emit: .globl funcName / .type funcName, @function  //    1.0 指令头
   ├─ emit: funcName:                                    //    1.1 入口标签
   ├─ emit: PROLOGUE_PLACEHOLDER                         //    1.2 序言占位符
   ├─ for each basic block:
   │  ├─ emit: .blockLabel:                              //    1.3 基本块标签
   │  └─ for each instruction:
   │     generateInst(inst, allocResult)                  //    1.4 指令翻译
   │     ├─ genAlloca(inst, ...)                          //        alloca
   │     ├─ genStore(inst, ...)                           //        store
   │     ├─ genLoad(inst, ...)                            //        load
   │     ├─ genBinOp(inst, ...)                           //        add/sub/mul/sdiv/srem
   │     ├─ genICmp(inst, ...)                            //        icmp
   │     ├─ genCondBr(inst, ...)                          //        条件分支
   │     ├─ genBr(inst, ...)                              //        无条件分支
   │     ├─ genCall(inst, ...)                            //        函数调用
   │     └─ genRet / genRetVoid(inst, ...)                //        返回
   │
   ├─ calculateStackFrame(func, allocResult)              //    1.5 计算栈帧大小
   └─ updateStackFramePlaceholders(func.name, ...)        //    1.6 回填序言/尾声
```

所有代码位于 [riscv_codegen.h](../src/include/riscv_codegen.h) 和 [riscv_codegen.cpp](../src/riscv_codegen.cpp) 中，命名空间 `toyc`。

---

## 阶段 0：预计算分配

### precomputeAllocations()

```cpp
// [riscv_codegen.cpp](../src/riscv_codegen.cpp)

void RISCVCodeGen::precomputeAllocations(const ir::Module &module) {
    for (auto &func : module.functions) {
        auto allocator = std::make_unique<LinearScanAllocator>();
        allocator->allocate(*func);
        funcAllocators_[func->name] = std::move(allocator);
    }
}
```

为模块中的每个函数创建独立的 `LinearScanAllocator`，执行完整的寄存器分配流程（详见[寄存器分配流程文档](./从调用链理解的寄存器分配流程.md)），结果存储在 `funcAllocators_` 映射中。

**设计原则**：分配与代码生成分离 — 先为所有函数完成分配，再逐一生成代码。这样代码生成阶段只需查询 `AllocationResult`，不需要考虑分配逻辑。

---

## 阶段 1：函数代码生成

### generateFunction()

```cpp
void RISCVCodeGen::generateFunction(const ir::Function &func) {
    auto &allocResult = funcAllocators_[func.name]->getAllocationResult();
    stackOffset_ = 0;
    allocaOffsets_.clear();
    cmpMap_.clear();

    // 1.0 ELF 指令头
    emit(".globl " + func.name);
    emit(".type " + func.name + ", @function");

    // 1.1 入口标签
    emit(func.name + ":");

    // 1.2 序言占位符（稍后回填）
    emit("PROLOGUE_PLACEHOLDER_" + func.name);

    // 1.3-1.4 遍历所有基本块及其指令
    for (auto &block : func.blocks) {
        if (block->name != "entry")
            emit("." + func.name + "_" + block->name + ":");
        for (auto &inst : block->insts)
            generateInst(*inst, allocResult);
    }

    // 1.5 计算栈帧大小
    int frameSize = calculateStackFrame(func, allocResult);

    // 1.6 回填序言/尾声
    updateStackFramePlaceholders(func.name, frameSize, allocResult);
}
```

**关键设计 — 占位符机制**：

生成函数体时，序言的栈帧大小未知（因为 alloca 和 spill slot 的总大小只有在遍历完所有指令后才能确定）。解决方案是：
1. 先输出 `PROLOGUE_PLACEHOLDER_funcName`
2. 遍历完所有指令后计算栈帧
3. 用字符串替换将占位符替换为实际的序言/尾声代码

---

## 指令翻译核心：generateInst()

```cpp
void RISCVCodeGen::generateInst(const ir::Instruction &inst,
                                 const AllocationResult &alloc) {
    switch (inst.op) {
        case ir::Opcode::Alloca:    genAlloca(inst, alloc);    break;
        case ir::Opcode::Store:     genStore(inst, alloc);     break;
        case ir::Opcode::Load:      genLoad(inst, alloc);      break;
        case ir::Opcode::Add:
        case ir::Opcode::Sub:
        case ir::Opcode::Mul:
        case ir::Opcode::SDiv:
        case ir::Opcode::SRem:      genBinOp(inst, alloc);     break;
        case ir::Opcode::ICmp:      genICmp(inst, alloc);      break;
        case ir::Opcode::Br:        genBr(inst, alloc);        break;
        case ir::Opcode::CondBr:    genCondBr(inst, alloc);    break;
        case ir::Opcode::Call:      genCall(inst, alloc);      break;
        case ir::Opcode::Ret:       genRet(inst, alloc);       break;
        case ir::Opcode::RetVoid:   genRetVoid(inst, alloc);   break;
        default: break;
    }
}
```

基于 `Opcode` 枚举的 switch 分派，取代了旧版基于正则表达式字符串解析的方式。

---

## 辅助函数：resolveUse() / resolveDef()

在详解每个 gen* 方法之前，先理解最重要的两个辅助函数。

### resolveUse() — 解析操作数为物理寄存器

```cpp
std::string RISCVCodeGen::resolveUse(const ir::Operand &op,
                                      const AllocationResult &alloc,
                                      const std::string &hint) {
    if (op.kind() == ir::Operand::Kind::Imm) {
        // 立即数 → li 加载到临时寄存器
        std::string tmp = hint.empty() ? "t0" : hint;
        emit("    li " + tmp + ", " + std::to_string(op.immVal()));
        return tmp;
    }
    if (op.kind() == ir::Operand::Kind::VReg) {
        int vreg = op.regId();
        // 先查物理寄存器映射
        if (alloc.vregToPhys.count(vreg))
            return regName(alloc.vregToPhys.at(vreg));
        // 溢出 → 从栈加载
        if (alloc.vregToStack.count(vreg)) {
            std::string tmp = hint.empty() ? "t0" : hint;
            int off = alloc.vregToStack.at(vreg);
            emit("    lw " + tmp + ", " + std::to_string(off) + "(sp)");
            return tmp;
        }
    }
    return "t0";
}
```

**三种情况**：
1. **立即数**（`Operand::Kind::Imm`）→ `li t0/t1, value`，返回临时寄存器名
2. **已分配物理寄存器的虚拟寄存器** → 直接返回物理寄存器名（如 "a0"）
3. **溢出到栈的虚拟寄存器** → `lw t0/t1, offset(sp)`，返回临时寄存器名

`hint` 参数指示使用哪个临时寄存器（"t0" 或 "t1"），避免两个操作数使用同一个临时寄存器。

### resolveDef() — 解析定义目标

```cpp
std::string RISCVCodeGen::resolveDef(int vreg, const AllocationResult &alloc) {
    if (alloc.vregToPhys.count(vreg))
        return regName(alloc.vregToPhys.at(vreg));
    // 溢出 → 写入临时寄存器，稍后 spillDefIfNeeded 会 sw 到栈
    return "t0";
}
```

### spillDefIfNeeded() — 溢出回写

```cpp
void RISCVCodeGen::spillDefIfNeeded(int vreg, const std::string &reg,
                                     const AllocationResult &alloc) {
    if (alloc.vregToStack.count(vreg)) {
        int off = alloc.vregToStack.at(vreg);
        emit("    sw " + reg + ", " + std::to_string(off) + "(sp)");
    }
}
```

如果 vreg 被溢出，将临时寄存器的值存回栈。

---

## 各指令的代码生成详解

### genAlloca — 栈空间分配

```cpp
void RISCVCodeGen::genAlloca(const ir::Instruction &inst,
                              const AllocationResult &alloc) {
    int vreg = inst.result;
    int size = 4;   // 固定 4 字节（i32）
    stackOffset_ += size;
    allocaOffsets_[vreg] = -stackOffset_;

    std::string rd = resolveDef(vreg, alloc);
    emit("    addi " + rd + ", s0, " + std::to_string(-stackOffset_));
    spillDefIfNeeded(vreg, rd, alloc);
}
```

**语义**：alloca 不是 RISC-V 指令，而是在编译时追踪栈偏移。每次 alloca 将 `stackOffset_` 增加 4，然后用 `addi rd, s0, -offset` 将地址计算到目标寄存器。

**示例**：
```llvm
%2 = alloca i32    ; stackOffset_ = 4,  allocaOffsets_[2] = -4
%3 = alloca i32    ; stackOffset_ = 8,  allocaOffsets_[3] = -8
```
生成：
```asm
    addi a2, s0, -4    # %2 的地址 = s0-4
    addi a3, s0, -8    # %3 的地址 = s0-8
```

### genStore — 存储

```cpp
void RISCVCodeGen::genStore(const ir::Instruction &inst,
                             const AllocationResult &alloc) {
    auto &valOp = inst.ops[0];    // 值
    auto &ptrOp = inst.ops[1];    // 指针

    // 确定存储类型（i1 用 sb，i32 用 sw）
    std::string storeOp = (inst.storeType == "i1") ? "sb" : "sw";

    if (ptrOp.kind() == ir::Operand::Kind::VReg &&
        allocaOffsets_.count(ptrOp.regId())) {
        // 目标是 alloca 出的栈地址 → 直接用帧指针偏移
        int off = allocaOffsets_[ptrOp.regId()];
        std::string src = resolveUse(valOp, alloc, "t0");
        emit("    " + storeOp + " " + src + ", " + std::to_string(off) + "(s0)");
    } else {
        // 通用情况：指针在寄存器中
        std::string src = resolveUse(valOp, alloc, "t0");
        std::string ptr = resolveUse(ptrOp, alloc, "t1");
        emit("    " + storeOp + " " + src + ", 0(" + ptr + ")");
    }
}
```

**优化**：当目标是 alloca 地址时，跳过指针寄存器解析，直接使用已知的帧偏移。

**i1 类型处理**：布尔值使用 `sb`（store byte）而非 `sw`（store word），匹配 `load` 中的 `lb`。

### genLoad — 加载

```cpp
void RISCVCodeGen::genLoad(const ir::Instruction &inst,
                            const AllocationResult &alloc) {
    int destVreg = inst.result;
    auto &ptrOp = inst.ops[0];

    std::string loadOp = (inst.loadType == "i1") ? "lb" : "lw";
    std::string rd = resolveDef(destVreg, alloc);

    if (ptrOp.kind() == ir::Operand::Kind::VReg &&
        allocaOffsets_.count(ptrOp.regId())) {
        int off = allocaOffsets_[ptrOp.regId()];
        emit("    " + loadOp + " " + rd + ", " + std::to_string(off) + "(s0)");
    } else {
        std::string ptr = resolveUse(ptrOp, alloc, "t1");
        emit("    " + loadOp + " " + rd + ", 0(" + ptr + ")");
    }
    spillDefIfNeeded(destVreg, rd, alloc);
}
```

对称于 `genStore`，同样利用 alloca 偏移优化。

### genBinOp — 二元运算

```cpp
void RISCVCodeGen::genBinOp(const ir::Instruction &inst,
                              const AllocationResult &alloc) {
    int destVreg = inst.result;
    auto &lhs = inst.ops[0];
    auto &rhs = inst.ops[1];
    std::string rd = resolveDef(destVreg, alloc);

    // === addi 优化 ===
    // 情况1: add vreg, imm → addi rd, rs, imm
    if (inst.op == ir::Opcode::Add &&
        rhs.kind() == ir::Operand::Kind::Imm) {
        std::string rs = resolveUse(lhs, alloc, "t0");
        emit("    addi " + rd + ", " + rs + ", " +
             std::to_string(rhs.immVal()));
        spillDefIfNeeded(destVreg, rd, alloc);
        return;
    }
    // 情况2: add imm, vreg → addi rd, rs, imm（交换律）
    if (inst.op == ir::Opcode::Add &&
        lhs.kind() == ir::Operand::Kind::Imm) {
        std::string rs = resolveUse(rhs, alloc, "t0");
        emit("    addi " + rd + ", " + rs + ", " +
             std::to_string(lhs.immVal()));
        spillDefIfNeeded(destVreg, rd, alloc);
        return;
    }
    // 情况3: sub vreg, imm → addi rd, rs, -imm
    if (inst.op == ir::Opcode::Sub &&
        rhs.kind() == ir::Operand::Kind::Imm) {
        std::string rs = resolveUse(lhs, alloc, "t0");
        emit("    addi " + rd + ", " + rs + ", " +
             std::to_string(-rhs.immVal()));
        spillDefIfNeeded(destVreg, rd, alloc);
        return;
    }

    // === 通用情况 ===
    std::string rs1 = resolveUse(lhs, alloc, "t0");
    std::string rs2 = resolveUse(rhs, alloc, "t1");

    std::string asmOp;
    switch (inst.op) {
        case ir::Opcode::Add:  asmOp = "add";  break;
        case ir::Opcode::Sub:  asmOp = "sub";  break;
        case ir::Opcode::Mul:  asmOp = "mul";  break;
        case ir::Opcode::SDiv: asmOp = "div";  break;
        case ir::Opcode::SRem: asmOp = "rem";  break;
        default: break;
    }
    emit("    " + asmOp + " " + rd + ", " + rs1 + ", " + rs2);
    spillDefIfNeeded(destVreg, rd, alloc);
}
```

**addi 优化**：

这是一个重要的窥孔优化，覆盖三种模式：

| IR 模式 | RISC-V 输出 | 说明 |
|---------|-------------|------|
| `add %x, 5` | `addi rd, rs, 5` | 右操作数为立即数 |
| `add 3, %x` | `addi rd, rs, 3` | 左操作数为立即数（利用交换律） |
| `sub %x, 2` | `addi rd, rs, -2` | 减法转加负数 |

不满足上述条件时，退化为通用的 R-type 指令。

### genICmp — 整数比较

```cpp
void RISCVCodeGen::genICmp(const ir::Instruction &inst,
                            const AllocationResult &alloc) {
    int destVreg = inst.result;
    auto &lhs = inst.ops[0];
    auto &rhs = inst.ops[1];

    std::string rs1 = resolveUse(lhs, alloc, "t0");
    std::string rs2 = resolveUse(rhs, alloc, "t1");
    std::string rd = resolveDef(destVreg, alloc);

    switch (inst.pred) {
        case ir::CmpPred::EQ:
            emit("    sub " + rd + ", " + rs1 + ", " + rs2);
            emit("    seqz " + rd + ", " + rd);
            break;
        case ir::CmpPred::NE:
            emit("    sub " + rd + ", " + rs1 + ", " + rs2);
            emit("    snez " + rd + ", " + rd);
            break;
        case ir::CmpPred::SLT:
            emit("    slt " + rd + ", " + rs1 + ", " + rs2);
            break;
        case ir::CmpPred::SGT:
            emit("    slt " + rd + ", " + rs2 + ", " + rs1);
            break;
        case ir::CmpPred::SLE:
            emit("    slt " + rd + ", " + rs2 + ", " + rs1);
            emit("    xori " + rd + ", " + rd + ", 1");
            break;
        case ir::CmpPred::SGE:
            emit("    slt " + rd + ", " + rs1 + ", " + rs2);
            emit("    xori " + rd + ", " + rd + ", 1");
            break;
        default: break;
    }

    // 缓存比较结果用于分支融合
    cmpMap_[destVreg] = {inst.pred, rs1, rs2};
    spillDefIfNeeded(destVreg, rd, alloc);
}
```

**比较谓词到 RISC-V 指令的映射**：

| 谓词 | 指令序列 | 原理 |
|-----|---------|------|
| EQ  | `sub → seqz` | a-b == 0 |
| NE  | `sub → snez` | a-b != 0 |
| SLT | `slt` | 直接使用 slt |
| SGT | `slt` (反转操作数) | a > b ⟺ b < a |
| SLE | `slt` (反转) → `xori 1` | a ≤ b ⟺ !(b < a) |
| SGE | `slt` → `xori 1` | a ≥ b ⟺ !(a < b) |

**cmpMap_ 缓存**：将比较结果（谓词 + 操作数）保存，供 `genCondBr` 的分支融合使用。

### genCondBr — 条件分支（含分支融合优化）

```cpp
void RISCVCodeGen::genCondBr(const ir::Instruction &inst,
                              const AllocationResult &alloc) {
    int condVreg = inst.ops[0].regId();
    std::string trueLabel  = "." + currentFunc_ + "_" + inst.ops[1].labelName();
    std::string falseLabel = "." + currentFunc_ + "_" + inst.ops[2].labelName();

    // 尝试分支融合：直接使用比较操作数
    if (cmpMap_.count(condVreg)) {
        auto &[pred, rs1, rs2] = cmpMap_[condVreg];
        std::string brOp;
        switch (pred) {
            case ir::CmpPred::EQ:  brOp = "beq";  break;
            case ir::CmpPred::NE:  brOp = "bne";  break;
            case ir::CmpPred::SLT: brOp = "blt";  break;
            case ir::CmpPred::SGT: brOp = "bgt";  break;
            case ir::CmpPred::SLE: brOp = "ble";  break;
            case ir::CmpPred::SGE: brOp = "bge";  break;
            default: brOp = ""; break;
        }
        if (!brOp.empty()) {
            emit("    " + brOp + " " + rs1 + ", " + rs2 + ", " + trueLabel);
            emit("    j " + falseLabel);
            return;
        }
    }

    // 退化：使用比较结果寄存器
    std::string cond = resolveUse(inst.ops[0], alloc, "t0");
    emit("    bnez " + cond + ", " + trueLabel);
    emit("    j " + falseLabel);
}
```

**分支融合优化**：

未优化：
```asm
    # icmp: sub + seqz → 结果在 a2
    sub a2, a0, a1
    seqz a2, a2
    # condBr: 测试 a2
    bnez a2, .true
    j .false
```

优化（融合后）：
```asm
    sub a2, a0, a1        # icmp 的计算仍保留
    seqz a2, a2           # （但可以被后续优化消除）
    beq a0, a1, .true     # 直接用原始操作数比较
    j .false
```

`cmpMap_` 缓存使 condBr 能直接引用 icmp 的原始操作数，生成更高效的条件分支指令。

### genBr — 无条件分支

```cpp
void RISCVCodeGen::genBr(const ir::Instruction &inst,
                          const AllocationResult &) {
    std::string label = "." + currentFunc_ + "_" + inst.ops[0].labelName();
    emit("    j " + label);
}
```

### genCall — 函数调用

```cpp
void RISCVCodeGen::genCall(const ir::Instruction &inst,
                            const AllocationResult &alloc) {
    std::string funcName = inst.ops[0].labelName();

    // 1. 保存 caller-saved 寄存器
    std::vector<std::string> savedRegs;
    for (auto &[vreg, phys] : alloc.vregToPhys) {
        if (regInfo().isCallerSaved(phys)) {
            savedRegs.push_back(regName(phys));
        }
    }
    int saveOffset = 0;
    for (auto &r : savedRegs) {
        emit("    sw " + r + ", " + std::to_string(saveOffset) + "(sp)");
        saveOffset += 4;
    }

    // 2. 设置参数（从 a0 开始）
    for (size_t i = 1; i < inst.ops.size(); ++i) {
        std::string src = resolveUse(inst.ops[i], alloc, "t0");
        std::string argReg = "a" + std::to_string(i - 1);
        if (src != argReg)
            emit("    mv " + argReg + ", " + src);
    }

    // 3. 调用函数
    emit("    call " + funcName);

    // 4. 恢复 caller-saved 寄存器
    saveOffset = 0;
    for (auto &r : savedRegs) {
        emit("    lw " + r + ", " + std::to_string(saveOffset) + "(sp)");
        saveOffset += 4;
    }

    // 5. 如有返回值，从 a0 取出
    if (inst.result != -1) {
        std::string rd = resolveDef(inst.result, alloc);
        if (rd != "a0")
            emit("    mv " + rd + ", a0");
        spillDefIfNeeded(inst.result, rd, alloc);
    }
}
```

**调用约定（RISC-V LP32）**：

```
调用前                调用后
┌─────────────────┐   ┌─────────────────┐
│ sw a0-a7 → sp   │   │                 │
│ mv args → a0-a7 │   │                 │
│ call func        │ → │ func 执行...    │
│                 │   │ 返回值在 a0     │
│ lw sp → a0-a7   │   │                 │
│ mv a0 → rd      │   │                 │
└─────────────────┘   └─────────────────┘
```

### genRet / genRetVoid — 函数返回

```cpp
void RISCVCodeGen::genRet(const ir::Instruction &inst,
                           const AllocationResult &alloc) {
    std::string src = resolveUse(inst.ops[0], alloc, "t0");
    if (src != "a0")
        emit("    mv a0, " + src);    // 返回值放入 a0

    emit("EPILOGUE_PLACEHOLDER_" + currentFunc_);  // 尾声占位符
    emit("    ret");
}

void RISCVCodeGen::genRetVoid(const ir::Instruction &,
                               const AllocationResult &) {
    emit("EPILOGUE_PLACEHOLDER_" + currentFunc_);
    emit("    ret");
}
```

尾声（恢复 callee-saved 寄存器、恢复栈帧）由占位符延迟生成。

---

## 栈帧计算与占位符回填

### calculateStackFrame()

```cpp
int RISCVCodeGen::calculateStackFrame(const ir::Function &func,
                                       const AllocationResult &alloc) {
    // 1. alloca 区域
    int allocaSize = stackOffset_;

    // 2. ra + s0（始终保存）
    int fixedSize = 8;   // ra(4B) + s0(4B)

    // 3. callee-saved 寄存器
    int calleeSavedSize = static_cast<int>(alloc.calleeSavedRegs.size()) * 4;

    // 4. 溢出区域
    int spillCount = 0;
    for (auto &[vreg, off] : alloc.vregToStack) {
        if (alloc.paramVregToLocation.count(vreg) &&
            alloc.paramVregToLocation.at(vreg) > 0)
            continue;   // 栈参数不计入
        spillCount++;
    }
    int spillSize = spillCount * 4;

    // 5. 总大小对齐到 16 字节
    int total = allocaSize + fixedSize + calleeSavedSize + spillSize;
    total = (total + 15) & ~15;   // 向上对齐
    return total;
}
```

**栈帧布局**：

```
高地址
┌────────────────────┐ ← 调用者 sp
│  (caller 帧)       │
├────────────────────┤ ← s0 (帧指针)
│  ra                │  -4(s0)
│  old s0            │  -8(s0)
│  callee-saved regs │  -12(s0), -16(s0), ...
│  alloca 区域       │  (由 allocaOffsets_ 索引)
│  spill 区域        │  (由 vregToStack 索引)
├────────────────────┤ ← sp (栈指针)
│  (对齐填充)        │
└────────────────────┘
低地址
```

### updateStackFramePlaceholders()

```cpp
void RISCVCodeGen::updateStackFramePlaceholders(
    const std::string &funcName, int frameSize,
    const AllocationResult &alloc) {

    // 构建 prologue
    std::string prologue;
    prologue += "    addi sp, sp, -" + std::to_string(frameSize) + "\n";
    prologue += "    sw ra, " + std::to_string(frameSize - 4) + "(sp)\n";
    prologue += "    sw s0, " + std::to_string(frameSize - 8) + "(sp)\n";
    prologue += "    addi s0, sp, " + std::to_string(frameSize);

    // 保存 callee-saved 寄存器
    int offset = frameSize - 12;
    for (int reg : alloc.calleeSavedRegs) {
        prologue += "\n    sw " + regName(reg) + ", " +
                    std::to_string(offset) + "(sp)";
        offset -= 4;
    }

    // 构建 epilogue
    std::string epilogue;
    offset = frameSize - 12;
    for (int reg : alloc.calleeSavedRegs) {
        epilogue += "    lw " + regName(reg) + ", " +
                    std::to_string(offset) + "(sp)\n";
        offset -= 4;
    }
    epilogue += "    lw ra, " + std::to_string(frameSize - 4) + "(sp)\n";
    epilogue += "    lw s0, " + std::to_string(frameSize - 8) + "(sp)\n";
    epilogue += "    addi sp, sp, " + std::to_string(frameSize);

    // 字符串替换
    for (auto &line : output_) {
        if (line == "PROLOGUE_PLACEHOLDER_" + funcName)
            line = prologue;
        else if (line == "EPILOGUE_PLACEHOLDER_" + funcName)
            line = epilogue;
    }
}
```

**序言**（Prologue）— 函数入口执行：
1. `addi sp, sp, -frameSize` — 分配栈帧
2. `sw ra, (frameSize-4)(sp)` — 保存返回地址
3. `sw s0, (frameSize-8)(sp)` — 保存帧指针
4. `addi s0, sp, frameSize` — 设置新帧指针
5. `sw s2, ...` 等 — 保存 callee-saved 寄存器

**尾声**（Epilogue）— 函数返回前执行（序言的逆操作）：
1. 恢复 callee-saved 寄存器
2. 恢复 ra、s0
3. `addi sp, sp, frameSize` — 释放栈帧

---

## 完整示例追踪

以 `int add(int a, int b) { return a + b; }` 为例：

**IR 输入**：
```llvm
define i32 @add(i32 %0, i32 %1) {
entry:
  %2 = alloca i32
  store i32 %0, ptr %2
  %3 = alloca i32
  store i32 %1, ptr %3
  %4 = load i32, ptr %2
  %5 = load i32, ptr %3
  %6 = add i32 %4, %5
  ret i32 %6
}
```

**寄存器分配结果**（来自 `AllocationResult`）：
```
%0 → a0    %1 → a1    %2 → a2    %3 → a3
%4 → a0    %5 → a1    %6 → a2
calleeSavedRegs = {}
```

**代码生成过程**：

| IR 指令 | gen* 方法 | 汇编输出 |
|---------|-----------|---------|
| (入口) | generateFunction | `.globl add` / `.type add, @function` / `add:` |
| (占位) | | `PROLOGUE_PLACEHOLDER_add` |
| `%2 = alloca i32` | genAlloca | `addi a2, s0, -4` (stackOffset_=4) |
| `store %0, %2` | genStore | `sw a0, -4(s0)` (利用 allocaOffsets_) |
| `%3 = alloca i32` | genAlloca | `addi a3, s0, -8` (stackOffset_=8) |
| `store %1, %3` | genStore | `sw a1, -8(s0)` |
| `%4 = load %2` | genLoad | `lw a0, -4(s0)` |
| `%5 = load %3` | genLoad | `lw a1, -8(s0)` |
| `%6 = add %4, %5` | genBinOp | `add a2, a0, a1` |
| `ret %6` | genRet | `mv a0, a2` / `EPILOGUE_PLACEHOLDER_add` / `ret` |

**栈帧计算**：allocaSize=8, fixedSize=8, calleeSaved=0, spill=0 → total=16（已对齐）

**占位符替换后最终汇编**：
```asm
    .globl add
    .type add, @function
add:
    addi sp, sp, -16
    sw ra, 12(sp)
    sw s0, 8(sp)
    addi s0, sp, 16
    addi a2, s0, -4
    sw a0, -4(s0)
    addi a3, s0, -8
    sw a1, -8(s0)
    lw a0, -4(s0)
    lw a1, -8(s0)
    add a2, a0, a1
    mv a0, a2
    lw ra, 12(sp)
    lw s0, 8(sp)
    addi sp, sp, 16
    ret
```
