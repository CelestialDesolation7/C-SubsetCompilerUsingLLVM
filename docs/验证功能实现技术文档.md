# ToyC 编译器验证功能实现技术文档

## 概述

本文档详细记录了为 ToyC 编译器添加自动化验证功能（`make verify`）时遇到的技术挑战、解决方案及关键技术讲解。

---

## 目录

1. [功能目标](#1-功能目标)
2. [整体架构设计](#2-整体架构设计)
3. [遇到的问题与解决方案](#3-遇到的问题与解决方案)
   - [问题 1: 汇编代码缺少关键指令](#问题-1-汇编代码缺少关键指令)
   - [问题 2: RISC-V 工具链兼容性](#问题-2-risc-v-工具链兼容性)
   - [问题 3: 缺少运行时库](#问题-3-缺少运行时库)
   - [问题 4: Clang 汇编与 GNU 汇编器不兼容](#问题-4-clang-汇编与-gnu-汇编器不兼容)
   - [问题 5: 软件除法函数缺失](#问题-5-软件除法函数缺失)
   - [问题 6: QEMU 用户模式运行问题](#问题-6-qemu-用户模式运行问题)
4. [关键技术讲解](#4-关键技术讲解)
5. [最终实现](#5-最终实现)
6. [总结](#6-总结)

---

## 1. 功能目标

### 需求描述

实现 `make verify` 命令，自动完成以下流程：

```
源代码(.c) → ToyC 生成汇编 → 编译为可执行文件 → 运行获取结果
                    ↓
              Clang 生成汇编 → 编译为可执行文件 → 运行获取结果
                    ↓
              对比两者结果 → 输出 ✅ 正确 / ❌ 错误
```

### 验证标准

- **退出码一致**：ToyC 和 Clang 生成的程序退出码相同
- **输出一致**：标准输出内容相同（如果有）

---

## 2. 整体架构设计

### 文件结构

```
scripts/
├── verify_output.sh    # 主验证脚本
├── crt0.s             # 自定义启动代码（裸机环境）
├── generate_asm.sh    # 汇编生成脚本
└── generate_ir.sh     # IR 生成脚本
```

### 验证流程

```bash
make verify
    │
    ├── 1. make test (生成汇编)
    │       ├── ToyC → test/asm/*_toyc.s
    │       └── Clang → test/asm/*_clang.s
    │
    ├── 2. 编译启动代码
    │       └── crt0.s → crt0.o
    │
    ├── 3. 遍历每个测试用例
    │       ├── 编译 ToyC 汇编 → 可执行文件
    │       ├── 编译 Clang 汇编 → 可执行文件
    │       ├── QEMU 运行两个程序
    │       └── 对比结果
    │
    └── 4. 输出统计报告
```

---

## 3. 遇到的问题与解决方案

### 问题 1: 汇编代码缺少关键指令

#### 现象

所有测试用例编译失败，提示链接错误。

#### 排查过程

查看 ToyC 生成的汇编代码：

```asm
; 修复前的 01_minimal_toyc.s
	.globl	main
main:
	addi	sp, sp, -16
	sw	ra, 12(sp)
	sw	s0, 8(sp)
	addi	s0, sp, 16
	li	t1, 0
	sw	t1, -12(s0)
                        ; ❌ 缺少 ret 指令！
                        ; ❌ 缺少栈帧恢复！
```

对比 Clang 生成的正确汇编：

```asm
; Clang 生成的 01_minimal_clang.s
	.text                   ; ✅ 有 .text 段声明
	.globl	main
main:
	addi	sp, sp, -16
	sw	ra, 12(sp)
	sw	s0, 8(sp)
	addi	s0, sp, 16
	li	a0, 0
	sw	a0, -12(s0)
	lw	ra, 12(sp)          ; ✅ 恢复返回地址
	lw	s0, 8(sp)           ; ✅ 恢复帧指针
	addi	sp, sp, 16      ; ✅ 恢复栈指针
	ret                     ; ✅ 有 ret 指令
```

#### 根本原因

在 `src/riscv_gen.cpp` 中的 `generateReturn` 函数存在逻辑错误：

```cpp
// 修复前的代码
void RISCVGenerator::generateReturn(const std::string &value)
{
    if (value != "0")  // ❌ 只有 value != "0" 时才生成返回代码
    {
        std::string valueReg = parseOperand(value);
        addInstruction("\tmv\ta0, " + valueReg);
        addInstruction("__STACK_FRAME_DEALLOCATION_PLACEHOLDER__");
        addInstruction("\tret");
    }
    hasReturn = true;  // 设置了标志，但没有生成指令
}
```

当 C 代码是 `return 0;` 时，`value` 为 `"0"`，条件 `value != "0"` 为 false，导致：
- 不生成 `li a0, 0`（设置返回值）
- 不生成栈帧恢复指令
- 不生成 `ret` 指令

#### 解决方案

修复 `generateReturn` 函数，确保无论返回值是什么都生成完整的返回序列：

```cpp
// 修复后的代码
void RISCVGenerator::generateReturn(const std::string &value)
{
    // 将返回值移动到 a0 寄存器
    if (value == "0")
    {
        addInstruction("\tli\ta0, 0");  // ✅ return 0 也要设置 a0
    }
    else
    {
        std::string valueReg = parseOperand(value);
        addInstruction("\tmv\ta0, " + valueReg);
    }
    
    // ✅ 无论如何都生成栈帧回收和返回指令
    addInstruction("__STACK_FRAME_DEALLOCATION_PLACEHOLDER__");
    addInstruction("\tret");
    hasReturn = true;
}
```

同时，在 `generateModule` 函数开头添加 `.text` 段声明：

```cpp
std::string RISCVGenerator::generateModule(const std::string &llvmIR)
{
    std::string assembly = "";
    precomputeAllFunctionAllocations(llvmIR);

    // ✅ 添加汇编文件头
    assembly += "\t.text\n";
    assembly += "\t.globl\tmain                            # -- Begin function main\n";
    // ...
}
```

---

### 问题 2: RISC-V 工具链兼容性

#### 现象

```
Error: riscv32-unknown-elf-gcc not found
```

#### 原因分析

Ubuntu 官方仓库提供的 RISC-V 工具链包名为 `gcc-riscv64-unknown-elf`，安装后的命令是 `riscv64-unknown-elf-gcc`，而不是脚本中硬编码的 `riscv32-unknown-elf-gcc`。

#### 解决方案

修改验证脚本，自动检测可用的工具链：

```bash
# 检查 RISC-V 工具链（支持 32 位和 64 位）
RISCV_GCC=""
RISCV_ARCH=""
RISCV_ABI=""

if command -v riscv32-unknown-elf-gcc >/dev/null 2>&1; then
  RISCV_GCC="riscv32-unknown-elf-gcc"
  RISCV_ARCH="rv32im"
  RISCV_ABI="ilp32"
elif command -v riscv64-unknown-elf-gcc >/dev/null 2>&1; then
  RISCV_GCC="riscv64-unknown-elf-gcc"
  RISCV_ARCH="rv32im"      # 仍然使用 RV32 架构
  RISCV_ABI="ilp32"        # 仍然使用 32 位 ABI
  echo "Note: Using riscv64-unknown-elf-gcc for RV32 compilation"
else
  echo "Error: RISC-V GCC not found"
  exit 1
fi
```

#### 技术要点

**为什么 riscv64 工具链可以编译 RV32 代码？**

RISC-V 64 位工具链是 32 位的超集，完全支持编译 32 位代码：

```bash
# 使用 riscv64 工具链编译 RV32 代码
riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 file.s -o output
```

关键参数：
- `-march=rv32im`：指定目标架构为 RV32I + M 扩展
- `-mabi=ilp32`：指定 32 位 ABI（int/long/pointer 都是 32 位）

---

### 问题 3: 缺少运行时库

#### 现象

```
/usr/lib/gcc/riscv64-unknown-elf/13.2.0/../../../riscv64-unknown-elf/bin/ld: 
cannot find crt0.o: No such file or directory
cannot find -lc: No such file or directory
cannot find -lgloss: No such file or directory
```

#### 原因分析

使用 `-static` 选项时，链接器需要：
- `crt0.o`：C 运行时启动代码
- `libc.a`：C 标准库
- `libgloss.a`：系统调用接口库

这些是 newlib 运行时库的组成部分，Ubuntu 的 `gcc-riscv64-unknown-elf` 包不包含 RV32 的运行时库。

#### 解决方案

创建自定义的最小化启动代码 `scripts/crt0.s`：

```asm
# RISC-V 32-bit 启动代码
# 用于 QEMU 用户模式下运行测试程序

    .text
    .globl _start
    .type _start, @function

_start:
    # 设置栈指针 (QEMU 用户模式会提供一个合理的 sp)
    addi    sp, sp, -16
    
    # 调用 main 函数
    call    main
    
    # main 返回后，返回值在 a0 中
    # 使用 Linux RISC-V exit 系统调用 (syscall 93)
    mv      a0, a0          # 退出码已经在 a0 中
    li      a7, 93          # exit syscall number
    ecall                   # 执行系统调用
    
    # 如果 ecall 失败，使用备用方法
    li      t0, 0
    jr      t0

    .size _start, .-_start
```

使用 `-nostdlib` 选项避免链接标准库：

```bash
# 编译启动代码
$RISCV_GCC -march=$RISCV_ARCH -mabi=$RISCV_ABI -c crt0.s -o crt0.o

# 链接可执行文件（不使用标准库）
$RISCV_GCC -march=$RISCV_ARCH -mabi=$RISCV_ABI -nostdlib \
    crt0.o program.s -o program
```

#### 技术要点

**RISC-V Linux 系统调用约定**

| 寄存器 | 用途 |
|--------|------|
| a0-a5  | 系统调用参数 |
| a7     | 系统调用号 |
| a0     | 返回值 |

常用系统调用号：
- `exit`: 93
- `write`: 64
- `read`: 63

---

### 问题 4: Clang 汇编与 GNU 汇编器不兼容

#### 现象

```
test/asm/01_minimal_clang.s: Assembler messages:
test/asm/01_minimal_clang.s:25: Error: unknown pseudo-op: `.addrsig'
```

#### 原因分析

Clang 生成的 RISC-V 汇编包含一些 LLVM 特有的伪指令，GNU 汇编器不支持：

```asm
; Clang 生成的汇编中包含这些不兼容的指令
	.attribute	4, 16
	.attribute	5, "rv32i2p1"
	.ident	"Ubuntu clang version 18.1.3"
	.addrsig                              ; ❌ GNU as 不支持
```

#### 解决方案

在编译前过滤掉不支持的伪指令：

```bash
# 处理 Clang 汇编（移除 GNU 汇编器不支持的伪指令）
clang_asm_filtered="$TEMP_DIR/${base}_clang_filtered.s"
grep -v '\.addrsig\|\.ident\|\.attribute' "$clang_asm" > "$clang_asm_filtered"

# 使用过滤后的文件编译
$RISCV_GCC ... "$clang_asm_filtered" -o "$clang_exe"
```

#### 技术要点

**不兼容伪指令说明**

| 伪指令 | 来源 | 用途 | 是否必需 |
|--------|------|------|----------|
| `.addrsig` | LLVM | 地址签名（安全特性） | 否 |
| `.ident` | Clang | 编译器标识 | 否 |
| `.attribute` | RISC-V | 架构属性 | 否（GNU as 有自己的方式） |

这些伪指令都是元数据，不影响实际代码执行，可以安全过滤。

---

### 问题 5: 软件除法函数缺失

#### 现象

```
undefined reference to `__divsi3'
```

#### 原因分析

RV32I 基础指令集不包含硬件除法指令。Clang 在编译除法操作时会调用 libgcc 中的软件实现：

```c
// 源代码
int result = a / b;

// Clang 生成的汇编（无硬件除法）
call __divsi3    ; 调用软件除法函数
```

使用 `-nostdlib` 时，libgcc 也不会被链接，导致找不到 `__divsi3`。

#### 解决方案

添加 `-lgcc` 选项链接 libgcc：

```bash
$RISCV_GCC -march=$RISCV_ARCH -mabi=$RISCV_ABI -nostdlib \
    "$CRT0_OBJ" "$asm_file" -o "$exe_file" -lgcc
```

#### 技术要点

**libgcc 中的软件实现函数**

| 函数 | 功能 |
|------|------|
| `__divsi3` | 32 位有符号除法 |
| `__udivsi3` | 32 位无符号除法 |
| `__modsi3` | 32 位有符号取模 |
| `__umodsi3` | 32 位无符号取模 |
| `__mulsi3` | 32 位乘法（某些架构） |

**ToyC 为什么不需要这些函数？**

ToyC 生成的代码使用 RV32IM（带 M 扩展）的硬件指令：

```asm
; ToyC 生成的除法代码
div     a0, a1, a2    ; 使用硬件 div 指令
rem     a0, a1, a2    ; 使用硬件 rem 指令
```

这是因为 ToyC 直接生成汇编，可以使用 M 扩展指令。而 Clang 使用 `-march=rv32i` 时默认不使用 M 扩展。

---

### 问题 6: QEMU 用户模式运行问题

#### 现象

所有程序返回退出码 139（SIGSEGV）。

#### 原因分析

初版 crt0.s 使用了固定的栈地址：

```asm
_start:
    li      sp, 0x80100000    ; ❌ 硬编码地址在 QEMU 中无效
    call    main
```

这个地址在 QEMU 用户模式下不一定可用，导致访问非法内存。

#### 解决方案

使用 QEMU 提供的栈指针，只做必要的调整：

```asm
_start:
    # QEMU 用户模式会提供有效的 sp
    addi    sp, sp, -16       ; ✅ 只分配少量栈空间
    call    main
```

#### 技术要点

**QEMU 用户模式 vs 系统模式**

| 特性 | 用户模式 | 系统模式 |
|------|----------|----------|
| 模拟范围 | 仅 CPU 指令 | 完整系统 |
| 系统调用 | 转发给主机内核 | 模拟 |
| 内存布局 | 使用主机进程空间 | 完全模拟 |
| 启动方式 | 直接运行 ELF | 需要 bootloader |
| 适用场景 | 简单程序测试 | 操作系统开发 |

对于编译器验证，用户模式更简单高效。

---

## 4. 关键技术讲解

### 4.1 RISC-V 调用约定

#### 寄存器分配

| 寄存器 | ABI 名称 | 用途 | 调用者/被调用者保存 |
|--------|----------|------|---------------------|
| x0 | zero | 硬件零寄存器 | - |
| x1 | ra | 返回地址 | 调用者 |
| x2 | sp | 栈指针 | 被调用者 |
| x3 | gp | 全局指针 | - |
| x4 | tp | 线程指针 | - |
| x5-x7 | t0-t2 | 临时寄存器 | 调用者 |
| x8 | s0/fp | 帧指针 | 被调用者 |
| x9 | s1 | 保存寄存器 | 被调用者 |
| x10-x11 | a0-a1 | 参数/返回值 | 调用者 |
| x12-x17 | a2-a7 | 参数寄存器 | 调用者 |
| x18-x27 | s2-s11 | 保存寄存器 | 被调用者 |
| x28-x31 | t3-t6 | 临时寄存器 | 调用者 |

#### 函数调用序列

```asm
; 调用者
    ; 1. 传递参数（前 8 个通过 a0-a7）
    li      a0, 10          ; 第一个参数
    li      a1, 20          ; 第二个参数
    
    ; 2. 调用函数
    call    add             ; 相当于 jal ra, add
    
    ; 3. 使用返回值（在 a0 中）
    mv      t0, a0

; 被调用者
add:
    ; 4. 保存被调用者保存寄存器
    addi    sp, sp, -16
    sw      ra, 12(sp)
    sw      s0, 8(sp)
    addi    s0, sp, 16
    
    ; 5. 函数体
    add     a0, a0, a1      ; 计算 a0 + a1
    
    ; 6. 恢复寄存器并返回
    lw      ra, 12(sp)
    lw      s0, 8(sp)
    addi    sp, sp, 16
    ret                     ; 相当于 jalr x0, ra, 0
```

### 4.2 ELF 可执行文件入口点

#### _start vs main

- `_start`：程序真正的入口点，由链接器设置
- `main`：用户代码入口点，由 `_start` 调用

标准 C 程序的启动流程：

```
_start (crt0.o)
    ↓
__libc_start_main (libc)
    ↓
main (用户代码)
    ↓
exit (libc)
    ↓
_exit (系统调用)
```

我们的简化流程：

```
_start (crt0.s)
    ↓
main (用户代码)
    ↓
ecall exit (直接系统调用)
```

### 4.3 裸机编程要点

#### -nostdlib 选项

禁用所有标准库链接，需要自己提供：
- 启动代码（`_start`）
- 系统调用接口
- 如果需要，手动链接 `-lgcc`

#### 最小化 crt0 实现

```asm
    .text
    .globl _start
_start:
    # 1. 初始化栈（QEMU 用户模式已提供）
    addi    sp, sp, -16
    
    # 2. 调用 main
    call    main
    
    # 3. 退出（使用 Linux syscall）
    li      a7, 93          # sys_exit
    ecall
```

---

## 5. 最终实现

### 5.1 验证脚本核心逻辑

```bash
#!/usr/bin/env bash
set -eu

# 1. 检测工具链
if command -v riscv32-unknown-elf-gcc >/dev/null 2>&1; then
  RISCV_GCC="riscv32-unknown-elf-gcc"
elif command -v riscv64-unknown-elf-gcc >/dev/null 2>&1; then
  RISCV_GCC="riscv64-unknown-elf-gcc"
fi

# 2. 编译启动代码
$RISCV_GCC -march=rv32im -mabi=ilp32 -c crt0.s -o crt0.o

# 3. 遍历测试文件
for c_file in "$SRC_DIR"/*.c; do
  base="$(basename "$c_file" .c)"
  
  # 4. 编译 ToyC 汇编
  $RISCV_GCC -march=rv32im -mabi=ilp32 -nostdlib \
      crt0.o "${base}_toyc.s" -o "${base}_toyc" -lgcc
  
  # 5. 过滤并编译 Clang 汇编
  grep -v '\.addrsig\|\.ident\|\.attribute' "${base}_clang.s" > filtered.s
  $RISCV_GCC -march=rv32im -mabi=ilp32 -nostdlib \
      crt0.o filtered.s -o "${base}_clang" -lgcc
  
  # 6. 运行并对比
  toyc_exit=$($QEMU "${base}_toyc"; echo $?)
  clang_exit=$($QEMU "${base}_clang"; echo $?)
  
  if [[ "$toyc_exit" == "$clang_exit" ]]; then
    echo "✅ CORRECT"
  else
    echo "❌ INCORRECT"
  fi
done
```

### 5.2 Makefile 集成

```makefile
# 默认测试目录
TEST_SRC_DIR ?= examples/compiler_inputs

# 验证目标
verify: test
	@echo "Running output verification..."
	@bash scripts/verify_output.sh "$(TEST_SRC_DIR)"
```

### 5.3 使用方式

```bash
# 验证默认目录
make verify

# 验证自定义目录
make verify TEST_SRC_DIR=examples/single_func

# 直接运行脚本
bash scripts/verify_output.sh path/to/tests
```

---

## 6. 总结

### 问题解决清单

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 汇编缺少 ret | generateReturn 逻辑错误 | 修复代码生成逻辑 |
| 找不到 riscv32-gcc | 包名不同 | 自动检测工具链 |
| 缺少 crt0.o | 无 RV32 运行时 | 自定义启动代码 |
| .addrsig 不支持 | Clang 特有指令 | grep 过滤 |
| __divsi3 未定义 | 软件除法缺失 | 链接 -lgcc |
| 返回码 139 | 栈地址无效 | 使用 QEMU 提供的栈 |

### 关键技术点

1. **RISC-V 交叉编译**：工具链选择、架构参数、ABI 设置
2. **裸机编程**：启动代码、系统调用、-nostdlib 使用
3. **QEMU 用户模式**：程序运行、退出码获取
4. **汇编兼容性**：不同汇编器的差异处理
5. **代码生成验证**：对比测试方法论

### 经验教训

1. **边界条件很重要**：`return 0` 这种常见情况反而容易被忽视
2. **环境差异要考虑**：不同系统的工具链名称可能不同
3. **最小化依赖**：使用 -nostdlib + 自定义 crt0 可以避免复杂的运行时依赖
4. **工具兼容性**：不同工具链（Clang vs GCC）生成的代码可能有细微差异

---

## 附录

### A. 完整文件列表

- `src/riscv_gen.cpp`：代码生成器（已修复）
- `scripts/verify_output.sh`：验证脚本
- `scripts/crt0.s`：启动代码
- `Makefile`：构建脚本

### B. 参考资料

- [RISC-V Calling Convention](https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf)
- [RISC-V Assembly Programmer's Manual](https://github.com/riscv/riscv-asm-manual)
- [QEMU User Mode Emulation](https://www.qemu.org/docs/master/user/main.html)
- [GCC Linking Options](https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html)
