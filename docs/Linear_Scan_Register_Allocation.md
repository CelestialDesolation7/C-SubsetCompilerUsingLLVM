# 线性扫描寄存器分配算法实现

## 概述

### 自然语言概括

线性扫描寄存器分配请求函数：
如果程序请求一个存放数据的位置，调用该函数以决定存放到何处。

```bash
LinearScanRegisterAllocation (i) -> 一个空闲寄存器地址 | 一个空闲栈空间地址
	维护一个名为 active 的活动区间集合，初始为空
	对于按起始点位置升序排列的，所有活动区间集合 AllInterval 中的每个活动区间 i 执行操作：
		调用函数 ExpireOldIntervals (i) 以释放所有不会再被使用的寄存器
		如果 (active 集合的元素数 = 寄存器总数 R)
		那么{ 
			// 我们知道所有寄存器都被未过期变量占用
			// 且由于本算法正在被调用，有一个新变量需要立即获得一个物理寄存器
			// 换而言之，发生溢出，需要将一个寄存器中的数据暂存到栈
			return SpillAtIntervals (i)
		}
		否则{
			// 我们决定从空闲寄存器池中取出一个寄存器分配给活跃区间 i 
			将 i 加入 active 集合中，按结束点位置升序排列；
			return 分配到的寄存器地址
		}
```

活动区间是一个Struct，名称为 i ，记录了三项数据：

- 一个对应的虚拟寄存器 %i ；
- 它首次被使用的位置 StartPoint；
- 它最后一次被使用的位置 EndPoint。

一个活动区间 i 在 active 集合中时，它必定满足以下性质：

- 编译器正在处理的指令位置（可以以行数表示），位于 i 的 StartPoint 和 EndPoint 之间；
- 其对应的 %i 的物理值位于物理寄存器中，而不是在栈上。

为了便于算法处理，我们要求：

- 名为 active 的活动区间集合，必须自发按结束点位置升序排列。

```bash
ExpireOldIntervals (i) -> void
	对于按结束点位置升序排列的 active 集合中的每一个活跃区间 j：
		如果 (j.EndPoint 在 i.StartPoint 的后方)
		那么{
			// 我们知道这一个 j 还没有过期，不能移除
			// 由于我们正在遍历按结束点位置升序排列的 active 集合
			// 以后遍历的所有 j 都不会是过期的，无法移除
			没有更多的寄存器可以被释放，此次函数调用结束
			return
		}
		否则{
			// 我们知道这一个 j 过期了，它占用的物理寄存器需要释放
			将 j 从 active 集合中移除
			将 j 正在占用的物理寄存器归还到空闲寄存器池中
			继续检查下一个 j 是否过期
		}
	return
```

 ```bash
 SpillAtInterval (i) -> 一个空闲寄存器地址 | 一个空闲栈空间地址
 	定义一个临时变量 spill ，它指向 active 中结束点最靠后的活跃区间
 	如果 (spill.EndPoint 在 i.EndPoint 的后方)
 	那么{
 		// 我们知道 spill 对应的数据将晚于 i 的失效
 		// 换而言之，它将晚于 i 被使用，更"不急切地"需要寄存器
 		// 所以将 spill 先放置到栈上代价较小
 		// 我们决定将 spill 的寄存器分配给 i
 		将 spill 溢出到内存，为其分配一个新的栈空间
 		从 active 中移除 spill
 		将 i 加入 active，按结束点升序排列
 		return spill 释放出的物理寄存器地址
 	}
 	否则{
 		// 我们知道 spill 对应的数据将早于 i 的失效
 		// 换而言之，它将先于 i 被使用，更"急切地"需要寄存器
 		// 所以拒绝给 i 一个物理寄存器，只给其提供一个栈空间用于 store 数据以待使用
 		return 一个空闲栈空间
 	}
 ```

以上函数的意义是实现"最小代价的溢出"。
这个算法以 **线性地遍历活跃区间** 为核心，保持 `active` 集合中为当前最活跃、最短命（即最早结束最后一次使用而可以释放空闲寄存器）的一组变量分配寄存器，从而实现高效、实时的寄存器分配。

---
