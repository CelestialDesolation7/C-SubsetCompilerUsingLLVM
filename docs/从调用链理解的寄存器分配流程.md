# 从调用链理解的寄存器分配流程

## 总览：入口函数调用栈

```
LinearScanAllocator::allocate(Function &F)          // 主入口
├─ processParameters(F.paramVregs)                   // 1. 处理函数参数
├─ LivenessAnalysis::run(F)                          // 2. 活跃性分析
│  ├─ F.buildCFG()                                   //    2.0 构建控制流图
│  ├─ computeUseDefSets(F)                           //    2.1 计算 use/def 集合
│  ├─ buildRPO(F.entryBlock())                       //    2.2 构建逆后序遍历
│  └─ computeLivenessIteratively(F)                  //    2.3 迭代求解 liveIn/liveOut
├─ assignInstrPositions(F)                           // 3. 指令线性化编号
├─ LiveIntervalBuilder::build()                      // 4. 构建活跃区间
│  └─ buildIntervalForVreg(vreg, interval)           //    4.1 为每个虚拟寄存器构建区间
│     └─ (or buildSimplifiedIntervalForVreg)         //    4.2 简化模式（点区间）
└─ runLinearScan(intervals)                          // 5. 执行线性扫描分配
   ├─ sortIntervalsByStart(sorted)                   //    5.1 按起始位置排序
   └─ for each interval:
      ├─ expireOldIntervals(interval.start())        //    5.2 释放过期区间
      ├─ allocatePhysicalReg(interval)               //    5.3 分配物理寄存器
      │  └─ insertActiveInterval(&interval)          //        插入 active 列表
      └─ spillAtInterval(interval)                   //    5.4 溢出处理
         └─ allocateSpillSlot()                      //        分配溢出栈槽
```

所有代码位于 [reg_alloc.h](../src/include/reg_alloc.h) 和 [reg_alloc.cpp](../src/reg_alloc.cpp) 中，命名空间为 `toyc`。

---

## 预备知识：物理寄存器模型

在进入分配流程之前，先了解 `RegInfo` 如何描述 RISC-V32 的 32 个物理寄存器。

### PhysReg 结构

```cpp
// [reg_alloc.h](../src/include/reg_alloc.h)

struct PhysReg {
    int id;               // 寄存器编号 (0-31)
    std::string name;     // 寄存器名 ("a0", "s1", "t2", ...)
    bool callerSaved;     // 是否为调用者保存
    bool calleeSaved;     // 是否为被调用者保存
    bool reserved;        // 是否保留（不参与分配）
    int priority;         // 分配优先级（越小越优先）
};
```

### RegInfo 构造

```cpp
// [reg_alloc.cpp](../src/reg_alloc.cpp)

RegInfo::RegInfo() : allocatableRegs(PhysRegComparator(&physRegs)) {
    physRegs.resize(32);

    // 保留寄存器（不参与分配，priority=999）
    physRegs[0]  = PhysReg(0,  "zero", ..., true,  999);  // x0  硬连线 0
    physRegs[1]  = PhysReg(1,  "ra",   ..., true,  999);  // x1  返回地址
    physRegs[2]  = PhysReg(2,  "sp",   ..., true,  999);  // x2  栈指针
    physRegs[3]  = PhysReg(3,  "gp",   ..., true,  999);  // x3  全局指针
    physRegs[4]  = PhysReg(4,  "tp",   ..., true,  999);  // x4  线程指针
    physRegs[5]  = PhysReg(5,  "t0",   ..., true,  999);  // x5  溢出临时 1
    physRegs[6]  = PhysReg(6,  "t1",   ..., true,  999);  // x6  溢出临时 2
    physRegs[8]  = PhysReg(8,  "s0",   ..., true,  999);  // x8  帧指针

    // 可分配寄存器（按优先级排序）
    physRegs[10] = PhysReg(10, "a0",  true,  false, false, 0);   // 最优先
    physRegs[11] = PhysReg(11, "a1",  true,  false, false, 1);
    // ... a2-a7 优先级 2-7
    physRegs[7]  = PhysReg(7,  "t2",  true,  false, false, 20);
    physRegs[28] = PhysReg(28, "t3",  true,  false, false, 21);
    // ... t4-t6 优先级 22-24
    physRegs[18] = PhysReg(18, "s2",  false, true,  false, 40);
    // ... s3-s11 优先级 41-49
    physRegs[9]  = PhysReg(9,  "s1",  false, true,  false, 50);

    // 构建可分配寄存器集合（自动按优先级排序）
    for (int i = 0; i < 32; ++i)
        if (!physRegs[i].reserved)
            allocatableRegs.insert(i);
}
```

**分配优先级策略**：
- a0-a7（优先级 0-7）最先分配 — 参数寄存器，caller-saved 代价低
- t2-t6（优先级 20-24）次之 — 临时寄存器，caller-saved
- s2-s11, s1（优先级 40-50）最后 — callee-saved 需额外保存/恢复开销

`allocatableRegs` 使用 `PhysRegComparator` 排序的 `std::set<int>`，`begin()` 始终返回优先级最高的可用寄存器。

---

## 阶段 1：处理函数参数

### processParameters()

```cpp
// [reg_alloc.cpp](../src/reg_alloc.cpp)

void LinearScanAllocator::processParameters(const std::vector<int> &paramVregs) {
    for (size_t i = 0; i < paramVregs.size(); ++i) {
        int vreg = paramVregs[i];
        if (i < 8) {
            // 前 8 个参数绑定到 a0-a7 (x10-x17)
            int argReg = 10 + static_cast<int>(i);   // a0=x10, a1=x11, ...
            result_.vregToPhys[vreg] = argReg;        // vreg → 物理寄存器映射
            result_.paramVregToLocation[vreg] = argReg;
            isPhysRegUsed_[argReg] = true;            // 标记已使用
            freePhysRegs_.erase(argReg);              // 从空闲池移除
            allocatedVregs_.insert(vreg);             // 标记已分配
        } else {
            // 超过 8 个参数 → 栈传递
            int stackOffset = static_cast<int>(i - 8 + 1) * 4;
            result_.vregToStack[vreg] = stackOffset;
            result_.paramVregToLocation[vreg] = stackOffset;
            allocatedVregs_.insert(vreg);
        }
    }
}
```

**示例**：函数 `int add(int a, int b)` 的参数：
- `paramVregs = [0, 1]`（%0 = a, %1 = b）
- 处理后：`vregToPhys[0] = 10(a0)`, `vregToPhys[1] = 11(a1)`
- a0, a1 从 `freePhysRegs_` 中移除

**关键点**：参数寄存器在分配阶段就已预占（pre-allocated），后续线性扫描遇到这些 vreg 时只需插入 active 列表。

---

## 阶段 2：活跃性分析

### LivenessAnalysis::run()

```cpp
// [reg_alloc.cpp](../src/reg_alloc.cpp)

void LivenessAnalysis::run(ir::Function &F) {
    F.buildCFG();                          // 2.0 构建控制流图
    computeUseDefSets(F);                  // 2.1 计算 use/def 集合
    F.rpoOrder = buildRPO(F.entryBlock()); // 2.2 构建逆后序遍历
    computeLivenessIteratively(F);         // 2.3 迭代求解
}
```

### 2.0 构建控制流图 — F.buildCFG()

```cpp
// [ir.h](../src/include/ir.h) — Function::buildCFG()

void Function::buildCFG() {
    // 清空所有 succs/preds
    for (auto &bb : blocks) {
        bb->succs.clear();
        bb->preds.clear();
    }
    // 分析每个基本块的终结指令
    for (auto &bb : blocks) {
        for (auto &inst : bb->insts) {
            if (inst->isTerminator()) {
                // 获取分支目标标签列表
                for (auto &target : inst->branchTargets()) {
                    BasicBlock *succBB = blockMap[target];
                    bb->succs.push_back(succBB);
                    succBB->preds.push_back(bb.get());
                }
            }
        }
    }
}
```

**输入**：函数的所有基本块及其指令（已包含 `Br`/`CondBr`/`Ret` 等终结指令）

**输出**：每个 `BasicBlock` 的 `succs`（后继）和 `preds`（前驱）列表

**关键接口**：`Instruction::branchTargets()` 根据 opcode 返回目标标签：
- `Br` → `[ops[0].labelName()]`
- `CondBr` → `[ops[1].labelName(), ops[2].labelName()]`
- `Ret`/`RetVoid` → `[]`（无后继）

### 2.1 计算 use/def 集合 — computeUseDefSets()

```cpp
void LivenessAnalysis::computeUseDefSets(ir::Function &F) {
    for (auto &block : F.blocks) {
        block->useSet.clear();
        block->defSet.clear();
        block->liveIn.clear();
        block->liveOut.clear();

        std::set<int> localDef;
        for (auto &inst : block->insts) {
            // 先处理 use（use-before-def 语义）
            for (int u : inst->useRegs()) {
                if (localDef.find(u) == localDef.end())
                    block->useSet.insert(u);      // 未被本块定义 → use
            }
            // 再处理 def
            int d = inst->defReg();
            if (d != -1) {
                block->defSet.insert(d);
                localDef.insert(d);
            }
        }
    }
}
```

**use-before-def 语义**：只有当某个寄存器在本块中**先被使用**、**后被定义**（或本块中只有使用没有定义）时，才计入 `useSet`。

**示例**：对于基本块：
```llvm
  %5 = load i32, ptr %4       ; def: %5, use: %4
  %6 = add i32 %5, 2          ; def: %6, use: %5
  store i32 %6, ptr %4        ; use: %6, %4
```
- `useSet = {%4}` — %4 在本块定义前被使用
- `defSet = {%5, %6}` — %5 使用时 localDef 已有 %5（由上一条定义），不计入 useSet

**关键接口**：
- `Instruction::useRegs()` — 根据 opcode 返回使用的虚拟寄存器 ID 列表
- `Instruction::defReg()` — 根据 opcode 返回定义的虚拟寄存器 ID（-1 表示无定义）

### 2.2 构建逆后序 — buildRPO()

```cpp
std::vector<ir::BasicBlock*> LivenessAnalysis::buildRPO(ir::BasicBlock *entry) {
    std::vector<ir::BasicBlock*> order;
    std::unordered_set<ir::BasicBlock*> visited;
    std::stack<std::pair<ir::BasicBlock*, bool>> stk;
    stk.push({entry, false});

    while (!stk.empty()) {
        auto [bb, processed] = stk.top();
        stk.pop();
        if (processed) {
            order.push_back(bb);     // 后序收集
            continue;
        }
        if (!visited.insert(bb).second)
            continue;
        stk.push({bb, true});        // 标记为待后序收集
        for (auto it = bb->succs.rbegin(); it != bb->succs.rend(); ++it)
            if (visited.find(*it) == visited.end())
                stk.push({*it, false});
    }
    std::reverse(order.begin(), order.end());  // 反转得到 RPO
    return order;
}
```

**算法**：非递归 DFS → 后序收集 → 反转 = 逆后序（RPO）

**示例**：对于包含 while 循环的函数：
```
entry → while_cond → while_body → while_cond (回边)
                   → while_end
```
RPO 顺序：`[entry, while_cond, while_body, while_end]`

**为什么需要 RPO**：数据流分析按 RPO 顺序遍历能保证在处理某个块时，其所有前驱（回边除外）已处理完毕，加快收敛。

### 2.3 迭代求解 liveIn/liveOut — computeLivenessIteratively()

```cpp
void LivenessAnalysis::computeLivenessIteratively(ir::Function &F) {
    bool changed = true;
    while (changed) {
        changed = false;
        // 反向遍历 RPO 序列
        for (int i = static_cast<int>(F.rpoOrder.size()) - 1; i >= 0; --i) {
            auto *bb = F.rpoOrder[i];

            // 数据流方程 1: liveOut = ∪ liveIn(S), S ∈ succ(bb)
            std::set<int> newLiveOut;
            for (auto *succ : bb->succs)
                newLiveOut.insert(succ->liveIn.begin(), succ->liveIn.end());

            // 数据流方程 2: liveIn = useSet ∪ (liveOut - defSet)
            std::set<int> newLiveIn = bb->useSet;
            for (int v : newLiveOut)
                if (bb->defSet.find(v) == bb->defSet.end())
                    newLiveIn.insert(v);

            // 检查是否有变化
            if (newLiveIn != bb->liveIn || newLiveOut != bb->liveOut) {
                bb->liveIn = newLiveIn;
                bb->liveOut = newLiveOut;
                changed = true;
            }
        }
    }
}
```

**数据流方程**：

$$
\text{liveOut}(B) = \bigcup_{S \in \text{succ}(B)} \text{liveIn}(S)
$$

$$
\text{liveIn}(B) = \text{useSet}(B) \cup (\text{liveOut}(B) - \text{defSet}(B))
$$

**迭代方向**：反向遍历 RPO（即从出口块向入口块迭代），因为活跃性信息从后继向前驱传播。反复迭代直到不动点（所有 liveIn/liveOut 不再变化）。

**示例**：对于包含循环的 CFG，假设 `while_body` 使用了 `%3`，循环回到 `while_cond`：
- 第 1 轮：`while_body.liveIn` 包含 `%3`，传播到 `while_cond.liveOut`
- 第 2 轮：`while_cond.liveIn` 更新（若 %3 不在 defSet 中则保留），传播到 `entry.liveOut`
- 第 3 轮：稳定，终止

---

## 阶段 3：指令线性化编号

### assignInstrPositions()

```cpp
void LinearScanAllocator::assignInstrPositions(ir::Function &F) {
    int pos = 0;
    for (auto *block : F.rpoOrder) {
        for (auto &inst : block->insts) {
            inst->index = pos++;
            inst->blockId = block->id;
        }
    }
}
```

**作用**：按 RPO 顺序为每条指令分配连续的全局编号。

**位置映射**：每条指令占据两个位置点（用于区分定义和使用）：
```cpp
int posDef() const { return index * 2; }     // 偶数：定义点
int posUse() const { return index * 2 + 1; } // 奇数：使用点
```

**示例**：
```
指令              index   posDef  posUse
%3 = alloca i32    0        0       1
store i32 0, %3    1        2       3
%4 = alloca i32    2        4       5
store i32 1, %4    3        6       7
%5 = load i32, %4  4        8       9
%6 = add %5, 2     5       10      11
store %6, %4       6       12      13
%7 = load i32, %4  7       14      15
ret i32 %7         8       16      17
```

---

## 阶段 4：构建活跃区间

### LiveIntervalBuilder::build()

```cpp
std::unordered_map<int, std::unique_ptr<LiveInterval>> LiveIntervalBuilder::build() {
    std::unordered_map<int, std::unique_ptr<LiveInterval>> intervals;
    for (int vreg = 0; vreg <= F_.maxVregId; ++vreg) {
        auto interval = std::make_unique<LiveInterval>(vreg);
        if (splitting_)
            buildSimplifiedIntervalForVreg(vreg, interval);
        else
            buildIntervalForVreg(vreg, interval);
        if (!interval->empty())
            intervals[vreg] = std::move(interval);
    }
    return intervals;
}
```

遍历所有虚拟寄存器，为每个构建 `LiveInterval`（由多个 `LiveRange` 组成）。

### buildIntervalForVreg() — 精确模式

```cpp
void LiveIntervalBuilder::buildIntervalForVreg(int vreg, std::unique_ptr<LiveInterval> &interval) {
    for (auto *bb : F_.rpoOrder) {
        bool liveAtStart = bb->liveIn.count(vreg) > 0;
        bool liveAtEnd = bb->liveOut.count(vreg) > 0;

        // 跳过不相关的块
        if (!liveAtStart && !liveAtEnd) {
            bool hasDefUse = false;
            for (auto &inst : bb->insts) {
                if (inst->defReg() == vreg) { hasDefUse = true; break; }
                for (int u : inst->useRegs())
                    if (u == vreg) { hasDefUse = true; break; }
                if (hasDefUse) break;
            }
            if (!hasDefUse) continue;
        }

        // 确定范围起止
        int rangeStart = liveAtStart ? bb->firstPos() : -1;
        int rangeEnd = liveAtEnd ? bb->lastPos() : -1;

        for (auto &inst : bb->insts) {
            if (inst->defReg() == vreg) {           // def
                if (rangeStart == -1) rangeStart = inst->posDef();
                rangeEnd = liveAtEnd ? bb->lastPos() : inst->posDef();
            }
            for (int u : inst->useRegs()) {         // use
                if (u == vreg) {
                    if (rangeStart == -1)
                        rangeStart = liveAtStart ? bb->firstPos() : inst->posUse();
                    rangeEnd = std::max(rangeEnd, inst->posUse());
                    break;
                }
            }
        }

        if (rangeStart != -1 && rangeEnd != -1)
            interval->addRange(rangeStart, rangeEnd);
    }
}
```

**逻辑详解**：

对于每个基本块，结合 `liveIn`/`liveOut` 信息和块内的 def/use 位置，精确计算 vreg 的活跃范围：

| 场景 | liveIn | liveOut | 范围 |
|------|--------|---------|------|
| 穿越块（无 def/use） | ✓ | ✓ | `[bb.firstPos, bb.lastPos]` |
| 定义后活跃出块 | ✗ | ✓ | `[def.posDef, bb.lastPos]` |
| 活跃入块后使用 | ✓ | ✗ | `[bb.firstPos, use.posUse]` |
| 定义并使用在同一块 | ✗ | ✗ | `[def.posDef, use.posUse]` |

### LiveInterval 与 LiveRange

```cpp
struct LiveRange {
    int start, end;
    bool overlaps(const LiveRange &other) const;
    bool adjacent(const LiveRange &other) const;
};

class LiveInterval {
    int vreg;                        // 对应的虚拟寄存器
    std::vector<LiveRange> ranges;   // 活跃范围列表
    int physReg = -1;                // 分配的物理寄存器
    int spillSlot = -1;              // 溢出栈槽

    void addRange(int s, int e);     // 添加范围（自动合并重叠/相邻）
    bool contains(int pos) const;
    int start() const;               // 最早起始位置
    int end() const;                 // 最晚结束位置
};
```

`addRange()` 会自动合并重叠或相邻的 `LiveRange`，保持 `ranges` 有序且无重叠。

**示例**：对于前面的 IR，`%5` 的活跃区间：
```
%5 = load i32, ptr %4   ; 定义点 posDef = 8
%6 = add i32 %5, 2      ; 使用点 posUse = 11
→ LiveInterval(%5): ranges = [(8, 11)]
```

---

## 阶段 5：执行线性扫描分配

### runLinearScan()

```cpp
AllocationResult LinearScanAllocator::runLinearScan(
    const std::unordered_map<int, std::unique_ptr<LiveInterval>> &intervals) {

    // 5.1 按起始位置排序
    std::vector<LiveInterval*> sorted;
    for (auto &[vreg, iv] : intervals)
        sorted.push_back(iv.get());
    sortIntervalsByStart(sorted);

    // 5.2 遍历每个区间
    for (auto *interval : sorted) {
        expireOldIntervals(interval->start());

        // 已预分配（参数寄存器）的区间
        if (allocatedVregs_.count(interval->vreg)) {
            if (result_.vregToPhys.count(interval->vreg))
                insertActiveInterval(interval);
            continue;
        }

        // 尝试分配
        if (freePhysRegs_.empty()) {
            spillAtInterval(*interval);      // 无空闲 → 溢出
        } else {
            allocatePhysicalReg(*interval);  // 分配物理寄存器
            allocatedVregs_.insert(interval->vreg);
        }
    }
    return result_;
}
```

### expireOldIntervals() — 释放过期区间

```cpp
void LinearScanAllocator::expireOldIntervals(int curStart) {
    auto it = active_.begin();
    while (it != active_.end()) {
        if ((*it)->end() < curStart) {
            freePhysReg((*it)->physReg);     // 归还物理寄存器到空闲池
            it = active_.erase(it);
        } else {
            break;   // active_ 按结束位置排序，后续只会更晚
        }
    }
}
```

`active_` 列表按 `end()` 升序排列，因此只需从头部开始检查。

### allocatePhysicalReg() — 分配物理寄存器

```cpp
void LinearScanAllocator::allocatePhysicalReg(LiveInterval &interval) {
    int physReg = allocatePhysReg();         // 从空闲池取优先级最高的
    interval.physReg = physReg;
    result_.vregToPhys[interval.vreg] = physReg;
    insertActiveInterval(&interval);
}

int LinearScanAllocator::allocatePhysReg() {
    int reg = *freePhysRegs_.begin();        // 优先级最高（a0 > a1 > ... > s1）
    freePhysRegs_.erase(freePhysRegs_.begin());
    isPhysRegUsed_[reg] = true;
    return reg;
}
```

### insertActiveInterval() — 有序插入 active 列表

```cpp
void LinearScanAllocator::insertActiveInterval(LiveInterval *interval) {
    auto it = std::lower_bound(active_.begin(), active_.end(), interval,
        [](LiveInterval *a, LiveInterval *b) { return a->end() < b->end(); });
    active_.insert(it, interval);
}
```

保持 `active_` 按 `end()` 升序，便于 `expireOldIntervals` 高效释放。

### spillAtInterval() — 溢出处理

```cpp
void LinearScanAllocator::spillAtInterval(LiveInterval &interval) {
    if (!active_.empty()) {
        // 找到 active 中结束位置最晚的区间
        auto spillIt = std::max_element(active_.begin(), active_.end(),
            [](LiveInterval *a, LiveInterval *b) { return a->end() < b->end(); });
        LiveInterval *spill = *spillIt;

        if (spill->end() > interval.end()) {
            // 溢出 active 中的区间，将其物理寄存器转给当前区间
            int physReg = spill->physReg;

            spill->physReg = -1;
            spill->spillSlot = allocateSpillSlot();
            result_.vregToPhys.erase(spill->vreg);
            result_.vregToStack[spill->vreg] = spill->spillSlot;
            active_.erase(spillIt);

            interval.physReg = physReg;
            result_.vregToPhys[interval.vreg] = physReg;
            insertActiveInterval(&interval);
            return;
        }
    }
    // 直接溢出当前区间
    interval.spillSlot = allocateSpillSlot();
    result_.vregToStack[interval.vreg] = interval.spillSlot;
}
```

**溢出策略**：

1. 如果 `active_` 中有区间的结束位置比当前区间更晚 → **溢出那个区间**（因为当前区间更短，占用寄存器的时间更少，总体溢出代价更低）
2. 否则 → **直接溢出当前区间**

```
溢出前:
  active:   [a0: ████████████████] (结束很晚)
  当前:     [??:     ████]        (结束较早)
  空闲:     (无)

溢出后:
  active:   [a0:     ████]        (当前占用 a0)
  溢出:     [栈: ████████████████] (原 active 溢出到栈)
```

### allocateSpillSlot() — 分配溢出栈槽

```cpp
int LinearScanAllocator::allocateSpillSlot() {
    return -(++nextSpillSlot_) * 4;   // -4, -8, -12, ...
}
```

返回负偏移量，由 `RISCVCodeGen` 在代码生成时转换为 `offset(sp)` 形式的栈访问。

---

## 阶段 6：收集使用信息

```cpp
// allocate() 末尾
result_.usedPhysRegs = getUsedPhysRegs();
result_.calleeSavedRegs = getCalleeSavedRegs();
```

```cpp
std::set<int> LinearScanAllocator::getUsedPhysRegs() const {
    std::set<int> used;
    for (int i = 0; i < 32; ++i)
        if (isPhysRegUsed_[i]) used.insert(i);
    return used;
}

std::set<int> LinearScanAllocator::getCalleeSavedRegs() const {
    std::set<int> callee;
    for (int i = 0; i < 32; ++i)
        if (isPhysRegUsed_[i] && regInfo_.isCalleeSaved(i)) callee.insert(i);
    return callee;
}
```

`calleeSavedRegs` 告诉代码生成器需要在 prologue 中保存、在 epilogue 中恢复哪些 callee-saved 寄存器（s1, s2, ...）。

---

## 完整分配结果 (AllocationResult)

```cpp
// [reg_alloc.h](../src/include/reg_alloc.h)

struct AllocationResult {
    std::unordered_map<int, int> vregToPhys;       // vreg → 物理寄存器 ID
    std::unordered_map<int, int> vregToStack;      // vreg → 溢出栈偏移
    std::unordered_map<int, int> paramVregToLocation; // 参数 vreg → 位置
    std::set<int> usedPhysRegs;                    // 实际使用过的物理寄存器集合
    std::set<int> calleeSavedRegs;                 // 需要保存/恢复的 callee-saved 寄存器
};
```

代码生成器 `RISCVCodeGen` 通过 `funcAllocators_[funcName]->getAllocationResult()` 获取分配结果，在 `resolveUse()`/`resolveDef()` 中查询 vreg 对应的物理寄存器或栈偏移。

---

## 溢出临时寄存器

当 vreg 被溢出到栈时，代码生成阶段需要临时寄存器来执行 `lw`/`sw`：

```cpp
// [reg_alloc.h](../src/include/reg_alloc.h)

int spillTempReg1_ = 5;   // t0 (x5)
int spillTempReg2_ = 6;   // t1 (x6)
int spillTempCounter_ = 0;

int LinearScanAllocator::allocateSpillTempReg() {
    spillTempCounter_ = !spillTempCounter_;
    return spillTempCounter_ ? spillTempReg1_ : spillTempReg2_;
}
```

t0 和 t1 交替使用，避免在同一条指令中两个溢出操作数使用同一个临时寄存器。这两个寄存器在 `RegInfo` 中标记为 `reserved = true`，不参与分配。

---

## 完整示例追踪

以 `int add(int a, int b) { return a + b; }` 为例，追踪完整的分配过程：

**IR**：
```llvm
define i32 @add(i32 %0, i32 %1) {
entry:
  %2 = alloca i32       ; [0] def: %2
  store i32 %0, ptr %2  ; [1] use: %0, %2
  %3 = alloca i32       ; [2] def: %3
  store i32 %1, ptr %3  ; [3] use: %1, %3
  %4 = load i32, ptr %2 ; [4] def: %4, use: %2
  %5 = load i32, ptr %3 ; [5] def: %5, use: %3
  %6 = add i32 %4, %5   ; [6] def: %6, use: %4, %5
  ret i32 %6             ; [7] use: %6
}
```

**Step 1 — processParameters**：
```
vregToPhys[0] = a0(x10)    freePhysRegs -= {a0}
vregToPhys[1] = a1(x11)    freePhysRegs -= {a1}
```

**Step 2 — 活跃性分析**：（单个基本块，无迭代）
```
useSet = {%0, %1}   defSet = {%2, %3, %4, %5, %6}
liveIn = {%0, %1}   liveOut = {}
```

**Step 3 — 指令线性化**：如上表 index 0-7

**Step 4 — 构建活跃区间**：
```
%0: [(0, 3)]  — 参数，被 store 使用
%1: [(0, 7)]  — 参数，被 store 使用
%2: [(0, 9)]  — alloca，被 store 和 load 使用
%3: [(4, 11)] — alloca，被 store 和 load 使用
%4: [(8, 13)] — load 定义，add 使用
%5: [(10, 13)]— load 定义，add 使用
%6: [(12, 15)]— add 定义，ret 使用
```

**Step 5 — 线性扫描**（按 start 排序后遍历）：
```
处理 %0 (start=0): 已预分配 → 插入 active [a0]
处理 %1 (start=0): 已预分配 → 插入 active [a0, a1]
处理 %2 (start=0): 分配 a2 → active [a0, a1, a2]
处理 %3 (start=4): expire无过期 → 分配 a3 → active [a0, a1, a2, a3]
处理 %4 (start=8): expire %0(end=3) → 回收 a0 → 分配 a0 → active [a1, a2, a3, a0]
处理 %5 (start=10): expire %1(end=7) → 回收 a1 → 分配 a1 → active [a2, a3, a0, a1]
处理 %6 (start=12): expire %2(end=9), %3(end=11) → 回收 a2,a3 → 分配 a2
                     → active [a0, a1, a2]
```

**最终分配**：
```
%0 → a0   %1 → a1   %2 → a2   %3 → a3
%4 → a0   %5 → a1   %6 → a2
calleeSavedRegs = {}（未使用任何 s 寄存器）
```
