# 寄存器分配完整调用流程详解

## 总览：入口函数调用栈

```
allocate(F)                          // 主入口
├─ processParameters()               // 1. 处理函数参数
├─ LivenessAnalysis::run()          // 2. 活跃性分析
│  ├─ computeUseDefSets()           //    2.1 计算use/def集合
│  └─ computeLivenessIteratively()  //    2.2 迭代计算活跃性
│     └─ buildRPO()                 //        2.2.1 构建逆后序遍历
├─ assignInstrPositions()           // 3. 指令线性化编号
├─ LiveIntervalBuilder::build()     // 4. 构建活跃区间
│  └─ buildIntervalForVreg()        //    4.1 为每个虚拟寄存器构建区间
└─ runLinearScan()                  // 5. 执行线性扫描分配
   ├─ sortIntervalsByStart()        //    5.1 按起始位置排序区间
   └─ [对每个区间]
      ├─ expireOldIntervals()       //    5.2 释放过期区间
      ├─ allocatePhysicalReg()      //    5.3 分配物理寄存器
      │  └─ insertActiveInterval()  //        5.3.1 插入active列表
      └─ spillAtInterval()           //    5.4 溢出处理
         └─ chooseSpillCandidate()   //        5.4.1 选择溢出候选
```

---

## 详细流程解析

### 阶段0：预处理 - 控制流图构建

**在调用allocate之前**，IR解析器已经调用了：

```cpp
FunctionIR::buildControlFlowGraph()
```

**功能**：分析每个基本块的终止指令（br/ret），建立前驱后继关系

**核心逻辑**：
```cpp
void FunctionIR::buildControlFlowGraph()
{
    // 清空现有关系
    for (auto &block : blocks)
    {
        block->succ.clear();
        block->pred.clear();
    }

    // 分析终止指令
    for (auto &block : blocks)
    {
        auto &lastInst = block->insts.back();
        
        if (lastInst->isTerminator())
        {
            // 获取分支目标标签
            std::vector<std::string> targets = lastInst->branchTargets();
            
            for (const std::string &target : targets)
            {
                BasicBlock *succBlock = nameToBlock[target];
                block->succ.push_back(succBlock);        // 添加后继
                succBlock->pred.push_back(block.get());  // 添加前驱
            }
        }
        else
        {
            // fall-through到下一个块
            BasicBlock *nextBlock = blocks[currentIdx + 1].get();
            block->succ.push_back(nextBlock);
            nextBlock->pred.push_back(block.get());
        }
    }
}
```

**输出**：每个BasicBlock的`succ`和`pred`列表已填充

---

### 阶段1：参数处理

```cpp
void processParameters(const std::vector<int> &paramVregs)
```

**目的**：预分配函数参数到ABI规定的寄存器/栈位置

**算法**：
1. 前8个参数 → a0-a7寄存器（物理寄存器10-17）
2. 第9+个参数 → 栈上正偏移位置

**关键操作**：
```cpp
// 前8个参数
for (int i = 0; i < min(8, paramCount); ++i)
{
    int argRegId = 10 + i;  // a0是寄存器10
    result.vregToPhys[vreg] = argRegId;
    isPhysRegUsed[argRegId] = true;
    freePhysRegs.erase(argRegId);  // 从空闲池移除
}

// 第9+个参数
for (size_t i = stackParamCount, tmp = 1; i > 0; --i, ++tmp)
{
    int stackOffset = 4 * tmp;  // 正偏移
    result.vregToStack[vreg] = stackOffset;
}
```

**输出**：
- `result.paramVregToLocation`：参数虚拟寄存器 → 物理位置映射
- `freePhysRegs`：已排除参数寄存器
- `isPhysRegUsed`：标记参数寄存器为已使用

---

### 阶段2：活跃性分析

#### 2.1 计算use/def集合

```cpp
void computeUseDefSets(FunctionIR &F)
```

**遍历顺序**：按原始基本块顺序（`F.blocks`）

**对每个基本块**：
```cpp
for (auto &block : F.blocks)
{
    block->useSet.clear();
    block->defSet.clear();

    // 按指令顺序处理
    for (auto &inst : block->insts)
    {
        // 先处理use（使用）
        for (int vreg : inst->uses())
        {
            // 关键：只有在该寄存器尚未被定义时，才算"首次使用"
            if (!block->defSet.count(vreg))
                block->useSet.insert(vreg);
        }

        // 再处理def（定义）
        int defVreg = inst->def();
        if (defVreg != -1)
            block->defSet.insert(defVreg);
    }
}
```

**示例**：
```llvm
BB1:
  %1 = add %2, %3   ; use: %2, %3 → useSet={%2, %3}
                     ; def: %1 → defSet={%1}
  %4 = mul %1, %2   ; use: %1(已在def中，不加), %2(已在use中)
                     ; def: %4 → defSet={%1, %4}
```

**输出**：
- `block->useSet`：在块内首次使用前未定义的寄存器
- `block->defSet`：在块内被定义的寄存器
- `F.maxVregId`：最大虚拟寄存器ID

---

#### 2.2 构建RPO（逆后序遍历）

```cpp
std::vector<BasicBlock*> buildRPO(BasicBlock *entry)
```

**目的**：确定数据流分析的遍历顺序，加速收敛

**算法**：后序DFS + 反转

```cpp
std::vector<BasicBlock*> order;
std::unordered_set<BasicBlock*> visited;
std::stack<std::pair<BasicBlock*, bool>> stk;

stk.push({entry, false});  // (块, 是否已处理后继)

while (!stk.empty())
{
    auto [bb, processed] = stk.top();
    stk.pop();
    
    if (processed)
    {
        order.push_back(bb);  // 后序：所有后继处理完才加入
        continue;
    }
    
    if (!visited.insert(bb).second) continue;  // 已访问过
    
    stk.push({bb, true});  // 标记待处理
    
    // 逆序压入后继（保持原顺序）
    for (auto it = bb->succ.rbegin(); it != bb->succ.rend(); ++it)
        stk.push({*it, false});
}

std::reverse(order.begin(), order.end());  // 反转得到RPO
return order;
```

**为什么需要RPO**？

在CFG中，RPO保证：
- 对于大多数边 `A → B`，A在B之前被访问
- 对于循环，只有回边违反这个规则
- 加速数据流方程的收敛（通常2-3轮）

**示例**：
```
      BB1
     /   \
   BB2   BB3
     \   /
      BB4
```

**DFS后序**：`[BB2, BB3, BB4, BB1]`  
**RPO**：`[BB1, BB4, BB3, BB2]` ❌（错误）

实际RPO应该是：`[BB1, BB2, BB3, BB4]` ✓

**输出**：`F.blocksInOrder` = RPO顺序的基本块列表

---

#### 2.3 迭代计算活跃性

```cpp
void computeLivenessIteratively(FunctionIR &F)
```

**数据流方程**：
```
LiveOut(B) = ∪(s∈succ(B)) LiveIn(s)
LiveIn(B)  = use(B) ∪ (LiveOut(B) - def(B))
```

**迭代算法**：
```cpp
F.blocksInOrder = buildRPO(F.entryBlock());  // 已完成

bool changed = true;
while (changed)
{
    changed = false;
    
    // 逆序遍历（从出口到入口，反向数据流）
    for (int i = blocksInOrder.size() - 1; i >= 0; --i)
    {
        BasicBlock *block = F.blocksInOrder[i];

        // 计算 LiveOut = ∪(LiveIn of successors)
        std::set<int> newLiveOut;
        for (BasicBlock *succ : block->succ)
            newLiveOut.insert(succ->liveIn.begin(), succ->liveIn.end());

        // 计算 LiveIn = use ∪ (LiveOut - def)
        std::set<int> newLiveIn = block->useSet;
        for (int vreg : newLiveOut)
            if (!block->defSet.count(vreg))
                newLiveIn.insert(vreg);

        // 检查不动点
        if (newLiveIn != block->liveIn || newLiveOut != block->liveOut)
        {
            changed = true;
            block->liveIn.swap(newLiveIn);
            block->liveOut.swap(newLiveOut);
        }
    }
}
```

**为什么逆序遍历**？

活跃性是**反向数据流**问题：
- LiveOut依赖后继的LiveIn
- 从出口向入口传播信息

**迭代示例**：
```llvm
BB1: %1 = ...       use={}, def={%1}
     br BB2, BB3

BB2: %2 = add %1    use={%1}, def={%2}
     br BB4

BB3: %3 = mul %1    use={%1}, def={%3}
     br BB4

BB4: ret %2         use={%2}, def={}
```

| 迭代      | BB      | 操作                              | LiveOut  | LiveIn   |
| --------- | ------- | --------------------------------- | -------- | -------- |
| **初始**  | 所有块  | -                                 | {}       | use集合  |
| **第1轮** | BB4     | -                                 | {}       | {%2}     |
|           | BB3     | LiveOut = BB4.LiveIn              | {%2}     | {%1, %2} |
|           | BB2     | LiveOut = BB4.LiveIn              | {%2}     | {%1, %2} |
|           | BB1     | LiveOut = BB2.LiveIn ∪ BB3.LiveIn | {%1, %2} | {%2}     |
| **第2轮** | BB4-BB1 | 检查                              | 不变     | 不变     |
| **收敛**  | -       | changed=false                     | -        | -        |

**输出**：
- `block->liveIn`：块入口活跃的虚拟寄存器集合
- `block->liveOut`：块出口活跃的虚拟寄存器集合

---

### 阶段3：指令线性化编号

```cpp
void assignInstrPositions(FunctionIR &F)
```

**目的**：为每条指令分配全局唯一的位置编号

**遍历顺序**：按RPO顺序（`F.blocksInOrder`）

**算法**：
```cpp
int pos = 0;
for (BasicBlock *block : F.blocksInOrder)
{
    for (auto &inst : block->insts)
    {
        inst->idx = pos++;
    }
}
```

**位置编号方案**：
- `inst->idx`：指令编号（0, 1, 2, ...）
- `inst->posDef()`：定义点 = `idx * 2`
- `inst->posUse()`：使用点 = `idx * 2 + 1`

**示例**：
```
指令0: %1 = add %2, %3
  idx=0, posDef=0, posUse=1
  
指令1: %4 = mul %1, %5
  idx=1, posDef=2, posUse=3
```

**为什么双位编号**？

在同一条指令内，**使用发生在定义之后**：
```
%1 = add %1, %2   ; 先使用旧%1（pos=1），再定义新%1（pos=0）
```

但实际上你的代码里定义在前：
```cpp
int posDef() const { return idx * 2; }
int posUse() const { return idx * 2 + 1; }
```

这意味着：**在同一指令内，使用发生在定义之后**（先def再use）

**输出**：每条指令的`idx`字段已设置

---

### 阶段4：构建活跃区间

```cpp
std::unordered_map<int, unique_ptr<LiveInterval>> 
LiveIntervalBuilder::build()
```

**对每个虚拟寄存器**（0 到 `maxVregId`）：

```cpp
for (int vreg = 0; vreg <= F.maxVregId; ++vreg)
{
    auto interval = new LiveInterval(vreg);
    buildIntervalForVreg(vreg, interval);  // 核心算法
    if (!interval->empty())
        intervals[vreg] = interval;
}
```

---

#### 4.1 为单个虚拟寄存器构建区间

```cpp
void buildIntervalForVreg(int vreg, LiveInterval *interval)
```

**遍历顺序**：按RPO顺序（`F.blocksInOrder`）

**对每个基本块**：

```cpp
for (BasicBlock *block : F.blocksInOrder)
{
    // 1. 检查是否相关
    bool liveAtStart = block->liveIn.count(vreg);
    bool liveAtEnd = block->liveOut.count(vreg);
    
    if (!liveAtStart && !liveAtEnd)
    {
        // 检查块内是否有def/use
        bool hasDefOrUse = false;
        for (auto &inst : block->insts)
        {
            if (inst->def() == vreg || 包含(inst->uses(), vreg))
                hasDefOrUse = true;
        }
        if (!hasDefOrUse) continue;  // 跳过不相关的块
    }

    // 2. 初始化范围
    int rangeStart = liveAtStart ? block->firstPos() : -1;
    int rangeEnd = liveAtEnd ? block->lastPos() : -1;

    // 3. 扫描块内指令，精确计算范围
    for (auto &inst : block->insts)
    {
        // 处理定义
        if (inst->def() == vreg)
        {
            if (rangeStart == -1)
                rangeStart = inst->posDef();
            
            rangeEnd = liveAtEnd ? block->lastPos() : inst->posDef();
        }

        // 处理使用
        for (int useVreg : inst->uses())
        {
            if (useVreg == vreg)
            {
                if (rangeStart == -1)
                    rangeStart = liveAtStart ? block->firstPos() 
                                             : inst->posUse();
                rangeEnd = max(rangeEnd, inst->posUse());
            }
        }
    }

    // 4. 添加范围到区间
    if (rangeStart != -1 && rangeEnd != -1)
        interval->addRange(rangeStart, rangeEnd);
}
```

**关键：`addRange` 自动合并重叠/相邻范围**

```cpp
void LiveInterval::addRange(int start, int end)
{
    LiveRange newRange(start, end);
    
    // 找到插入位置
    auto it = lower_bound(ranges.begin(), ranges.end(), newRange);
    
    // 向前合并
    auto mergeStart = it;
    while (mergeStart != ranges.begin())
    {
        auto prev = mergeStart - 1;
        if (prev->overlaps(newRange) || prev->adjacent(newRange))
        {
            newRange.start = min(newRange.start, prev->start);
            newRange.end = max(newRange.end, prev->end);
            mergeStart = prev;
        }
        else break;
    }
    
    // 向后合并
    auto mergeEnd = it;
    while (mergeEnd != ranges.end())
    {
        if (mergeEnd->overlaps(newRange) || mergeEnd->adjacent(newRange))
        {
            newRange.start = min(newRange.start, mergeEnd->start);
            newRange.end = max(newRange.end, mergeEnd->end);
            ++mergeEnd;
        }
        else break;
    }
    
    // 删除被合并的旧范围，插入新范围
    ranges.erase(mergeStart, mergeEnd);
    ranges.insert(mergeStart, newRange);
}
```

**示例**：
```llvm
BB1: [0-5]
  %1 = ...         ; def at 0
  br BB2, BB3

BB2: [6-9]
  %2 = add %1      ; use at 7
  br BB4

BB3: [10-13]
  %3 = mul %1      ; use at 11
  br BB4

BB4: [14-17]
  %4 = phi %2, %3
```

**%1的活跃区间构建过程**：
1. BB1: def at 0, liveOut=true → `addRange(0, 5)`
2. BB2: liveIn=true, use at 7 → `addRange(6, 7)`
3. BB3: liveIn=true, use at 11 → `addRange(10, 11)`
4. BB4: 无关，跳过

**自动合并后**：`%1 = [0, 5] [6, 7] [10, 11]`

**输出**：`intervals` = {vreg → LiveInterval对象}

---

### 阶段5：线性扫描分配

```cpp
AllocationResult runLinearScan(
    const unordered_map<int, unique_ptr<LiveInterval>> &intervals)
```

#### 5.1 按起始位置排序

```cpp
std::vector<LiveInterval*> sortedIntervals;
for (const auto &pair : intervals)
    sortedIntervals.push_back(pair.second.get());

sortIntervalsByStart(sortedIntervals);
```

**排序规则**：按 `interval->start()` 升序

**输出**：`sortedIntervals` = 按生命周期开始位置排序的区间列表

---

#### 5.2 对每个区间分配

```cpp
for (LiveInterval *interval : sortedIntervals)
{
    expireOldIntervals(interval->start());  // 释放过期区间
    
    if (allocatedVregs.count(interval->vreg))
    {
        spillAtInterval(*interval);  // 已分配过，溢出
    }
    else if (freePhysRegs.empty())
    {
        spillAtInterval(*interval);  // 无空闲寄存器，溢出
    }
    else
    {
        allocatePhysicalReg(*interval);  // 分配寄存器
        allocatedVregs.insert(interval->vreg);
    }
}
```

---

#### 5.2.1 释放过期区间

```cpp
void expireOldIntervals(int curStart)
{
    auto it = active.begin();
    while (it != active.end())
    {
        LiveInterval *interval = *it;
        
        if (interval->end() < curStart)  // 生命周期已结束
        {
            freePhysReg(interval->physReg);  // 释放物理寄存器
            it = active.erase(it);
        }
        else break;  // active按end排序，后面都不会过期
    }
}
```

**关键**：`active` 列表按 `interval->end()` 排序

---

#### 5.2.2 分配物理寄存器

```cpp
void allocatePhysicalReg(LiveInterval &interval)
{
    int physReg = allocatePhysReg();  // 从freePhysRegs取优先级最高的
    
    interval.physReg = physReg;
    result.vregToPhys[interval.vreg] = physReg;
    
    insertActiveInterval(&interval);  // 插入active列表（按end排序）
}
```

**`allocatePhysReg()` 实现**：

```cpp
int allocatePhysReg()
{
    if (freePhysRegs.empty()) return -1;
    
    int bestReg = *freePhysRegs.begin();  // set按priority排序
    freePhysRegs.erase(freePhysRegs.begin());
    isPhysRegUsed[bestReg] = true;
    
    return bestReg;
}
```

**`insertActiveInterval()` 实现**：

```cpp
void insertActiveInterval(LiveInterval *interval)
{
    auto it = lower_bound(active.begin(), active.end(), interval,
                          [](LiveInterval *a, LiveInterval *b) {
                              return a->end() < b->end();
                          });
    active.insert(it, interval);
}
```

---

#### 5.2.3 溢出处理

```cpp
void spillAtInterval(LiveInterval &interval)
{
    if (active.empty())
    {
        // 直接溢出当前区间
        int spillSlot = allocateSpillSlot();
        interval.spillSlot = spillSlot;
        result.vregToStack[interval.vreg] = spillSlot;
        return;
    }
    
    // 选择溢出候选
    int spillIdx = chooseSpillCandidate(interval);
    LiveInterval *spillCandidate = active[spillIdx];
    
    if (spillCandidate->end() > interval.end())
    {
        // 溢出候选，将其寄存器给当前区间
        int physReg = spillCandidate->physReg;
        
        int spillSlot = allocateSpillSlot();
        spillCandidate->spillSlot = spillSlot;
        spillCandidate->physReg = -1;
        result.vregToStack[spillCandidate->vreg] = spillSlot;
        
        active.erase(active.begin() + spillIdx);
        
        interval.physReg = physReg;
        result.vregToPhys[interval.vreg] = physReg;
        insertActiveInterval(&interval);
    }
    else
    {
        // 溢出当前区间
        int spillSlot = allocateSpillSlot();
        interval.spillSlot = spillSlot;
        result.vregToStack[interval.vreg] = spillSlot;
    }
}
```

**`chooseSpillCandidate()` 实现**：

```cpp
int chooseSpillCandidate(const LiveInterval &current) const
{
    int maxEndPos = -1;
    int candidateIdx = 0;
    
    for (size_t i = 0; i < active.size(); ++i)
    {
        if (active[i]->end() > maxEndPos)
        {
            maxEndPos = active[i]->end();
            candidateIdx = i;
        }
    }
    
    return candidateIdx;  // 选择end最大的
}
```

**`allocateSpillSlot()` 实现**：

```cpp
int allocateSpillSlot()
{
    int nextOffset = -(result.vregToStack.size() + 2) * 4;
    return nextOffset;  // 负偏移，栈向下增长
}
```

---

## 总结

### 完整流程图

```
[IR字符串] 
   ↓
parseFunctionFromLLVMIR()
   ↓
[FunctionIR + blocks + CFG]
   ↓
allocate()
   ├─ processParameters()          → 预分配参数寄存器
   ├─ LivenessAnalysis::run()
   │  ├─ computeUseDefSets()       → 计算use/def集合
   │  └─ computeLivenessIteratively()
   │     └─ buildRPO()             → **块线性化（RPO）**
   │        └─ 迭代不动点          → 计算LiveIn/LiveOut
   ├─ assignInstrPositions()       → 指令线性化编号
   ├─ LiveIntervalBuilder::build()
   │  └─ buildIntervalForVreg()    → 构建活跃区间
   │     └─ addRange()             → 自动合并范围
   └─ runLinearScan()
      ├─ sortIntervalsByStart()     → 按起始位置排序
      └─ [对每个区间]
         ├─ expireOldIntervals()    → 释放过期区间
         ├─ allocatePhysicalReg()   → 分配寄存器
         │  └─ insertActiveInterval() → 维护active列表
         └─ spillAtInterval()        → 溢出处理
            └─ chooseSpillCandidate() → 选择溢出候选
   ↓
[AllocationResult]
```

### 关键数据结构状态变化

| 阶段        | 数据结构                  | 状态                    |
| ----------- | ------------------------- | ----------------------- |
| 0-CFG       | `block->succ/pred`        | 已填充前驱后继          |
| 1-参数      | `result.vregToPhys`       | 参数已预分配            |
|             | `freePhysRegs`            | 已排除参数寄存器        |
| 2.1-use/def | `block->useSet/defSet`    | 已计算                  |
| 2.2-RPO     | `F.blocksInOrder`         | RPO顺序的块列表         |
| 2.3-活跃性  | `block->liveIn/liveOut`   | 已收敛                  |
| 3-编号      | `inst->idx`               | 已分配全局编号          |
| 4-区间      | `intervals`               | vreg → LiveInterval映射 |
| 5-分配      | `result.vregToPhys/Stack` | 最终分配结果            |
|             | `active`                  | 当前活跃区间列表        |

希望这次的解释足够详细清晰！